[{"title":"DNS 与 TCP","path":"/2021/08/20/dns-and-tcp/","content":"一图概览 DNS &amp; hostsDNS，全称：Domain Name System，中文：域名系统 域名系统本身的原理是比较复杂的，但域名系统的功能很简单，就是输入一个域名，输出一个 IP，这里我们只对 DNS 做简单讨论 举例说明： 在浏览器输入 baidu.com 这个地址 浏览器需要知道你访问的这个地址对应的 IP 是多少，于是浏览器就会去问操作系统 如果操作系统也不知道，就会去问电信、移动、联通这样的网络运行商（以下简称 ISP） 当你付费之后，网络运营商就会告诉你 baidu.com 这个地址对应的 IP 是多少（假设这里 baidu.com 对应的 IP 是 1.2.3.4），然后将 IP 返回给你 浏览器获取到 baidu.com 对应的 IP 之后，就会与 1.2.3.4 这个 IP 建立 TCP 连接 细化过程： 在浏览器输入 baidu.com 这个地址的时候，浏览器首先会去检查自身是否有缓存，如果发现之前访问过 baidu.com ，那么浏览器就会直接将上一次的 IP 进行返回 如果浏览器没有缓存，就回去询问操作系统，然后操作系统首先也是会检查自身是否有缓存，如果没有就会去询问 ISP（网络运行商） 平时我们修改 hosts 这个文件，其实就是在手动给操作系统设置缓存，比如我们在 hosts 中写入baidu.com 2.3.4.5，以后每次访问 baidu.com 这个地址的时候就不会再去询问 ISP 了，直接会通过 hosts 中的设置去访问 2.3.4.5 这个 IP TCP 三次握手TCP 全称：Transmission Control Protocol，即传输控制协议 假设 A 是浏览器，B 是服务器 A 首先会向 B 发送一个叫做SYN(x)（假设这里 x &#x3D; 100）的信息 SYN 是 synchronize(同步) 的缩写，同步不是指「同步异步」中的同步，而是「同步信息」中的同步；这里的 x 一般是一个数字编号，且 x 和 y 一般都是从 0 开始的，这里我们对 x 和 y 的意义不做讨论，有兴趣的请自行研究 B 收到 A 发来的同步信息后，就会返回ACK(x+1)（101） SYN(y)（这里假设 y &#x3D; 200） ACK 是 acknowledge(知道) 的缩写 然后 A 会回复消息 ACK(y+1)（201）给 B 从以上过程中能够确保以下几件事： A 可以向 B 发送信息 B 能收到 A 发送的信息 B 也可以向 A 发送信息 A 也能收到 B 发送的信息 三次握手成功后就开始建立 TCP 连接了，建立连接后就可以开始传输内容了（一般是 HTTP 内容，也可以是其他内容，且传输的过程也可以是双向的，并非一定是单向的），HTTP 内容传输结束后，就会「关闭」 TCP 四次挥手 上述内容传输完成后，A 会发送一个FIN(x) 注意：不一定是 A 先发送 FIN，也可以是 B 先发送 B 先回复ACK(x+1) 注意：关闭时的 x 和 y 一般都不是 0 然后再回复FIN(y) 步骤 2 和步骤 3 中间可能会夹杂着其他内容 A 回复ACK(y+1) 最后，A 和 B 各自关闭自己的 TCP 连接 一些 Q &amp; A为什么需要关闭 TCP 连接？因为一直保持连接会浪费内存和 CPU TCP 和 UDP 的区别是什么？ 八股文，面试必背 TCP 面向连接有状态，UDP 无状态 TCP 可靠（不丢失不重复），UDP 不可靠 TCP 传输效率较低，UDP 较高 为什么 TCP 的三次握手不能精简为两次？为了确保客户端（A端）能接收到服务端（B端）的数据（只有两次的话，无法判断 A 是否能接收到 B 的数据） 为什么 TCP 的四次挥手不能将中间两步合并成一步？因为两步中间（指发送ACK(x+1)和FIN(y)之间）往往会有其他数据需要发送，需要等其他数据发送完成之后，再发送FIN(y)","tags":["DNS","TCP"],"categories":["学习"]},{"title":"浅析 Promise、Async/Await","path":"/2021/08/17/promise-async-await/","content":"Promise基本用法Promise 的简单封装与使用 1234567891011// 封装function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(Math.floor(Math.random() * 6) + 1) &#125;, 3000) &#125;)&#125;// 使用摇色子().then(success1, failed1).then(success2, failed2) Ma Mi 任务模型 Ma 指 MacroTask(宏任务)，Mi 指 MicroTask(微任务) 先 Ma 再 Mi，即先执行宏任务再执行微任务 JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务 其实最初 JS 只存在一个任务队列，为了让 Promise 回调更早执行，强行又插入了一个异步的任务队列，用来存放 Mi 任务 宏任务：setTimeout()、setInterval()、 setImmediate()、 I&#x2F;O、UI渲染（常见的定时器，用户交互事件等等） 微任务：Promise、process.nextTick、Object.observe、MutationObserver Promise 的其他 APIPromise.resolve(result): 制造一个成功（或失败）制造成功 123456789101112function 摇色子() &#123; return Promise.resolve(4)&#125;// 等价于function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(4) &#125;)&#125;摇色子().then(n =&gt; console.log(n)) // 4 制造失败 123456function 摇色子() &#123; // 此处 Promise.resolve 接收的是一个失败的 Promise 实例（状态为 reject） return Promise.resolve(new Promise((resolve, reject) =&gt; reject()))&#125;摇色子().then(n =&gt; console.log(n)) // 1 Uncaught (in promise) undefined 关于 Promise.resolve 接收参数的问题，ECMAScript 6 入门里其实说得很清楚 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例；如果参数是一个原始值，或者没有参数，Promise.resolve都会直接返回一个resolved状态的 Promise 对象。 Promise.reject(reason): 制造一个失败12345Promise.reject(&#x27;我错了&#x27;)// 等价于new Promise((resolve, reject) =&gt; reject(&#x27;我错了&#x27;))Promise.reject(&#x27;我错了&#x27;).then(null, reason =&gt; console.log(reason)) // 我错了 Promise.all(数组): 等待全部成功，或者有一个失败全部成功，将所有成功 promise 结果组成的数组返回 12Promise.all([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]) .then(values =&gt; console.log(values)) // [1, 2, 3] 只要有一个失败，就结束，返回最先被 reject 失败状态的值 12Promise.all([Promise.reject(1), Promise.resolve(2), Promise.resolve(3)]) .then(values =&gt; console.log(values)) // Uncaught (in promise) 1 Promse.all 在需要对多个异步进行处理时往往非常有用； 不过在某些特殊情况下，直接使用Promse.all就显得不那么方便了 举个例子，比如现在有 3 个请求，request1, request2 和 request3，我们需要对这 3 个请求进行统一处理，并且不管请求成功还是失败，都需要拿到所有的响应结果，如果这时候使用Promise.all([request1, request2, request3])的话，request1 请求失败了，后面的两个请求 request2, request3 就都不会执行了（这里实际上是 request1 在 rejected 之后，被 Promise.all([]).catch 给捕获了 ）。 如何解决 Promise.all() 在第一个 Promise 失败就会中断的问题？ 利用 .then() 后会返回一个状态为 resolved 的 Promise（即会自动包装成一个已resolved的promise），从而避免被 Promise.all([]).catch 捕获 123456789101112131415161718192021222324// 3 个请求const request1 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;第 1 个请求失败&#x27;) &#125;, 1000)&#125;)const request2 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;第 2 个请求失败&#x27;) &#125;, 2000)&#125;)const request3 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;第 3 个请求成功&#x27;) &#125;, 3000)&#125;)Promise.all([ request1().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;)), request2().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;)), request3().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;))]).then(result =&gt; console.log(result)) 可以把对每个请求的.then操作封装一下 123456789101112const x = promiseList =&gt; promiseList.map(promise =&gt; promise.then(value =&gt; (&#123; status: &#x27;ok&#x27;, value&#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason&#125;)))const xxx = promiseList =&gt; Promise.all(x(promiseList))xxx([request1(), request2(), request3()]) .then(result =&gt; console.log(result)) 打印结果如下： Promise.allSettled(数组): 等待全部状态改变12Promise.allSettled([Promise.reject(1), Promise.resolve(2), Promise.resolve(3)]) .then(result =&gt; console.log(result)) 打印结果如下： 可以看出 Promise.allSettled 的作用其实和上面我们实现的 xxx 函数的作用是一致的，因此针对上文提到场景，可以直接使用 Promise.allSettled，更加简洁。 Promise.race(数组): 等待第一个状态改变12345Promise.race([request1(), request2(), request3()]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 第 1 个请求失败&#125;) Promise.race([request1, request2, request3])里面哪个请求最先响应，就返回其对应的结果，不管结果本身是成功状态还是失败状态（这里最先响应的请求是 request1）。 一般情况下用不到 Promise.race 这个 api，不过在某些场景下还是有用的。例如在多台服务器部署了同样的服务端代码，要从一个商品列表的接口拿数据，这时候就可以在 race 中写上所有服务器中的查询商品列表的接口地址，哪个服务器响应快，就优先从哪个服务器拿数据。 Promise 的应用场景多次处理一个结果1摇色子().then(v =&gt; v1).then(v1 =&gt; v2) 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 串行 这里有一个悖论：一旦 promise 出现，那么任务就已经执行了 所以不是 promise 串行，而是任务串行 解法：把任务放进队列，完成一个再做下一个（用 Reduce 实现 Promise 串行执行） 并行Promise.all、Promise.allSettled、Promise.race都可以看作是并行地在处理任务 这里可能你会产生疑问，JS 不是单线程吗，怎么做到并行执行任务？ 这里指的是并行地做网络请求的任务，而网络请求实际上是由浏览器来做的，并非是 JS 做的，就像 setTimeout 是浏览器的功能而不是 JS 的，setTimeout 只是浏览器提供给 JS 的一个接口。 Promise 的错误处理自身的错误处理promise 自身的错误处理其实挺好用的，直接在.then的第二个回调参数中进行错误处理即可 1promise.then(s1, f1) 或者使用.catch语法糖 12// 上面写法的语法糖promise.then(s1).catch(f1) 建议总是使用catch()方法，而不使用then()方法的第二个参数，原因是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch） 全局错误处理以axios为例，Axios 作弊表 错误处理之后 如果你没有继续抛错，那么错误就不再出现 如果你继续抛错，那么后续回调就要继续处理错误 前端似乎对 Promise 不满Async&#x2F;Await替代Promise的6个理由，主要是以下 6 个方面： 简洁 错误处理 条件语句 中间值 错误栈 调试（在.then代码块中设置断点，使用 Step Over 快捷键，调试器不会跳到下一个.then，因为它只会跳过异步代码） async &#x2F; awaitasync &#x2F; await 基本用法最常见的用法 1234const fn = async() =&gt; &#123; const temp = await makePromise() return temp + 1&#125; 优点：完全没有缩进，就像是在写同步代码 封装一个 async 函数async的封装和使用 1234567891011121314function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(Math.floor(Math.random() * 6) + 1) &#125;, 3000) &#125;)&#125;async function fn() &#123; const result = await 摇色子() console.log(result)&#125;fn() 用try...catch进行错误处理 1234567891011121314async function 摇色子() &#123; throw new Error(&#x27;色子坏了&#x27;)&#125;async function fn() &#123; try &#123; const result = await 摇色子() console.log(result) &#125; catch (error) &#123; console.log(error) &#125;&#125;fn() 为什么需要 async在函数前面加一个async，这看起来非常多余，await所在的函数就是async，不是吗？ 理由之一： 在 ES 标准的 async&#x2F;await 出来之前，有些人自己用函数实现了 await，为了兼容旧代码里普通函数的 await(xxx)（为了将旧代码里面的 await 和新的 ES 标准里的 async&#x2F;await 区分开来），其实 async 本身并没有什么意义。 你可能会说，async函数会隐式地返回一个 Promise 对象呀，但这并不能成为必须要在函数前加async的理由，有兴趣的可以去看看知乎上关于async的讨论。 为什么js里使用了await的方法必须定义成async的？ C#中，async关键字到底起什么作用？ await 错误处理用 try&#x2F;catch 来同时处理同步和异步错误是很常见的做法 12345678910let responsetry &#123; response = await axios.get(&#x27;/xxx&#x27;)&#125; catch (e) &#123; if (e.response) &#123; console.log(e.response.status) throw e &#125;&#125;console.log(response) 但其实还有更好的写法，就像下面这样 123456789101112const errorHandler = error =&gt; &#123; console.log(error) // 注意这里要抛出一个错误 throw error // 或者 return Promise.reject(error)，注意：一定要 return&#125;// 只用一句代码就可以处理成功和失败const response = await axios.get(&#x27;/xxx&#x27;).then(null, errorHandler)// 或者使用 catch 语法糖const response = await axios.get(&#x27;/xxx&#x27;).catch(errorHandler) 需要注意的是，errorHandler函数中不要直接return一个值，一定要抛出一个错误（打断程序的运行）。因为在请求调用失败的情况下，会把errorHandler里return的值直接赋值给 response（通俗的说法就是“Promise 会吃掉错误”），在errorHandler中抛出一个错误能够保证在请求成功的情况下才会有 response，请求失败的情况下一定是会进入errorHandler函数中的 下面是一个实际的例子 123456789101112131415161718const ajax = function() &#123; return new Promise((resolve, reject) =&gt; &#123; reject(&#x27;这是失败后的提示&#x27;) // resolve(&#x27;这是成功后的结果&#x27;) &#125;)&#125;const error = (error) =&gt; &#123; console.log(&#x27;error:&#x27;, error) return Promise.reject(error)&#125;async function fn() &#123; const response = await ajax().then(null, error) console.log(&#x27;response:&#x27;, response)&#125;fn() 可以看到，我们仅仅只用了一句代码就可以同时处理 Promise 成功和失败的情况了，绝大多数的 ajax 调用都是可以用这样的方式来处理的。 所以，对于async/await，并不是一定需要使用try/catch来做错误处理的。 之前我常常陷入一个误区：就是认为await和.then是对立的，始终觉得用了await后就不应该再出现.then。 但其实并非如此，说到底async/await也只不过是.then的语法糖而已。就像上面的例子一样，.then和await完全是可以结合在一起使用的，在.then中进行错误处理，而await左边只接受成功结果。 另外，我们还可以把 4xx&#x2F;5xx 等常见错误用拦截器全局处理，errorHandler也可以放在拦截器里。 await 的传染性代码： 123console.log(1)await console.log(2)console.log(3) // await 会使这句代码变成异步的，如果想要让他立即执行，放到 await 前面即可 分析： await会使得所有它左边的和下面的代码变成异步代码 console.log(3)变成异步任务了 Promise 同样有传染性（同步变异步），放到.then回调函数中的代码会变成异步的，不过相比于await，.then下面的代码并不会变成异步的 回调没有传染性 await 的应用场景多次处理一个结果123const r1 = await makePromise()const r2 = handleR1(r1)const r3 = handleR2(r2) 串行天生串行（多个await并排时，从上到下依次执行，后面的会等前面执行完了再执行） 1234await promise1await promise2await promise3... 并行同 Promise，await Promise.all([p1, p2, p3])、await Promise.allSettled([p1, p2, p3])、await Promise.race([p1, p2, p3]) 都是并行的 循环的时候存在 bug正常情况下，即便在循环中，await也应当是串行执行的。 例如 for 循环中的 await 是串行的（后面等前面） 1234567891011121314151617181920async function runPromiseByQueue(myPromises) &#123; for (let i = 0; i &lt; myPromises.length; i++) &#123; await myPromises[i](); &#125;&#125;const createPromise = (time, id) =&gt; () =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(&quot;promise&quot;, id); resolve(); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 4 2 1 但是在某些循环中，如 forEach 和 map 中，await 会并行执行（后面不等前面） 1234567891011121314151617181920async function runPromiseByQueue(myPromises) &#123; myPromises.forEach(async (task) =&gt; &#123; await task(); &#125;);&#125;const createPromise = (time, id) =&gt; () =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(&quot;promise&quot;, id); resolve(); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 1 2 4 后面 JS 又出了一个新的东西 for await…of 来弥补这个 bug 123456789101112131415161718192021async function runPromiseByQueue(myPromises) &#123; // 异步迭代 for await (let item of myPromises) &#123; console.log(&#x27;promise&#x27;, item); &#125;&#125;const createPromise = (time, id) =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; resolve(id); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 4 2 1","tags":["Promise","async/await"],"categories":["学习"]},{"title":"JavaScript Snippets","path":"/2021/07/23/javascript-snippets/","content":":::info收集的一些常用的 JavaScript 代码片段::: 将给定字符串中每个单词的首字母转为大写1234const capitalizeWord = (string) =&gt; string.replace(/\\b[a-z]/g, (char) =&gt; char.toUpperCase());console.log(capitalizeWord(&quot;hello world in javascript&quot;)); // Hello World In Javascript 计算给定字符串的字节长度1234const byteSize = (string) =&gt; new Blob([string]).size;console.log(byteSize(&quot;vivy&quot;)); // 4console.log(byteSize(&quot;潮鸣&quot;)); // 6 将数组元素转换为指定的 HTML 元素，主要用于将数据转换为界面 HTML 格式12345const arrayToHtmlList = (array, tag = &quot;li&quot;) =&gt; array.map((item) =&gt; `&lt;$&#123;tag&#125;&gt;$&#123;item&#125;&lt;/$&#123;tag&#125;&gt;`).join(&quot;&quot;);console.log(arrayToHtmlList([&quot;第一条&quot;, &quot;第二条&quot;])); // &lt;li&gt;第一条&lt;/li&gt;&lt;li&gt;第二条&lt;/li&gt;console.log(arrayToHtmlList([&quot;第一条&quot;, &quot;第二条&quot;], &quot;p&quot;)); // &lt;p&gt;第一条&lt;/p&gt;&lt;p&gt;第二条&lt;/p&gt; 多个数值求平均值1234567const average = (...nums) =&gt; nums.reduce((acc, val) =&gt; acc + val, 0) / nums.length;const ages = [23, 56, 15, 28];// 此代码也展示了函数如何传递不定参数（使用 ES6 扩展运算符）console.log(average(...ages)); // 30.5console.log(average(23, 56, 15, 28)); // 30.5 计算 map 数组按照指定 key 的平均值，也可以给定一个迭代函数123456789101112const averageBy = (array, fn) =&gt; array.map(typeof fn === &quot;function&quot; ? fn : (val) =&gt; val[fn]).reduce((acc, val) =&gt; acc + val, 0) / array.length;const users = [ &#123; name: &quot;saber&quot;, size: 23 &#125;, &#123; name: &quot;vivy&quot;, size: 56 &#125;, &#123; name: &quot;tico&quot;, size: 15 &#125;, &#123; name: &quot;k423&quot;, size: 28 &#125;,];const average1 = averageBy(users, (item) =&gt; item.size);const average2 = averageBy(users, &quot;size&quot;);console.log(average1); // 30.5console.log(average2); // 30.5 封装 localStorage12345678910111213141516171819202122232425const useStorage = (storageKey = &quot;authorization&quot;) =&gt; &#123; const localKey = `devpoint.local.$&#123;storageKey&#125;`; const save = (data) =&gt; &#123; window.localStorage.setItem(localKey, JSON.stringify(data)); &#125;; const get = () =&gt; &#123; const localData = window.localStorage.getItem(localKey); if (localData &amp;&amp; localData !== &quot;&quot;) &#123; return JSON.parse(localData); &#125; else &#123; return false; &#125; &#125;; const clear = () =&gt; &#123; window.localStorage.setItem(localKey, &quot;&quot;); &#125;; return &#123; save, get, clear &#125;;&#125;;const storageAuth = useStorage();const loginInfo = &#123; username: &quot;vivy&quot;, age: 18,&#125;;storageAuth.save(loginInfo);console.log(storageAuth.get()); 计算数组中某个值的重复次数123456789const countOccurrences = (array, value) =&gt; array.reduce( (accumulator, current) =&gt; current === value ? accumulator + 1 : accumulator, 0 );console.log(countOccurrences([...&quot;vivy&quot;], &quot;v&quot;)); // 2console.log(countOccurrences([1, 3, 3, 4, 3, 3, 2, 3], 3)); // 5 检查值是否属于某个数据类型123456789const isCheck = (type, val) =&gt; ![undefined, null].includes(val) &amp;&amp; val.constructor === type;console.log(isCheck(Array, [&quot;a&quot;])); // trueconsole.log(isCheck(Object, &#123;&#125;)); // trueconsole.log(isCheck(ArrayBuffer, new ArrayBuffer())); // trueconsole.log(isCheck(Boolean, new Boolean(true))); // trueconsole.log(isCheck(RegExp, /./g)); // trueconsole.log(isCheck(Number, 0)); // true 遍历对象的每个属性，并分别为每个属性迭代一个回调123456789101112const forObject = (obj, callback) =&gt; Object.keys(obj).forEach((key) =&gt; callback(obj[key], key, obj));const testObj = &#123; word: &quot;信じる心があなたの魔法〜&quot;, author: &quot;篝敦子&quot;,&#125;;forObject(testObj, (val, key) =&gt; &#123; console.log(`$&#123;key&#125;:$&#123;val&#125;`);&#125;);// word:信じる心があなたの魔法〜// author:篝敦子 通过键值查找对象，返回满足给定函数的第一个 key12345678910const findKey = (obj, fn) =&gt; Object.keys(obj).find((key) =&gt; fn(obj[key], key, obj));const testObj = &#123; vivy: &#123; age: 17 &#125;, k423: &#123; age: 18 &#125;, saber: &#123; age: 19 &#125;,&#125;;console.log(findKey(testObj, (item) =&gt; item.age &gt; 18)); // saber 将一组数据按照指定的 key 的进行分组，并按照分组进行归类1234567891011121314151617181920212223242526272829303132333435363738const groupBy = (obj, key) =&gt; &#123; const values = obj instanceof Map || obj instanceof Set ? Array.from(obj.values()) : Object.values(obj); return values.reduce((acc, value) =&gt; &#123; const groupKey = value[key]; if (!Array.isArray(acc[groupKey])) &#123; acc[groupKey] = [value]; &#125; else &#123; acc[groupKey].push(value); &#125; return acc; &#125;, &#123;&#125;);&#125;;const arrayRoles = [ &#123; title: &quot;Mieruko-chan&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Vladilena Mirizé&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Nakano Azusa&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Shirahane Suou&quot;, category: &quot;yyy&quot; &#125;, &#123; title: &quot;Mio Akiyama&quot;, category: &quot;yyy&quot; &#125;,];console.log(groupBy(arrayRoles, &quot;category&quot;));/*&#123; &#x27;xxx&#x27;: [ &#123; title: &#x27;Mieruko-chan&#x27;, category: &#x27;xxx&#x27; &#125;, &#123; title: &#x27;Vladilena Mirizé&#x27;, category: &#x27;xxx&#x27; &#125;, &#123; title: &#x27;Nakano Azusa&#x27;, category: &#x27;xxx&#x27; &#125; ], &#x27;yyy&#x27;: [ &#123; title: &#x27;Shirahane Suou&#x27;, category: &#x27;yyy&#x27; &#125;, &#123; title: &#x27;Mio Akiyama&#x27;, category: &#x27;yyy&#x27; &#125; ]&#125;*/","tags":["JavaScript Snippets","Tool function"],"categories":["学习"]},{"title":"第三方应用授权：OAuth 2.0","path":"/2021/06/21/oauth2.0/","content":"介绍OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。 简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（access_token），用来代替密码，供第三方应用使用。 OAuth 2.0 的优点：保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全 令牌与密码的区别令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。 令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。 令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。 令牌有权限范围（scope）。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。 :::warning只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。::: 四种授权类型（authorization grant）即四种颁发令牌的方式： 授权码（authorization-code） 隐藏式（implicit） 密码式（password）： 客户端凭证（client credentials） :::primary不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。::: 第一种授权方式：授权码授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。:::info这种方式是&#x3D;&#x3D;最常用的流程&#x3D;&#x3D;，安全性也最高，它适用于那些++有后端的 Web 应用++{.wavy .success}。授权码通过前端传送，++令牌则是储存在后端++{.dot}，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。::: 举例说明： A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用 12345https://b.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。 用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码 1https://a.com/callback?code=AUTHORIZATION_CODE A 网站拿到授权码以后，就可以&#x3D;&#x3D;在后端&#x3D;&#x3D;，向 B 网站请求令牌 123456https://b.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL client_id参数和client_secret参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri参数是令牌颁发后的回调网址。 B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据 123456789&#123; &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;token_type&quot;:&quot;bearer&quot;, &quot;expires_in&quot;:2592000, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, &quot;scope&quot;:&quot;read&quot;, &quot;uid&quot;:100101, &quot;info&quot;:&#123;...&#125;&#125; access_token字段就是令牌，A 网站在后端拿到了。 第二种方式：隐藏式有些 Web 应用是&#x3D;&#x3D;纯前端应用&#x3D;&#x3D;，没有后端。这时就不能用上面的方式了，必须++将令牌储存在前端++{.dot}。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式++没有授权码这个中间步骤++{.dot}，所以称为（授权码）”隐藏式”（implicit）。 A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用 12345https://b.com/oauth/authorize? response_type=token&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read response_type参数为token，表示要求直接返回令牌。 用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。 1https://a.com/callback#token=ACCESS_TOKEN token参数就是令牌，A 网站因此直接在前端拿到令牌。 :::info注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。另外，这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。::: 第三种方式：密码式如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。 A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。 12345https://oauth.b.com/token? grant_type=password&amp; username=USERNAME&amp; password=PASSWORD&amp; client_id=CLIENT_ID grant_type参数是授权方式，这里的password表示”密码式”，username和password是 B 的用户名和密码。 B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 响应，A 因此拿到令牌。 :::danger这种方式需要用户给出自己的用户名&#x2F;密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。::: 第四种方式：凭证式最后一种方式是凭证式（client credentials），适用于++没有前端的命令行应用++{.dot}，即在命令行下请求令牌。 A 应用在命令行向 B 发出请求。 1234https://oauth.b.com/token? grant_type=client_credentials&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET grant_type参数等于client_credentials表示采用凭证式，client_id和client_secret用来让 B 确认 A 的身份。 B 网站验证通过以后，直接返回令牌 :::info这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。::: 令牌的使用A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。 此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。 12curl -H &quot;Authorization: Bearer ACCESS_TOKEN&quot; \\&quot;https://api.b.com&quot; 更新令牌令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。 具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。 12345https://b.com/oauth/token? grant_type=refresh_token&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; refresh_token=REFRESH_TOKEN grant_type参数为refresh_token表示要求更新令牌，client_id参数和client_secret参数用于确认身份，refresh_token参数就是用于更新令牌的令牌。 B 网站验证通过以后，就会颁发新的令牌。","tags":["OAuth 2.0","第三方应用授权"],"categories":["学习"]},{"title":"npm & package.json","path":"/2021/06/17/npm&package.json/","content":"npm 是什么npm 是 Node.js 的包管理工具，Node.js package manger，通过 npm Node.js 可以方便地使用第三方开发的开源模块，同时也可以把自己的模块发布到 npm 供其它开发者使用。 npm 主要由三部分组成： npm website：https://npmjs.com，开发者查找发现 package 的站点 CLI（命令行）：开发者可以使用命令行工具和 npm 进行交互，对 package 进行安装、更新、删除等操作 registry（注册表）：package 及其元信息存储的数据库 :::info注册表是一个巨大的数据库，保存了每个包（package）的信息。例如我们要查询 vue 包的信息，可以访问https://registry.npmjs.org/vue，就会看到 vue 模块所有版本的信息。模块名后面，还可以跟上版本号或者标签，用来查询某个具体版本的信息，例如：https://registry.npmjs.org/vue/3.0.0 查看 vue 3.0.0 版本的信息具体用法就是，https://registry.npmjs.org/模块名/版本号::: yarnyarn 是 Facebook 2017 年推出的和 npm 功能类似的包管理工具，主要解决当时 npm 的几个核心问题 安装包不够快速与稳定 存在安全隐患 同时 yarn 的 cli 工具提供了更简单的命令，当然面对 yarn 带来的压力，npm 在 5.0 后提供了类似的改进，两者现在差距不再巨大，开发者可以根据个人习惯和项目规范自由选择（我个人更喜欢使用 yarn） npxnpm 从5.2版本开始，增加了 npx 命令，npx 想要解决的主要问题，就是调用项目内部安装的模块。原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在；如果存在，则执行；不存在，则进行临时安装，然后执行，执行完毕后将包删除。 对 npx 的详细介绍见npx使用教程 package.jsonnpm 通过 Node.js 模块根目录的 package.json 文件获取模块元数据和依赖关系等，例如react 的 package.json 包含如下信息:::info可以通过npm init -y或者yarn init -y生成一份默认的 package.json 配置::: react 的 package.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; &quot;name&quot;: &quot;react&quot;, &quot;description&quot;: &quot;React is a JavaScript library for building user interfaces.&quot;, &quot;keywords&quot;: [ &quot;react&quot; ], &quot;version&quot;: &quot;17.0.3&quot;, &quot;homepage&quot;: &quot;https://reactjs.org/&quot;, &quot;bugs&quot;: &quot;https://github.com/facebook/react/issues&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;files&quot;: [ &quot;LICENSE&quot;, &quot;README.md&quot;, &quot;build-info.json&quot;, &quot;index.js&quot;, &quot;cjs/&quot;, &quot;umd/&quot;, &quot;jsx-runtime.js&quot;, &quot;jsx-dev-runtime.js&quot;, &quot;unstable-shared-subset.js&quot; ], &quot;main&quot;: &quot;index.js&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &#123; &quot;react-server&quot;: &quot;./unstable-shared-subset.js&quot;, &quot;default&quot;: &quot;./index.js&quot; &#125;, &quot;./index&quot;: &#123; &quot;react-server&quot;: &quot;./unstable-shared-subset.js&quot;, &quot;default&quot;: &quot;./index.js&quot; &#125;, &quot;./build-info.json&quot;: &quot;./build-info.json&quot;, &quot;./jsx-runtime&quot;: &quot;./jsx-runtime.js&quot;, &quot;./jsx-dev-runtime&quot;: &quot;./jsx-dev-runtime.js&quot;, &quot;./&quot;: &quot;./&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/facebook/react.git&quot;, &quot;directory&quot;: &quot;packages/react&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=0.10.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;loose-envify&quot;: &quot;^1.1.0&quot;, &quot;object-assign&quot;: &quot;^4.1.1&quot; &#125;, &quot;browserify&quot;: &#123; &quot;transform&quot;: [ &quot;loose-envify&quot; ] &#125;&#125; namename 是模块的唯一标识，安装、使用模块都需要使用模块的 name，可以使用字母（只能使用小写字母）、数字、_、-和.，例如安装和使用 vue 需要用到如下命令 1yarn add vue 1import &#123;inject, Ref&#125; from &#x27;vue&#x27; 可以通过 scope 组织具有相关性的模块，模块名义@开头的包就是一个 scoped package，scope 就是@和/之间的内容 1@scope/project-name 例如@antv&#x2F;g2plot version版本号遵从语义化版本规范，使用x.y.z形式，对应主版本.次版本.修订版本 ，版本号递增规则如下： 主版本（major）：当你做了不兼容的 API 修改，一般改动很大，不兼容低版本 次版本（minor）：当你做了向下兼容的功能性新增，兼容同一个大版本的 API 和用法 修订版本（patch）：当你做了向下兼容的问题修正，一般用来修复 bug 先行版本x.y.z格式是模块正式版本，重要模块为了保证稳定，会在放出正式版本之前提供先行版本 alpha: 内部版本 beta: 公测版本 rc: Release candidate，正式版本的候选版本 stable: 稳定版 csp 例：npm 上 vue 部分版本记录 这种特殊版本除非开发者&#x3D;&#x3D;精确声明使用&#x3D;&#x3D;，例如npm install vue@3.0.0-rc.13，否则npm install不会自动安装对应版本内容 快捷命令npm 提供了快捷升级命令 升级主版本号：npm version major 升级次版本号：npm version minor 升级修订版本号：npm version patch 设置版本号为指定的版本号：npm version 版本号 升级先行版本号：npm version prerelease 升级先行版本号并指定先行版本的名字：npm version prerelease --preid=&lt;prerelease-id&gt; 示例： 1234567# 假定现在的版本号是1.1.1npm version major # 2.0.0npm version minor # 1.2.0npm version patch # 1.1.2npm version prerelease # 1.1.2-0npm version prerelease --preid=alpha # 1.1.2-alpha.0npm version 4.1.2 # 4.1.2 :::info执行npm version修改完版本号之后，还会默认执行 git add -&gt; git commit -&gt; git tag 操作，commit 的信息和为 tag 均为版本号，且该步骤应在npm publish之前进行。::: tagnpm 中的 tag 类似于 git 中的 branch ，发布者可以在指定的 tag 上进行发版，使用者可以选择指定 tag 来安装，默认的 tag 是latest。这对于我们日常开发非常有用，很多时候我们想要发布版本来进行验证功能，但是又不想影响正在使用的人，我们就可以利用 tag 和先行版本来进行发包。 12npm publish --tag alpha # 发版到名为 alpha 的 tag 上npm i &lt;package&gt;@&lt;tag&gt; # 从指定 tag 上安装包 dependencies &amp; devDependenciesdependencies 和 devDependencies 字段用来表示模块的依赖和开发环境依赖，模块依赖的版本号有些几种不同写法，来保证安装的时候使用对应的版本 x.y.z 使用精确版本号 * 任意版本，第一次安装会使用模块最新版本 ^x.y.z x 位锁死，y、z 位使用最新版本 3.x和^3.0.0含义相同，x 位使用指定版本，y、z 位使用最新 ~x.y.z x、y 锁定，z 位使用最新版本 npm 提供了快捷命令，可以在安装的时候就自动把对应内容写到 package.json 中 12npm install &lt;package_name&gt; --save # 安装模块并写入 dependenciesnpm install &lt;package_name&gt; --save-dev # 安装模块并写入 devDependencies peerDependencies有时候模块需要与宿主模块共享依赖，也就是有可能会用到某个模块，但自己不安装，希望宿主环境安装的时候使用 peerDependencies 声明，比如 react-dom 的 package.json 的使用 12345678&quot;dependencies&quot;: &#123; &quot;loose-envify&quot;: &quot;^1.1.0&quot;, &quot;object-assign&quot;: &quot;^4.1.1&quot;, &quot;scheduler&quot;: &quot;^0.20.1&quot;&#125;,&quot;peerDependencies&quot;: &#123; &quot;react&quot;: &quot;17.0.3&quot;&#125; repositoryrepository 用来指定模块源代码信息 12345&quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/facebook/react.git&quot;, &quot;directory&quot;: &quot;packages/react&quot;&#125; main 字段main 字段用来标识模块的默认入口文件，比如 react main: &quot;index.js&quot; ，下面两句写法含义相同 12const react = require(&#x27;react&#x27;);const react = require(&#x27;react/index.js&#x27;); 发布 package 在 npmjs.com 上注册账号 在++命令行++{.dot}使用npm login登录 使用npm publish进行发布 :::warning在进行npm publish操作前，请确认使用的是 npm 官方源，如果当前使用的是非官方源，可以使用npm config set registry https://registry.npmjs.org或者nrm切换至 npm 官方源:::","tags":["npm","package.json"],"categories":["学习"]},{"title":"Google 搜索技巧","path":"/2021/03/01/google-search-skills/","content":"使用引号强制进行精确匹配搜索:::default no-icon“what is javascript”::: AND运算符将只返回与这两个术语相关的结果:::default no-iconhtml AND css::: 使用OR运算符获取与其中一个搜索词相关的结果:::default no-icon(javascript OR python) free course或者(javascript | python) free course::: -运算符将排除包含以下术语或短语的结果:::default no-iconjavascript -css::: 使用*通配符作为占位符，它将被任何单词或短语替换:::default no-icon“how to start * in 6 months”::: 在单个网站内搜索:::default no-iconsite:freecodecamp.org::: 也可以用site:来限制搜索结果的顶级域，例如.com、.edu、.org 查找特定的文件类型:::default no-iconfiletype:pdf learn css或者ext:pdf learn css::: 搜索一个数字范围:::default no-iconecmascript 2016..2018:::","tags":["Google 搜索技巧"],"categories":["学习"]},{"title":"浅析前端路由","path":"/2021/02/22/frontend-routing/","content":"什么是前端路由用最简单的话来说就是，页面间的跳转仅由前端来控制，而不需要向后端发起请求。前端路由反映的是URL和组件之间的映射关系。 如何实现前端路由vue-router 中有 3 种路由模式：hash、history、abstract（不常用），这里仅介绍下 hash 模式和 history 模式的简单实现 hash 模式早期的前端路由的实现就是基于 location.hash 来实现的。实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#first’。 1http://www.example.com#first hash 路由模式的实现主要基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，&#x3D;&#x3D;hash 部分并不会被发送&#x3D;&#x3D;； hash 值的任意改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过&#x3D;&#x3D;浏览器的回退、前进按钮&#x3D;&#x3D;来控制 hash 的切换； 通过&#x3D;&#x3D;设置 a 标签的 href 属性&#x3D;&#x3D;，当用户点击这个标签后，URL 的 hash 值会发生改变；或者直接&#x3D;&#x3D;对 loaction.hash 进行赋值&#x3D;&#x3D;，改变 URL 的 hash 值； 通过浏览器原生的hashchange事件来++监听 hash 值的变化++{.dot .warning}，从而对页面进行跳转（渲染）。 1234567891011121314151617181920212223242526272829303132333435&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--渲染对应组件的地方--&gt;&lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 第一次加载的时候，不会执行 hashchange 监听事件，默认执行一次 // DOMContentLoaded 为浏览器 DOM 加载完成时触发 window.addEventListener(&#x27;DOMContentLoaded&#x27;, Load) window.addEventListener(&#x27;hashchange&#x27;, HashChange) // 展示页面组件的节点 var routeView = null function Load() &#123; routeView = document.getElementById(&#x27;route-view&#x27;) HashChange() &#125; function HashChange() &#123; // 每次触发 hashchange 事件，通过 location.hash 拿到当前浏览器地址的 hash 值 // 根据不同的路径展示不同的内容 switch(location.hash) &#123; case &#x27;#/page1&#x27;: routeView.innerHTML = &#x27;page1&#x27; return case &#x27;#/page2&#x27;: routeView.innerHTML = &#x27;page2&#x27; return default: routeView.innerHTML = &#x27;page1&#x27; return &#125; &#125;&lt;/script&gt; :::info这仅是最简易的实现，真实的 hash 模式，还要考虑到很多复杂的情况，具体情况可以去看 Vue Router 的源码。::: history 模式history 模式的实现基于 HTML5 提供的 History API，其中最主要的 API 为：history.pushState()和history.repalceState()。这两个 API 均可在不刷新页面的情况下，对浏览器的历史纪录进行操作。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。 history 路由模式的实现主要基于下面几个特性： 通过 pushState 和 repalceState 这两个 API 来操作实现 URL 的变化（实际上是改变了浏览器的location.pathname属性值） ； 通过浏览器原生的popstate事件来&#x3D;&#x3D;监听浏览器动作的变化&#x3D;&#x3D;，从而对页面进行跳转（渲染）； 但history.pushState()或history.replaceState()只能改变 URL，并不会触发 popstate 事件，需要&#x3D;&#x3D;手动触发页面跳转（渲染）&#x3D;&#x3D;。 :::info需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在 Javascript 代码中调用history.back()或者history.forward()方法）（摘自 MDN 对 popstate 的解释）::: 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&#x27;DOMContentLoaded&#x27;, Load) window.addEventListener(&#x27;popstate&#x27;, PopChange) var routeView = null function Load() &#123; routeView = document.getElementById(&#x27;route-view&#x27;) // 默认执行一次 popstate 的回调函数，匹配一次页面组件 PopChange() // 获取所有带 href 属性的 a 标签节点 var aList = document.querySelectorAll(&#x27;a[href]&#x27;) // 遍历 a 标签节点数组，阻止默认事件，添加点击事件回调函数 aList.forEach(aNode =&gt; aNode.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() //阻止a标签的默认事件 var href = aNode.getAttribute(&#x27;href&#x27;) // 手动修改浏览器的地址栏 history.pushState(null, &#x27;&#x27;, href) // 通过 history.pushState 手动修改地址栏， // popstate 是监听不到地址栏的变化，所以此处需要手动执行回调函数 PopChange PopChange() &#125;)) &#125; function PopChange() &#123; console.log(&#x27;location&#x27;, location) switch(location.pathname) &#123; case &#x27;/page1&#x27;: routeView.innerHTML = &#x27;page1&#x27; return case &#x27;/page2&#x27;: routeView.innerHTML = &#x27;page2&#x27; return default: routeView.innerHTML = &#x27;page1&#x27; return &#125; &#125;&lt;/script&gt; 以上代码的思路：通过遍历页面上的所有 a 标签，阻止 a 标签的默认事件的同时，加上点击事件的回调函数，在回调函数内获取 a 标签的 href 属性值，再通过 pushState 去改变浏览器的 location.pathname 属性值。然后手动执行 popstate 事件的回调函数，去匹配相应的路由。 :::warning这里注意，以上代码不能在浏览器直接打开静态文件（会报错），需要通过 web 服务，启动端口去浏览网址。::: 单页面应用 v.s. 多页面应用对前端来说，路由概念的出现是伴随着SPA出现的；在SPA出现之前，页面的跳转(导航)都是通过服务端来控制的，并且页面跳转存在一个明显白屏跳转过程；SPA出现后，用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染，就不再让服务端控制页面跳转了，于是前端路由出现了，前端可以自由控制组件的渲染，来模拟页面跳转。 单页面应用和多页面应用的对比如下： 单页面应用（SinglePage Web Application，SPA） 多页面应用（MultiPage Application，MPA） 组成 一个外壳页面和多个页面片段组成 多个完整页面构成 资源共用（css，js） 共用，只需在外壳部分加载 不共用，每个页面都需要加载 刷新方式 页面局部刷新或更改 整页刷新 URL 模式 xxx.com/#/firstxxx.com/#/second xxx.com/#/first.htmlxxx.com/#/second.html 用户体验 页面片段间切换快，用户体验好 页面切换加载缓慢，流畅度不够，用户体验较差 转场动画 容易实现 无法实现 数据传递 容易 依赖 URL 传参，或者 cookie、localStorage 等 搜索引擎优化（SEO） 需要单独方案、实现较为困难、不利于SEO检索、可利用服务端渲染（SSR）优化 容易实现 使用范围 高要求的体验度、追求界面流畅的应用（一般是后台管理系统） 适用于追求高度支持搜索引擎的应用 维护成本 相对容易 相对复杂","tags":["前端路由"],"categories":["学习"]},{"title":"Vue 两个版本的区别（完整版 v.s. 运行时版）","path":"/2020/06/30/vue-difference-version/","content":"使用 Vue 实例的三种方式 方法一：从 HTML 得到视图 使用「完整版 Vue」 通过 cdn 或 import 来引入 vue.js 或者 vue.min.js 将视图写在 HTML 中或者写在 template 选项中 方法二：用 JS 来构建视图 使用「非完整版 Vue」 通过 cdn 或 import 来引入 vue.runtime.js 或者 vue.runtime.min.js 使用 render 函数 方法三：使用 vue-loader（webpack 的一个 loader） 使用「非完整版 Vue」 vue-loader 可以把 *.vue 文件翻译成 h 构建方法 这种做法的缺点是，HTML 内就只有一个 div#app，对 SEO 不友好 完整版（运行时 + 编译器） v.s. 非完整版（只包含运行时）对比如下： Vue 完整版 （运行时 + 编译器） Vue 非完整版（只包含运行时） 评价 特点 有 compiler 没有 compiler compiler 占 30% 体积 视图 写在 HTML 中或者写在 template 选项中 写在 render 函数里用 h 来创建标签 h 是尤雨溪写好传给 render 的 cdn 引入 vue.js vue.runtime.js 文件名不同，生产环境后缀为 .min.js webpack 引入 需要配置 alias 默认使用此版 尤雨溪配置的 @vue&#x2F;cli 引入 需要额外配置 默认使用此版 尤雨溪、蒋豪群配置的 1234567891011// 需要编译器new Vue(&#123; template: &#x27;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#x27;&#125;)// 不需要编译器new Vue(&#123; render (h) &#123; return h(&#x27;div&#x27;, this.hi) &#125;&#125;) 当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。 最佳实践：总是使用非完整版，然后配合vue-loader 和 vue 单文件组件。 Vue 作者的思路： 为了保证用户体验，让用户下载的 JS 文件体积更小，但只支持 h 函数 为了保证开发体验，让开发者可以直接在 vue 文件里写 HTML 标签，而不写 h 函数 由此发明了 vue-loader，脏活儿让 loader 来做，vue-loader 把 vue 文件里的 HTML 转为 h 函数 SEO 基本原理 全称：Search Engine Optimization，中文：搜索引擎优化 你可以认为搜索引擎就是在不停的发起 curl 搜索引擎根据 curl 的结果来猜测页面的内容 如果页面的内容是通过 JS 渲染上去的，则不利于 SEO JS 创建 div 比如 Vue 的 HTML 内初始就只有一个 div#app，这个 div 的内容是通过 JS 后面填充进去的，因此 Vue 不利于 SEO（可以用 SSR 来解决 Vue 的 SEO 问题） 解决「SEO 不友好」方法： 原则上只要让 curl 能得到页面的信息，SEO 就能正常工作 把 title、description、keyword、meta、h1、a 写好即可 百度的 SEO 就是个笑话，充钱你就能变强 Google 其实可以获取 JS 创建的内容，但毕竟在墙外，国内还是别想了","tags":["Vue","SEO","Vue compiler"],"categories":["学习"]},{"title":"朋友们","path":"/friends/index.html","content":"Notev優萌初華云之巅涼風桜雨星日语"}]