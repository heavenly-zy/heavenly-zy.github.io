[{"title":"CSS命名规范-BEM（转载）","path":"/2023/07/07/css/bemcss/","content":"原文戳这里👉：https://bemcss.com BEM 解决的问题css 的样式应用是全局性的，没有作用域可言。考虑以下场景： 场景一：开发一个弹窗组件，在现有页面中测试都没问题，一段时间后，新需求新页面，该页面一打开这个弹窗组件，页面中样式都变样了，一查问题，原来是弹窗组件和该页面的样式相互覆盖了，接下来就是修改覆盖样式的选择器…又一段时间，又开发新页面，每次为元素命名都心惊胆战，求神拜佛，每写一条样式，F5 都按多几次，每个组件都测试一遍… 场景二：承接上文，由于页面和弹窗样式冲突了，所以把页面的冲突样式的选择器加上一些结构逻辑，比如子选择器、标签选择器，借此让选择器独一无二。一段时间后，新同事接手跟进需求，对样式进行修改，由于选择器是一连串的结构逻辑，看不过来，嫌麻烦，就干脆在样式文件最后用另一套选择器，加上了覆盖样式…接下来又有新的需求…最后的结果，一个元素对应多套样式，遍布整个样式文件… 以往开发组件，我们都用“重名概率小”或者干脆起个“当时认为是独一无二的名字”来保证样式不冲突，这是不可靠的。 理想的状态下，我们开发一套组件的过程中，我们应该可以随意的为其中元素进行命名，而不必担心它是否与组件以外的样式发生冲突。 BEM 解决这一问题的思路在于，由于项目开发中，每个组件都是唯一无二的，其名字也是独一无二的，组件内部元素的名字都加上组件名，并用元素的名字作为选择器，自然组件内的样式就不会与组件外的样式冲突了。 这是通过组件名的唯一性来保证选择器的唯一性，从而保证样式不会污染到组件外。 这也可以看作是一种“硬性约束”，因为一般来说，我们的组件会放置在同一目录下，那么操作系统中，同一目录下文件名必须唯一，这一点也就确保了组件之间不会冲突。 BEM 的命名规矩很容易记：block-name__element-name--modifier-name，也就是模块名 + 元素名 + 修饰器名。 一般来说，根据组件目录名来作为组件名字： 比如分页组件：/app/components/page-btn/ 那么该组件模块就名为 page-btn，组件内部的元素命名都必须加上模块名，比如： 12345&lt;div class=&quot;page-btn&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;page-btn__prev&quot;&gt;上一页&lt;/button&gt; &lt;!-- ... --&gt; &lt;button type=&quot;button&quot; class=&quot;page-btn__next&quot;&gt;下一页&lt;/button&gt;&lt;/div&gt; 上面我们用双下划线来明确区分模块名和元素名，当然也可以用单下划线，比如 page-btn_prev和page-btn_next。我们只需保留 BEM 的思想，其命名规范可以任意变通。 一开始了解 BEM 的时候，可能会产生误解，出现以下不正确的命名方式： 123456789&lt;div class=&quot;page-btn&quot;&gt; &lt;!-- ... --&gt; &lt;ul class=&quot;page-btn__list&quot;&gt; &lt;li class=&quot;page-btn__list__item&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;page-btn__list__item__link&quot;&gt;第一页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- ... --&gt;&lt;/div&gt; 分页组件有个 ul 列表名为：page-btn__list，列表里面存放每一页的按钮，名为：page-btn__list__item__link，这是不对的。 首先，有悖 BEM 命名规范，BEM 的命名中只包含三个部分，元素名只占其中一部分，所以不能出现多个元素名的情况，所以上述每一页的按钮名 page-btn__list__item__link 可以改成：page-btn__btn。 其次，有悖 BEM 思想，BEM 是不考虑结构的，比如上面的分页按钮，即使它是在 ul 列表里面，它的命名也不应该考虑其父级元素。当我们遵循了这个规定，无论父元素名发生改变，或是模块构造发生的改变，还是元素之间层级关系互相变动，这些都不会影响元素的名字。 所以即使需求变动了，分页组件该有按钮还是要有按钮的，DOM 构造发生变动，至多也就不同元素的增删减，模块内名称也随之增删减，而不会出现修改名字的情况，也就不会因为名字变动，牵涉到 JS 文件的修改，或样式文件的修改。 BEM 命名好长BEM 的命名中包含了模块名，长长的命名会让 HTML 标签会显得臃肿。 其实每个使用 BEM 的开发团队多多少少会改变其命名规范，比如 Instagram 团队使用的驼峰式: 1.blockName-elementName--modifierName &#123; /* ... */ &#125; 还有单下划线： 1.block-name_element-name--modifierName &#123; /* ... */ &#125; 还有修饰器名用单横线连接： 1.blockName__elementName-modifierName &#123; /* ... */ &#125; 其实这些对缩短命名没有多大的帮助，但我们也无需担心文件体积的问题，由于服务端有 gzip 压缩，BEM 命名相同的部分多，压缩下来的体积不会太大。另外现在都用 IDE 来编写代码了，有自动提示功能，也无须担心重复的输入过长的名字。 因为命名长，我们是不是可以用子代选择器来代替 BEM 命名？这样至少在 HTML 编写时，让 HTML 标签看起来美观一点。 下面说说子代选择器带来的问题。 子选择器子代选择器的方式是，通过组件的根节点的名称来选取子代元素。按照这个思路，分页按钮样式可以这么写： 12345&lt;div class=&quot;page-btn&quot;&gt; &lt;!-- ... --&gt; &lt;ul class=&quot;list&quot;&gt;&lt;/ul&gt; &lt;!-- ... --&gt;&lt;/div&gt; 12.page-btn &#123; /* ... */ &#125; .page-btn .list &#123; /* ... */ &#125; HTML 看起来美观多了，但这解决了样式冲突问题么？试想下，如果让你来接手这个项目，要增加一个需求，新增一个组件，你命名放心么？ 你面临的问题是：你打开组件目录，里面有个分页组件，叫做 page-btn，可是你完全不知道要怎么给新组件命名，因为即使新组件模块名与 page-btn 不一样，也不能保证新组件与分页组件不冲突。 比如新的需求是“新增一个列表组件”，如果该组件的名字叫做 list，其根节点的名字叫 list，那么这个组件下面写的样式，就很可能和 .page-btn .list 的样式冲突: 1.list &#123; /* ... */ &#125; 这还仅仅只有两个组件而已，实际项目中，十几个或几十个组件，难道我们要每个组件都检查一下来“新组件名是否和以往组件的子元素命名冲突了”么？这不现实。 BEM 禁止使用子代选择器，以上是原因之一。子代选择器不好的地方还在于，如果层次关系过长，逻辑不清晰，非常不利于维护。为了懒得命名或者追求所谓的“精简代码”，写出下面这种选择器： 12345.page-btn button:first-child &#123;&#125; .page-btn ul li a &#123;&#125;/* ... */ /* 维护代码，新增需求 */.page-btn .prev &#123;&#125; 用层次关系结构关系来定位元素，可能会因为需求改变而大面积的重写样式文件。试想一下维护这类代码有多么痛苦，我们要一边检查该元素的上下文 DOM 结构，一边对照着 CSS 文件，一一对比，找到该元素对应的样式，也就是说我为了改一个元素的代码，需要不断翻阅 HTML 文件和 CSS 文件，可维护性非常之差。更有甚者，来维护这块代码的同事，直接在样式文件最后添加覆盖样式，这会造成一个非常严重的问题了：同一个元素样式零散的分布在文件的不同地方，而且定位该元素的选择器也可能各不相同。 这样的样式文件只会越写越糟糕，可以说，当我们用子代选择器来定位元素时，这个样式文件就已经注定是要被翻来覆去的重构的了，甚至，每个来维护这个文件的人都会将其重构一遍。 子代选择器还会造成权重过大的问题，当我们要做响应式的时候，某个带样式的元素需要适配不同的屏幕，此时，我们还要不断的确认该元素之前的选择器写法！为了覆盖前面权重过大的样式，甚至通过添加额外的类名或标签名来增加权重。可想而知，此后这个样式文件的维护难度就像雪球一样，越滚越大。 如果我们用的是 BEM，要覆盖样式很简单：找到要覆盖样式的元素，得知它的类名，在媒体查询中，用它的类名作为选择器，写下覆盖样式，样式就覆盖成功了，不需要担心前面样式的权重过大。 BEM 修饰器根据不同的场景，组件可能会表现出不同的样式。比如分页组件在 pc 端具有具体的页码以及上下页按钮，但在移动端，因空间有限，可能只保留上下页按钮。我们可以用修饰器来区分这两种情况。默认情况下，分页按钮的类名为 page-btn，但在移动端，我们需要加多个类名 page-btn--min 1234/* 缩小版分页组件中，具体页码按钮隐去 */ .page-btn--min .page-btn__btn &#123; display: none; &#125;.page-btn--min .page-btn__prev &#123; width: 50%; &#125;.page-btn--min .page-btn__next &#123; width: 50%; &#125; 上面这种情况用了子代选择器，BEM 是不允许这么写的，BEM 中修饰器的样式不依赖于任何结构关系，也就是说，元素的状态改变只会影响自身，不对其他元素进行影响，但实际上，这很难做到。以上的写法不会造成样式冲突，而且权重的影响也不大。 BEM 修饰器代表着元素的状态，但有时候元素的状态需要 js 来控制，此时遵循规范没有任何好处，比如激活状态，BEM 推荐的写法是： 12.block__element &#123; display: none; &#125;.block__element--active &#123; display: block; &#125; 当用 js 为该元素添加状态时，我们需要知道该元素的名字 block__element，这样我们才能推导出它的激活状态为 block__element--active，这是不合理的，因为很多时候我们无法得知元素的名称，所以这时候，我们应该统一 js 控制状态的类名格式，比如 is-active、js-active 等等，这些类名只用作标识，不予许有默认的公共样式： 12.block__element &#123; display: none; &#125;.block__element.is-active &#123; display: block; &#125; 原子类和 BEMBEM 可以不需要用到原子类，但是如果已经引入了类似 Bootstrap 的框架，也没必要强制避免使用原子类，比如“pull-right”、”ellipsis”、“clearfix”等等类，这些类非常实用，和 BEM 是可以互补的。 在组件开发中其实不推荐使用原子类，因为这会降低组件的可复用性。可复用性的最理想状态就是组件不仅仅在不同的页面中表现一致，在跨项目的情况下，也能够运行良好。如果组件的样式因为依赖于某几个原子类就要依赖整个 Bootstrap 库，那么组件的迁移负担就重很多了。 原子类更适合应用在实际页面中，这是因为页面变动大而且不可复用，假设在 header 中，我们用到了两个组件 logo 和 user-panel（用户操作面板），两个组件分别置于 header 的左侧和右侧，我们可以这么写： 12345678&lt;div class=&quot;header clearfix&quot;&gt; &lt;div class=&quot;logo pull-left&quot;&gt; &lt;!-- ... --&gt; &lt;/div&gt; &lt;div class=&quot;user-panel pull-left&quot;&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/div&gt; header 可以封装成一个模块，但它复用程度不高，不能算是组件，所以即使使用原子类也没有关系。在项目中，使用原子类之前应该考虑一下，这个场景是否变动大而且不可复用，如果是的话，我们可以放心的使用原子类。 组件应该是“自洽的”，其本身就应该构成了一个“生态圈”，也就是说，他几乎不需要外部供给，自给自足就能够运转下去。 实际页面中也应该使用 BEM在实际页面中也需要用到 BEM 命名方法，不然乱起的一个名字很可能就和某一组件冲突了，导致样式相互覆盖。 假如我们有联系页面，路径是 /pages/contact/。那么该页面的模块名可以是 page-contact，其名下元素均以 page-contact__element-name 命名。 一般来说，实际页面中只是对组件进行调用，对组件的位置进行调整，但不会对组件内部细节进行修改。但实际情况下，同一个组件在不同页面不同模样的情况也是有的，所以会出现在实际页面中对组件样式进行微调的代码： 12/* 联系页面对分页按钮进行微调 */.page-contact .page-btn &#123;&#125; 但更推荐的做法是给分页组件添加一个修饰器，将上面的样式放到修饰器名下，再根据实际情况运用到页面中。 webpack css-loader 解决之道BEM 主要被诟病的一点在于其命名过长，结合 Angular 这种带有标签指令的框架时，整个 HTML 看起来会更混乱： 12&lt;!-- 发帖页面 --&gt;&lt;span ng-repeat=&quot;post in postData track by post.id&quot; ng-if=&quot;$index === 0&quot; class=&quot;page-post__post-item&quot; ng-class=&quot;&#123;&#x27;page-post__post-item--even&#x27;: $even&#125;&quot; popover-content=&quot;&quot;&gt;&lt;/span&gt; 当然，我们可以通过换行来缓解这个问题: 123456789&lt;!-- 发帖页面 --&gt;&lt;span ng-repeat=&quot;post in postData track by post.id&quot; ng-if=&quot;$index === 0&quot; class=&quot;page-post__post-item&quot; ng-class=&quot;&#123;&#x27;page-post__post-item--even&#x27;: $even&#125;&quot; popover-content=&quot;&quot;&gt;&lt;/span&gt; 但其实说穿了，BEM 保证样式不冲突的核心就是：在元素名中加入唯一的标识。这个标识在 BEM 中对应的是模块名，也可能是一个独一无二的乱序字符串。 为模块中每个元素名加入标识，这可是重复的工作啊，重复的工作就应该交给机器去做。 webpack 加载器 css-loader，可在 js 中读取 css 样式，自2015年4月份起，该插件加入了 placeholder 功能，使得该插件可以解决 CSS 作用域的问题，原理也就是给元素的名称加入唯一的标识。 12/* 分页组件 */:local(.prev) &#123;&#125; css-loader 加载器自定义的语法：:local(.identifier)&#123;&#125; 向外暴露出选择器 .prev。在 JS 代码中，我们可以拿到这个选择器： 123import styles from &#x27;./page-btn.css&#x27;;var $prevBtn = $(&#x27;&lt;button class=&quot;&#x27; + styles.prev + &#x27;&quot;&gt;上一页&lt;/button&gt;&#x27;);// ... styles.prev 返回的是一串独一无二且随机的字符串，该字符串对应着样式文件中的选择器。这名字有悖语义化，但 css-loader 支持配置字符串的生成格式。","tags":["BEM"],"categories":["学习笔记","CSS"]},{"title":"-webkit-fill-available 关键字","path":"/2023/07/06/css/-webkit-fill-available/","content":"-webkit- 前缀：浏览器厂商会在 CSS 属性或值前加一个私有的前缀来支持新属性，带有此前缀的属性或值能够在以 WebKit 为内核的浏览器中正常使用。以 WebKit 为内核的浏览器代表有 Safari 和 Chrome。 fill-available：它会自动计算元素的宽度和高度，使元素的尺寸撑满其父元素的可用空间，这个属性通常用于解决某些布局问题。 下面是一个使用 -webkit-fill-available 来实现元素填充父元素的剩余空间的例子： 123456789101112.parent &#123; width: 300px; height: 200px; border: 1px solid #ccc; display: flex;&#125;.child &#123; width: -webkit-fill-available; height: -webkit-fill-available; background-color: #f0f0f0;&#125; 需要注意的是，-webkit-fill-available 是一个非标准的属性，一般情况下不建议使用非标准的或私有的 CSS 属性值，因为它们可能不被不同浏览器所支持，导致兼容性问题。 可以考虑其他方案的实现: 1234567.parent &#123; display: flex;&#125;.child &#123; flex: 1;&#125; 查看效果","tags":["-webkit-","fill-available"],"categories":["学习笔记","CSS"]},{"title":"CSS 垂直居中的几种方式","path":"/2023/06/27/css/vertical-centering-method/","content":"只提供核心代码，多余代码已被省去。 padding适用于 parent 的高度不固定的情况 12345.parent &#123; padding: 20px 0;&#125;.child &#123;&#125; flex1234567.parent &#123; display: flex; justify-content: center; align-items: center;&#125;.child &#123;&#125; absolute margin auto123456789101112.parent &#123; position: relative;&#125;.child &#123; position: absolute; margin: auto; top: 0; bottom: 0; left: 0; right: 0;&#125; absolute translate12345678910.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; grid1234567.parent &#123; display: grid;&#125;.child &#123; place-self: center;&#125;","tags":["垂直居中","CSS"],"categories":["学习笔记","CSS"]},{"title":"如何通过接口下载文件","path":"/2023/06/19/how-to-download-excel/","content":"后端通常会以文件流的形式将文件返回给前端，前端需要将获取到的文件内容转换成 blob 类型的数据，然后再下载到本地。 设置 responseType 为 blob以 axios 为例，通过设置 responseType 为 blob 把指定响应数据的类型指定为 Blob 对象 123456export function getFileFromApi() &#123;\treturn axios.get(&#123; url: `/xxx`, responseType: &#x27;blob&#x27;\t&#125;)&#125; 获取文件名可以从 content-disposition 响应头中拿到后端返回的文件名，当然也可以前端自定义文件名 content-disposition 响应头示例 1content-disposition: attachment;filename=&quot;example.xlsx&quot; 1234567891011const getFilename = (response: AxiosResponse): string =&gt; &#123; let filename = &quot;&quot;; const contentDisposition = response.headers[&quot;content-disposition&quot;]; // 可匹配： // attachment; filename=&quot;example.xlsx&quot; // attachment; filename=example.xlsx // attachment; filename*=UTF-8&#x27;&#x27;example.xlsx const fileNameMatch = contentDisposition?.match(/filename\\*?=[&#x27;&quot;]?(?:UTF-\\d[&#x27;&quot;]*)?([^;\\r &quot;&#x27;]*)[&#x27;&quot;]?;?/); if (fileNameMatch?.length === 2) filename = decodeURIComponent(fileNameMatch[1]); return filename;&#125;; 通过 a 标签下载文件123456789101112const downloadBlobFile = (data: BlobPart, fileName: string): void =&gt; &#123; const blob = new Blob([data]); const link = document.createElement(&quot;a&quot;); link.download = fileName; link.style.display = &quot;none&quot;; link.href = URL.createObjectURL(blob); link.target = &quot;blank&quot;; document.body.appendChild(link); link.click(); URL.revokeObjectURL(link.href); // 释放 URL 对象 document.body.removeChild(link);&#125; 使用方式 123getFileFromApi().then(response =&gt; &#123; downloadBlobFile(response.data, getFilename(response) || &quot;example.xlsx&quot;)&#125;)","tags":["文件下载","Blob"],"categories":["学习笔记"]},{"title":"消除 Vue 中 Unhandled error during execution of xxx 的警告","path":"/2023/06/16/vue/unhandled-error/","content":"以 Vue3 为例，通常我们会在 onMounted 钩子中处理异步请求 1234onMounted(() =&gt; &#123; await request() fn() // fn 只在 request 请求成功后被调用&#125;) 如果 request 请求出错而未处理，Vue 会抛出警告 虽然影响并不大，可警告看着还是不太舒服，索性还是想办法解决下 可通过下面几种方式消除警告 try…catch缺点：太丑了 12345678onMounted(() =&gt; &#123; try &#123; await request() &#125; catch(error) &#123; return &#125; fn() // fn 只在 request 请求成功后被调用&#125;) await…catch缺点：需要额外对错误类型进行判断 12345onMounted(() =&gt; &#123; const result = await request()!.catch(error =&gt; new Error()) if(result instanceof Error) return fn()&#125;) .then推荐使用，这时候 then 比 await 好用 123onMounted(() =&gt; &#123; request()?.then(fn, () =&gt; undefined)&#125;)","tags":["Vue"],"categories":["学习笔记","Vue"]},{"title":"Vue 中的特殊变量 $event","path":"/2023/06/16/vue/vue3-$event/","content":"根据 Vue 文档，在 Vue 中进行事件监听时，事件的回调函数有两种写法： 接受方法名：不带圆括号的形式不需要传参，event 对象将被自动当做实参传入。 123456789&lt;template&gt; &lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const greet = (event) =&gt; &#123; console.log(event) // event 对象&#125;&lt;/script&gt; 接受对某个方法的调用：带圆括号的形式可以传参，打印出来的 event 将会变成我们手动传递的那个参数。 123456789&lt;template&gt; &lt;button @click=&quot;greet(233)&quot;&gt;Greet&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const greet = (event) =&gt; &#123; console.log(event) // 233&#125;&lt;/script&gt; 如果现在既需要传递参数，又需要用到 event 对象，该如何做呢？ 这时候就需要用到 $event 这个特殊的变量啦，在内联声明的写法中，我们需要把 $event 变量作为参数，显式地传入方法中。 12345678910&lt;template&gt; &lt;button @click=&quot;greet($event, 233)&quot;&gt;Greet&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const greet = (event, x) =&gt; &#123; console.log(event) // event 对象 console.log(x) // 233&#125;&lt;/script&gt; 自定义事件中的 $event定义了一个子组件 MyButton，并给 $emit 提供一个额外的参数。 123&lt;button @click=&quot;$emit(&#x27;increaseBy&#x27;, 1)&quot;&gt; Increase by 1&lt;/button&gt; 通常用一个组件方法来作为事件处理函数，该方法会接收到事件所传递的参数。 12345678910&lt;template&gt; &lt;MyButton @increase-by=&quot;increaseCount&quot; /&gt;&lt;/template&gt;&lt;script setup&gt;const count = ref(0)function increaseCount(n) &#123; count.value += n&#125;&lt;/script&gt; 当需要给 increaseCount 函数额外传递参数时，也可以使用 $event，此时的 $event 就是事件附带的参数。 1234567891011&lt;template&gt; &lt;MyButton @increase-by=&quot;increaseCount($event, 233)&quot; /&gt;&lt;/template&gt;&lt;script setup&gt;const count = ref(0)function increaseCount(n, x) &#123; count.value += n console.log(x) // 233&#125;&lt;/script&gt;","tags":["Vue","$event"],"categories":["学习笔记","Vue"]},{"title":"script 标签的 defer 与 async 属性（转载）","path":"/2023/03/17/async-and-defer/","content":"原文戳这里👉：https://github.com/mrlmx/blogs/issues/4 前言在面试的时候，经常会遇到一道经典的面试题： 如何优化网页加载速度？ 常规的回答中总会有一条： 把 css 文件放在页面顶部，把 js 文件放在页面底部。 那么，为什么要把 js 文件放在页面的最底部呢？ 我们先来看下这段代码： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;Hi&lt;/title&gt; &lt;script&gt; console.log(&quot;Howdy ~&quot;); &lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue@3.2.41/dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router@4.1.5/dist/vue-router.global.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello 👋🏻 ~ &lt;/body&gt;&lt;/html&gt; 他的执行顺序是： 在控制台打印：Howdy ~ 请求并执行 vue.global.js 请求并执行 vue-router.global.js 在页面中展示：Hello 👋🏻 ~ 触发 DOMContentLoaded 事件 浏览器的解析规则是：如果遇到 script 标签，则暂停构建 DOM，转而开始执行 script 标签，如果是外部 script，那么浏览器还需要一直等待其「下载」并「执行」后，再继续解析后面的 HTML。 如果请求并执行「vue.global.js」需要 3 秒，「vue-router.global.js」需要 2 秒，那么页面中的 Hello 👋🏻 ~，则至少需要 5 秒以上才会展示出来。 可以看到，script 标签会阻塞浏览器解析 HTML，如果把 script 都放在 head 中，在网络不佳的情况下，就会导致页面长期处于白屏状态。 在很久以前，一般都是将这些外联脚本，放在 body 标签的最后面，确保先解析展示 body 中的内容，然后再一个个请求执行这些外联脚本。 那有没有其他更优雅的解决方案呢？ 答案是肯定的，现在 script 标签新增了 2 个属性：defer 和 async，就是为了解决此类问题，提升页面性能的。 &lt;script defer&gt;先看一下 MDN 上的解释： 这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。有 defer 属性的脚本会阻止 DOMContentLoaded 事件，直到脚本被加载并且解析完成。 文档是直接总结了他的特性，我们先看看下面的代码，展开说说细节，加深一下理解。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;Hi&lt;/title&gt; &lt;script&gt; console.log(&quot;Howdy ~&quot;); &lt;/script&gt; &lt;script defer src=&quot;https://unpkg.com/vue@3.2.41/dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;https://unpkg.com/vue-router@4.1.5/dist/vue-router.global.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello 👋🏻 ~ &lt;/body&gt;&lt;/html&gt; 他的执行顺序是： 在控制台打印：Howdy ~ 在页面中展示：Hello 👋🏻 ~ 请求并执行 vue.global.js 请求并执行 vue-router.global.js 触发 DOMContentLoaded 事件 如果在 script 标签上设置了 defer 属性，那么在浏览器解析到这里时，会默默的在后台开始下载此脚本，并继续解析后面的 HTML，并不会阻塞解析操作。 等到 HTML 解析完成之后，浏览器会立即执行后台下载的脚本，脚本执行完成之后，才会触发 DOMContentLoaded 事件。 看起来还是蛮好理解的吧？咱们再来讨论 2 个小细节： Q1：如果 HTML 解析完成之后，设置了 defer 属性的脚本还没下载完成，会怎样？A1：浏览器会等脚本下载完成之后，再执行此脚本，执行完成之后，再触发 DOMContentLoaded 事件。 Q2：如果有多个设置了 defer 属性的脚本，那浏览器会如何处理？A2：浏览器会并行的在后台下载这些脚本，等 HTML 解析完成，并且所有脚本下载完成之后，再按照他们在 HTML 中出现的相对顺序执行，等所有脚本执行完成之后，再触发 DOMContentLoaded 事件。 最佳实践： 建议所有的外联脚本都默认设置此属性，因为他不会阻塞 HTML 解析，可以并行下载 JavaScript 资源，还可以按照他们在 HTML 中的相对顺序执行，确保有依赖关系的脚本运行时，不会缺少依赖。 在 SPA 的应用中，可以考虑把所有的 script 标签加上 defer 属性，并且放到 body 的最后面。在现代浏览器中，可以并行下载提升速度，也可以确保在老浏览器中，不阻塞浏览器解析 HTML，起到降级的作用。 注意： defer 属性仅适用于外部脚本，如果 script 脚本没有 src，则会忽略 defer 特性。 defer 属性对模块脚本（&lt;script type=&#39;module&#39;&gt;&lt;/script&gt;）无效，因为模块脚本就是以 defer 的形式加载的。 &lt;script async&gt;按照惯例，先看一下 MDN 上的解释： 对于普通脚本，如果存在 async 属性，那么普通脚本会被并行请求，并尽快解析和执行。对于模块脚本，如果存在 async 属性，那么脚本及其所有依赖都会在延缓队列中执行，因此它们会被并行请求，并尽快解析和执行。该属性能够消除解析阻塞的 Javascript。解析阻塞的 Javascript 会导致浏览器必须加载并且执行脚本，之后才能继续解析。 感觉这段描述的已经蛮清晰了，不过咱们还是先看看下面的代码，展开说说细节，加深一下理解。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;Hi&lt;/title&gt; &lt;script&gt; console.log(&quot;Howdy ~&quot;); &lt;/script&gt; &lt;script async src=&quot;https://google-analytics.com/analytics.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;https://ads.google.cn/ad.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello 👋🏻 ~ &lt;/body&gt;&lt;/html&gt; 他的执行顺序是： 在控制台打印：Howdy ~ 并行请求 analytics.js 和 ad.js 在页面中展示：Hello 👋🏻 ~ 根据网络的实际情况，以下几项会无序执行 执行 analytics.js （下载完后，立即执行） 执行 ad.js （下载完后，立即执行） 触发 DOMContentLoaded 事件（可能在在上面 2 个脚本之前，之间，之后触发） 浏览器在解析到带有 async 属性的 script 标签时，也不会阻塞页面，同样是在后台默默下载此脚本。当他下载完后，浏览器会暂停解析 HTML，立马执行此脚本。 看起来还是蛮好理解的吧？咱们再来讨论 2 个小细节： Q1：如果设置了 async 属性的 script 下载完之后，浏览器还没解析完 HTML，会怎样？A1：浏览器会暂停解析 HTML，立马执行此脚本，等执行完之后，再继续解析 HTML。 Q2：如果有多个 async 属性的 script 标签，那等他们下载完成之后，会按照代码顺序执行吗？A2：不会。执行顺序是：谁先下载完成，谁先执行。async 的特点是「完全独立」，不依赖其他内容。 最佳实践： 当我们的项目，需要集成其他独立的第三方库时，可以使用此属性，他们不依赖我们，我们也不依赖于他们。通过设置此属性，让浏览器异步下载并执行他，是个不错的优化方案。 注意： async 特性仅适用于外部脚本，如果 script 脚本没有 src，则会忽略 async 特性。 总结defer 不阻塞浏览器解析 HTML，等解析完 HTML 之后，才会执行 script。 会并行下载 JavaScript 资源。 会按照 HTML 中的相对顺序执行脚本。 会在脚本下载并执行完成之后，才会触发 DOMContentLoaded 事件。 在脚本执行过程中，一定可以获取到 HTML 中已有的元素。 defer 属性对模块脚本无效。 适用于：所有外部脚本（通过 src 引用的 script）。 async 不阻塞浏览器解析 HTML，但是 script 下载完成后，会立即中断浏览器解析 HTML，并执行此 script。 会并行下载 JavaScript 资源。 互相独立，谁先下载完，谁先执行，没有固定的先后顺序，不可控。 由于没有确定的执行时机，所以在脚本里面可能会获取不到 HTML 中已有的元素。 DOMContentLoaded 事件和 script 脚本无相关性，无法确定他们的先后顺序。 适用于：独立的第三方脚本。 另外：async 和 defer 之间最大的区别在于它们的执行时机。 One More Thing 你有没有想过，如果一个 script 标签同时设置 defer 和 async，浏览器会如何处理？ 先说结论：从表现形式上来说，async 的优先级比 defer 高，也就是如果同时存在这 2 个属性，那么浏览器将会以 async 的特性去加载此脚本。 这主要分 2 种情况： 如果是「普通脚本」，浏览器会优先判断 async 属性是否存在，如果存在，则以 async 特性去加载此脚本，如果不存在，再去判断是否存在 defer 属性。 如果是「模块脚本」，浏览器会判断 async 属性是否存在： 如果存在，浏览器会并行下载此模块和他的所有依赖模块，等全部下载完成之后，会立刻执行此脚本。 如果不存在，浏览器也会并行下载此模块和他的所有依赖模块，然后等浏览器解析完 HTML 之后，再执行此脚本。 另外需要注意的是：在模块脚本上设置 defer 属性是无效的。 一图胜千言 最后，用一张图概括一下这两个属性的加载模式吧： 思考题🤔 为什么浏览器在解析到普通的 script 标签时，必须先执行他？ 普通的 script 标签会阻塞浏览器解析 HTML，这会导致什么问题？","tags":["async","defer"],"categories":["学习笔记"]},{"title":"浅尝类型体操","path":"/2023/02/22/typescript/ts-14/","content":"基本原理if(A &lt;&#x3D; B)if(A &lt;&#x3D; B) true else false 123type A = 1;type B = 1 | 2;type Result = A extends B ? true : false; // true if(A &lt;&#x3D; B) and (C &lt;&#x3D; D)1234567891011type A = 1;type B = 1 | 2;type C = 3;type D = 3 | 4;type Result = A extends B ? C extends D ? &#x27;true, true&#x27; : &#x27;true, false&#x27; : C extends D ? &#x27;false, true&#x27; : &#x27;false, false&#x27;; // &quot;true, true&quot; 空元组12345type A = [];type IsEmptyArray&lt;Arr extends unknown[]&gt; = Arr[&#x27;length&#x27;] extends 0 ? true : false;type Result = IsEmptyArray&lt;A&gt;; // true 元组与数组的区别是：数组长度没有限制，而元组长度有限制； 可以理解为：元组就是长度固定的数组 非空元组12345type A = [1];type NotEmpty&lt;Arr extends unknown[]&gt; = Arr extends [...infer X, infer Last] ? true : false;type Result = NotEmpty&lt;A&gt;; // true [...infer X, infer Last] 表示至少存在一个元素的数组，那么 Arr extends [...infer X, infer Last] 表示的意思是：Arr 是否属于（包含于）一个非空数组 判断是否为非空元组的两种方法： array[&#39;length&#39;] !== 0 array extends [...infer X, infer Rest] === true 递归12345type A = [&#x27;Ich&#x27;, &#x27;☆&#x27;, &#x27;liebe&#x27;, &#x27;☆&#x27;, &#x27;dich&#x27;];type Reverse&lt;Arr extends unknown[]&gt; = Arr extends [...infer Rest, infer Last] ? [Last, ...Reverse&lt;Rest&gt;] : Arr;type Result = Reverse&lt;A&gt;; // [&quot;dich&quot;, &quot;☆&quot;, &quot;liebe&quot;, &quot;☆&quot;, &quot;Ich&quot;] 注意：递归是有层数限制的 模式匹配 + infer 引用123type Tuple = [&#x27;Ich&#x27;, &#x27;☆&#x27;, &#x27;liebe&#x27;, &#x27;☆&#x27;, &#x27;dich&#x27;];type Result1 = Tuple extends [infer First, ...infer Rest] ? First : never; // &quot;Ich&quot;type Result2 = Tuple extends [infer First, ...infer Rest] ? Rest : never; // [&quot;☆&quot;, &quot;liebe&quot;, &quot;☆&quot;, &quot;dich&quot;] inter 出现在条件类型中，通常与 extends 关键字一起使用 infer 显示地声明了一个新的泛型变量，用于表示待推断的类型 当一个类型无法通过简单的方式访问到时, 我们可以使用 infer 关键字来实现对其的快速访问；换言之，使用 infer 往往是因为后面需要用到对应的变量，比如上述的 First 和 Rest，表示做一个引用（个人理解） 不写引用，直接写类型也是可以的 123type Tuple = [&#x27;Ich&#x27;, &#x27;☆&#x27;, &#x27;liebe&#x27;, &#x27;☆&#x27;, &#x27;dich&#x27;];type Result1 = Tuple extends [infer First, ...string[]] ? First : never; // &quot;Ich&quot;type Result2 = Tuple extends [&#x27;Ich&#x27;, ...infer Rest] ? Rest : never; // [&quot;☆&quot;, &quot;liebe&quot;, &quot;☆&quot;, &quot;dich&quot;] 元组体操[1] &#x3D;&gt; [1, 2]12type A = [1];type B = [...A, 2]; // [1, 2] [1, 2] [3, 4] &#x3D;&gt; [1, 2, 3, 4]123type B = [1, 2];type C = [3, 4];type D = [...B, ...C]; // [1, 2, 3, 4] [1, 2, 3, 4] &#x3D;&gt; 412345type D = [1, 2, 3, 4];// 注意 1,2,3,4 都是类型，不是值type Last&lt;T&gt; = T extends [...items: unknown[], last: infer X] ? X : never;type E = Last&lt;D&gt;;// ^--- E = 4 注意这里的 4 是类型，不是值 这里顺便提一下错误的写法 12345type D = [1, 2, 3, 4];// 注意 1,2,3,4 都是类型，不是值type Last&lt;T extends unknown[]&gt; = T[T[&quot;length&quot;] - 1]// TS 并没有提供 - 1 操作type E = Last&lt;D&gt; [1, 2, 3, 4] &#x3D;&gt; [1, 2, 3]12345type D = [1, 2, 3, 4];// 注意 1,2,3,4 都是类型，不是值type NoLast&lt;T&gt; = T extends [...infer X, unknown] ? X : never;type E = NoLast&lt;D&gt;;// ^--- E = [1,2,3] 注意是类型，不是值 字符串体操‘a’ &#x3D;&gt; ‘A’123456type A = &#x27;vivy&#x27;;type B = Capitalize&lt;A&gt;;// ^-- type B = &quot;Vivy&quot;type C = &#x27;Ich&#x27; | &#x27;☆&#x27; | &#x27;liebe&#x27; | &#x27;☆&#x27; | &#x27;dich&#x27;;type X = Capitalize&lt;C&gt;;// ^-- type X = &quot;Ich&quot; | &quot;☆&quot; | &quot;Liebe&quot; | &quot;Dich&quot; 对联合类型使用 Capitalize 依旧遵循前面讲的分配率，即对每个类型单独进行大写操作后再合并起来 12345678910111213141516/** * 全变成大写 */type Uppercase&lt;S extends string&gt; = intrinsic;/** * 全变成小写 */type Lowercase&lt;S extends string&gt; = intrinsic;/** * 首字母大写 */type Capitalize&lt;S extends string&gt; = intrinsic;/** *首字母小写 */type Uncapitalize&lt;S extends string&gt; = intrinsic; intrinsic 表示是 TS 内置的泛型 ‘a’ ‘b’ &#x3D;&gt; ‘ab’1234567type A = &#x27;Ich&#x27;;type B = &#x27;☆&#x27;;type C = &#x27;liebe&#x27;;type D = &#x27;☆&#x27;;type E = &#x27;dich&#x27;;type X = `$&#123;A&#125; $&#123;B&#125; $&#123;C&#125; $&#123;D&#125; $&#123;E&#125;`;// ^-- type X = &quot;Ich ☆ liebe ☆ dich&quot; ‘ab’ &#x3D;&gt; ‘a’1234type A = &quot;Ich ☆ liebe ☆ dich&quot;type First&lt;T&gt; = T extends `$&#123;infer F&#125;$&#123;string&#125;` ? F : nevertype Result = First&lt;A&gt;// ^-- &quot;I&quot; ‘ab’ &#x3D;&gt; ‘b’字符串模式匹配的缺陷：只能获取到字符串中的第一个字符，获取不到最后一个字符 那么如何才能做到获取最后一个字符呢？ 这里给出思路： 我们可以获取元组的最后一项 字符串可以转为元组 我们可以获取字符串的最后一项 12345678910type LastOfTuple&lt;T extends unknown[]&gt; = T extends [...infer _, infer Last] ? Last : never;type StringToTuple&lt;S extends string&gt; = S extends `$&#123;infer First&#125;$&#123;infer Rest&#125;` ? [First, ...StringToTuple&lt;Rest&gt;] : [];type LastOfString&lt;T extends string&gt; = LastOfTuple&lt;StringToTuple&lt;T&gt;&gt;;type Result = LastOfString&lt;&#x27;Ich ☆ liebe ☆ dich&#x27;&gt;;// ^-- &quot;h&quot; string &#x3D;&gt; 联合类型12345type StringToUnion&lt;S extends string&gt; = S extends `$&#123;infer First&#125;$&#123;infer Rest&#125;` ? First | StringToUnion&lt;Rest&gt; : never;type Result = StringToUnion&lt;&#x27;Ich☆liebe☆dich&#x27;&gt;;// type Result = &quot;I&quot; | &quot;c&quot; | &quot;h&quot; | &quot;☆&quot; | &quot;l&quot; | &quot;i&quot; | &quot;e&quot; | &quot;b&quot; | &quot;d&quot; 注意：联合类型自动去重了 string &#x3D;&gt; 元组12345type StringToTuple&lt;S extends string&gt; = S extends `$&#123;infer First&#125;$&#123;infer Rest&#125;` ? [First, ...StringToTuple&lt;Rest&gt;] : [];type Result = StringToTuple&lt;&#x27;Ich☆liebe☆dich&#x27;&gt;;// type Result = [&quot;I&quot;, &quot;c&quot;, &quot;h&quot;, &quot;☆&quot;, &quot;l&quot;, &quot;i&quot;, &quot;e&quot;, &quot;b&quot;, &quot;e&quot;, &quot;☆&quot;, &quot;d&quot;, &quot;i&quot;, &quot;c&quot;, &quot;h&quot;] 注意：元组没有去重","tags":["TypeScript","类型体操","infer"],"categories":["学习笔记","TypeScript"]},{"title":"面向对象之 class（下）","path":"/2023/02/17/typescript/ts-13/","content":"四种成员可见性public（类外可见）public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public private（类内可见）private 修饰的属性或方法是私有的，不能在声明它的类的外部访问 protected（子类可见）protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的 #var（真私有属性）上面的都是 TS 的语法（访问修饰符），而 #var 是 JS 的语法，在属性名前面加上 # 即可做到真正的属性私有 注意：由于 private 是 TS 的语法，在类型被擦除后就没了；真正的私有属性得使用 # 才能做到 static 属性与 static block我们可以使用 static 来定义一个静态属性，静态属性只能通过类名来访问 1234567891011class Dog &#123; static kind = &quot;狗&quot;; constructor() &#123; // ... &#125;&#125;const dog = new Dog();console.log(dog.kind); // undefinedconsole.log(Dog.kind); // &quot;狗&quot; 注意：用 static 声明的属性，其名称不能是 name、prototype、length、arguments、caller 其中之一 因为 js 中的类都是通过函数来模拟的 static block 主要用来初始化私有属性（类外部无法初始化私有属性） 12345678910class Foo &#123; static #count = 0; static &#123; const count = loadFromLocalStorage() || 0; Foo.#count += count; &#125; constructor() &#123; console.log(Foo.#count); &#125;&#125; 类与泛型123456789101112131415class Hash&lt;K, V&gt; &#123; map: Map&lt;K, V&gt; = new Map(); set(key: K, value: V) &#123; this.map.set(key, value); &#125; get(key: K) &#123; return this.map.get(key); &#125;&#125;class Hash&lt;K, V&gt; extends Map&lt;K, V&gt; &#123; destroy() &#123; this.clear(); &#125;&#125; class 表达式将匿名的 class 赋值给一个变量 1234567const Rectangle = class &#123; constructor(public height: number, public width: number) &#123;&#125; area() &#123; return this.height * this.width; &#125;&#125;;const r = new Rectangle(100, 200); 抽象类（不常用）abstract 用于定义抽象类和其中的抽象方法 抽象类不允许被实例化 12345678abstract class Base &#123; abstract getName(): string; printName() &#123; console.log(&#x27;Hello, &#x27; + this.getName()); &#125;&#125;const b = new Base();// ^--- 报错：Cannot create an instance of an abstract class 抽象类中的抽象方法必须被子类实现，之后才可进行实例化 12345678910111213abstract class Base &#123; abstract getName(): string; printName() &#123; console.log(&#x27;Hello, &#x27; + this.getName()); &#125;&#125;class Derived extends Base &#123; getName() &#123; return &#x27;world&#x27;; &#125;&#125;const d = new Derived();d.printName(); 可以看出，抽象类是介于 interface 和 class 之间的一种写法 如果一个 class 中的属性全都是抽象属性，那么也可以直接把这个 class 当作 interface 把类当作参数（常用）注意是把类作为参数，而不是把类的实例化对象作为参数 123456789101112class Person &#123; constructor(public name: string) &#123;&#125; sayHi() &#123; console.log(`Hi, I am $&#123;this.name&#125;`); &#125;&#125;function greet(constructor: typeof Person) &#123; const p = new constructor(&#x27;ClariS&#x27;); p.sayHi();&#125;greet(Person); // 不报错greet(new Person(&#x27;ClariS&#x27;)); // 报错 123456789101112class Person &#123; constructor(public name: string) &#123;&#125; sayHi() &#123; console.log(`Hi, I am $&#123;this.name&#125;`); &#125;&#125;function greet(constructor: new (name: string) =&gt; Person) &#123; const p = new constructor(&#x27;ClariS&#x27;); p.sayHi();&#125;greet(Person); // 不报错greet(new Person(&#x27;ClariS&#x27;)); // 报错","tags":["TypeScript","class"],"categories":["学习笔记","TypeScript"]},{"title":"面向对象之 class（上）","path":"/2023/02/16/typescript/ts-12/","content":"思考题：写入属性时会覆盖共有属性吗？12345678910111213141516171819function Person(name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; constructor: Person, sayHi(target) &#123; console.log(`你好，$&#123;target.name&#125;，我是 $&#123;this.name&#125;`) &#125;&#125;const p0 = new Person(&quot;ClariS&quot;, 17)const p1 = new Person(&quot;vivy&quot;, 18)const p2 = new Person(&quot;k423&quot;, 19)p1.sayHi = function (target) &#123; console.log(`我是 $&#123;target.name&#125; `)&#125;p2.sayHi(p0) // 1. 你好，ClariS，我是 k423// 2. 我是 ClariS 上面代码的打印结果是 1 还是 2 ？ 答案是 1，当我们向实例对象上写入属性时，并不会覆盖原型上的共有属性 我们把实例对象的结构打印出来看看 可以看到，读取与写入的规则是不一样的 读取 p0、p1、p2的 sayHi 属性时，会先看自身上的独有属性中是否存在 sayHi，再去看原型上的共有属性； 而当向 p0、p1、p2 上写入属性时，会直接把属性写入到实例对象上，并不会覆盖原型上的 sayHi 方法。 interface 和 class 的区别interface 和 class 都是用来描述对象的 1234interface PointInterface &#123;&#125;class PointClass &#123;&#125;const p = new PointClass(); 当 tsconfig.json 中设置 &quot;strictPropertyInitialization&quot;: false 时 12345678910111213interface PointInterface &#123; x: number; y: number;&#125;// 不报错class PointClass &#123; x: number; y: number;&#125;const p = new PointClass();p.x = 1;p.y = 1; 当 tsconfig.json 中设置 &quot;strictPropertyInitialization&quot;: true 或 &quot;strict&quot;: true 时 12345678910interface PointInterface &#123; x: number; y: number;&#125;// 报错：Property &#x27;x&#x27; has no initializer and is not definitely assigned in the constructorclass PointClass &#123; x: number; y: number;&#125; 区别：interface 只有成员的类型没有实现，class 须同时有成员的类型和实现 class 的 4 种初始化方法① 声明类型并给初始值 1234class PointClass &#123; x: number = 0; y: number = 0;&#125; ② 只给初始值，类型让 TS 自动推断 1234class PointClass &#123; x = 0; y = 0;&#125; ③ 声明类型，并在构造函数中给初始值 12345678class PointClass &#123; x: number; y: number; constructor() &#123; this.x = 0; this.y = 0; &#125;&#125; ④ 断言，告诉 TS 别检查，我自己一定能保证初始值存在 123456789101112class PointClass &#123; x!: number; y!: number; constructor() &#123; this.init(); &#125; // 当我们进行初始化操作，但初始化操作不在 constructor 中时，TS 是检测不出来的，因此需要进行断言 init() &#123; this.x = 0; this.y = 0; &#125;&#125; class 的构造函数123456789101112class Point &#123; x: number; y: number; constructor(x = 0, y = 0) &#123; // 生成实例对象时才会执行 this.x = x; this.y = y; &#125;&#125;const p = new Point()console.log(p.x, p.y) public 缩写可以使用以下的缩写语法来代替上述写法，和上述的写法是完全等价的 123456class Point &#123; constructor(public x = 0, public y = 0) &#123; &#125;&#125;const p = new Point()console.log(p.x, p.y) 不写初始值也不报错 123456class Point &#123; constructor(public x?: number, public y?: number) &#123; &#125;&#125;const p = new Point()console.log(p.x, p.y) 结合函数重载123456789101112131415161718192021class Point &#123; x!: number; y!: number; constructor(x: number, y: number); constructor(s: string); constructor(xs: number | string, y?: number) &#123; if (typeof xs === &#x27;number&#x27; &amp;&amp; typeof y === &#x27;number&#x27;) &#123; this.x = xs this.y = y &#125; else if (typeof xs === &#x27;string&#x27;) &#123; const parts = xs.split(&#x27;,&#x27;) this.x = parseFloat(parts[0]) this.y = parseFloat(parts[1]) &#125; &#125;&#125;const p = new Point(&#x27;1,2&#x27;)console.log(p.x, p.y) 结合索引签名1234567891011class Hash &#123; [s: string]: unknown set(key: string, value: unknown) &#123; this[key] = value &#125; get(key: string) &#123; return this[key] &#125;&#125; class 实现接口实现一个接口 12345678910111213141516interface Person &#123; name: string sayHi: (target: Person) =&gt; void&#125;class User implements Person &#123; constructor(public name: string) &#123; &#125; sayHi(target: Person) &#123; console.log(`Hi $&#123;target.name&#125;`) &#125;&#125;// 通过观察不难发现：// 类 - 类 =&gt; 继承// 类型 - 类型 =&gt; 继承// 类 - 类型 =&gt; 实现 实现多个接口 123456789101112131415161718192021222324252627interface Person &#123; name: string sayHi: (target: Person) =&gt; void&#125;interface Taggable &#123; tags: string[] addTag: (tag: string) =&gt; void removeTag: (tag: string) =&gt; void&#125;class User implements Person, Taggable &#123; tags: string[] = [] constructor(public name: string) &#123; &#125; sayHi(target: Person) &#123; console.log(`Hi $&#123;target.name&#125;`) &#125; addTag(tag: string) &#123; this.tags.push(tag) &#125; removeTag(tag: string) &#123; const index = this.tags.indexOf(tag) this.tags.splice(index, 1) // this.tags = this.tags.filter(t =&gt; t !== tag) &#125;&#125; 即使接口中存在可选属性，也必须得在 class 中实现它，不然会报错 12345678910111213141516interface Person &#123; name: string age?: number sayHi: (target: Person) =&gt; void&#125;class User implements Person &#123; constructor(public name: string) &#123; &#125; sayHi(target: Person) &#123; console.log(`Hi $&#123;target.name&#125;`) &#125;&#125;const u = new User(&#x27;ClariS&#x27;)u.age // Property &#x27;age&#x27; does not exist on type &#x27;User&#x27; class 继承 class123456789101112131415161718class Person &#123; constructor(public name: string) &#123; &#125; sayHi() &#123; console.log(`你好，我是$&#123;this.name&#125;`); &#125;&#125;class User extends Person &#123; constructor(public id: number, name: string) &#123; super(name) &#125; login() &#123; &#125;&#125;const u = new User(1, &#x27;ClariS&#x27;);u.sayHi()u.login() 注意： 只能继承一个 class，无法同时继承多个 class 在调用 super() 之前不能使用 this 重写函数12345678910111213141516171819class Person &#123; constructor(public name: string) &#123;&#125; sayHi() &#123; console.log(`你好，我是$&#123;this.name&#125;`); &#125;&#125;class User extends Person &#123; constructor(public id: number, name: string) &#123; super(name); &#125; login() &#123;&#125; sayHi(target?: User) &#123; // target 只能是可选 if (target === undefined) &#123; super.sayHi(); &#125; else &#123; console.log(`你好，$&#123;target.name&#125;，我是 $&#123;this.name&#125;`); &#125; &#125;&#125; 注意函数参数类型之间的兼容关系，比如此处 Person 的 syaHi 的参数为空，那么重写的 sayHi 函数的参数 target 只能是可选的 重写属性123456789101112131415class Person &#123; friend?: Person; constructor(public name: string, friend?: Person) &#123; this.friend = friend; &#125;&#125;class User extends Person &#123; declare friend: User; constructor(public id: number, name: string, friend?: User) &#123; super(name, friend); &#125;&#125;const u1 = new User(1, &#x27;ClariS&#x27;);const u2 = new User(1, &#x27;vivy&#x27;, u1);u2.friend; 注意：declare 后面声明 friend 的类型必须是兼容父类中 friend 的类型的，比如此处 User 是兼容 Person 的","tags":["TypeScript","class"],"categories":["学习笔记","TypeScript"]},{"title":"面向对象之原型","path":"/2023/02/09/typescript/ts-11/","content":"用 JS 造一个小兵1234567891011121314const 近战兵 = &#123; 兵种: &quot;近战&quot;, 血量: 1488, 物理攻击力: 60, 护甲: 180, 金钱: 42, 补刀奖励: 16, 出生: function () &#123;/* 出生动画 */&#125;, 死亡: function () &#123;/* 死亡动画 */&#125;, 攻击: function () &#123;/* 攻击特效 */&#125;, 行走: function () &#123;/* 行走动画 */&#125;,&#125;兵营(近战兵) 需求：造 100 个小兵 JS 如何创建对象 以 new 为语法糖 用构造函数给对象添加独有属性 用构造函数的 prototype 容纳共有属性 使用属性查找规则 属性查找规则","tags":["TypeScript","原型"],"categories":["学习笔记","TypeScript"]},{"title":"泛型编程（下）","path":"/2023/02/07/typescript/ts-10/","content":"本文介绍了一些 TS 内置工具类型的用法及实现 Readonly &amp; Mutable123456789101112131415161718192021type Person = &#123; id: number; name: string; age: number &#125;;type MyReadonly&lt;T&gt; = &#123; readonly [K in keyof T]: T[K];&#125;;type X1 = MyReadonly&lt;Person&gt;;// &#123;// readonly id: number;// readonly name: string;// readonly age: number;// &#125;type MyMutable&lt;T&gt; = &#123; -readonly [K in keyof T]: T[K];&#125;;type X9 = MyMutable&lt;Readonly&lt;Person&gt;&gt;;// &#123;// id: number;// name: string;// age: number;// &#125; 注意： Mutable 并不是 TS 内置的函数 -readonly [] 表示去掉属性前面的 Readonly Partial &amp; Required123456789101112131415161718192021type Person = &#123; id: number; name: string; age: number &#125;;type MyPartial&lt;T&gt; = &#123; [K in keyof T]?: T[K];&#125;;type X2 = MyPartial&lt;Person&gt;;// &#123;// id?: number;// name?: string;// age?: number;// &#125;type MyRequired&lt;T&gt; = &#123; [K in keyof T]-?: T[K];&#125;;type X3 = MyRequired&lt;Person&gt;;// &#123;// id: number;// name: string;// age: number;// &#125; 注意 -?，表示去掉属性的可选，变为必选 Exclude &amp; Extract12345type MyExclude&lt;A, B&gt; = A extends B ? never : A;type X5 = Exclude&lt;1 | 2 | 3, 1 | 2&gt;; // 3type MyExtract&lt;A, B&gt; = A extends B ? A : never;type X6 = MyExtract&lt;1 | 2 | 3, 2 | 4&gt;; // 2 按照之前讲的乘法分配律，有如下理解过程： 12345678type X5 = 1 | 2 | 3 extends 1 | 2 ? never : Atype X5 = | 1 extends 1 | 2 ? never : 1 // never| 2 extends 1 | 2 ? never : 2 // never| 3 extends 1 | 2 ? never : 3 // 3type X5 = never | never | 3 // 3 X6 的理解过程同 X5，这里不赘述 Omit &amp; Pick12345678910111213type Person = &#123; id: number; name: string; age: number &#125;;type MyOmit&lt;T, Key extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, Key&gt;&gt;;// 或者type MyOmit&lt;T, Key extends keyof T&gt; = &#123; [K2 in keyof T as (K2 extends Key ? never : K2)]: T[K2];&#125;;type X7 = MyOmit&lt;Person, &#x27;name&#x27; | &#x27;age&#x27;&gt;; // &#123; id: number &#125;type MyPick&lt;T, Key extends keyof T&gt; = &#123; [K2 in Key]: T[K2];&#125;;type X8 = MyPick&lt;Person, &#x27;name&#x27; | &#x27;age&#x27;&gt;; // &#123; name: string; age: number &#125; Key extends keyof T 是一个泛型约束，约束所传的 key 必须包含在 keyof T 中，即必须是 &#39;id&#39; | &#39;name&#39; | &#39;age&#39; 的子集 MyOmit 的第二个写法中，集合 K2 extends Key ? never : K2 小于或等于集合 K2 in keyof T，依旧遵循之前讲的类型兼容，类型小的可赋值给类型大的，查看实现思路 Record12345type MyRecord&lt;Key extends string | number | symbol, Value&gt; = &#123; [k in Key]: Value;&#125;;type X4 = MyRecord&lt;string, string&gt;; // &#123; [x: string]: string &#125; ReturnType1234567891011type MyReturnType&lt;T extends (...args: any[]) =&gt; unknown&gt; = T extends (...args: any[]) =&gt; infer U ? U : neverconst fn = (v: boolean) =&gt; &#123; if (v) return 1 else return 2&#125;type Result = MyReturnType&lt;typeof fn&gt; // 应推导出 &quot;1 | 2&quot; Awaited1234567type MyAwaited&lt;T extends PromiseLike&lt;any&gt;&gt; = T extends PromiseLike&lt;infer U&gt; ? U extends PromiseLike&lt;any&gt; ? MyAwaited&lt;U&gt; : U : never;type Result = MyAwaited&lt;Promise&lt;string&gt;&gt; // string PromiseLike 表示一个对象具有 then 方法，它可以像 Promise 一样使用链式调用。 PromiseLike 可以表示内置的 Promise 对象和第三方库或自定义实现的 thenable 对象，因此 PromiseLike 提供了更广泛的兼容性。 限制传入的类型必须是 PromiseLike 使用 infer 推导 PromiseLike 参数类型 如果推导类型仍为 PromiseLike，就循环调用 MyAwaited 否则直接返回推导类型 Parameters12345678type MyParameters&lt;T extends (...args: any[]) =&gt; unknown&gt; = T extends (...args: infer P) =&gt; unknown ? P : never;const foo = (arg1: string, arg2: number): void =&gt; &#123;&#125;type Result = MyParameters&lt;typeof foo&gt; // [arg1: string, arg2: number] 限制传入的类型必须是函数类型 使用 infer 推导函数的参数类型 由于 ...args 本身已经是元组类型，因此 infer P 最终推导出的，也是元组类型 其他这里推荐一个用于练习 TS 类型体操的 repo：TypeScript 类型体操姿势合集 看看别人的体操： 用 TypeScript 类型运算实现一个中国象棋程序 TypeScript 类型体操天花板，用类型运算写一个 Lisp 解释器","tags":["TypeScript","泛型"],"categories":["学习笔记","TypeScript"]},{"title":"泛型编程（上）","path":"/2023/02/06/typescript/ts-9/","content":"泛型就像函数函数 12const f = (a, b) =&gt; a + bconst result = f(1, 2) // 3 泛型 12type F&lt;A, B&gt; = A | Btype Result = F&lt;string, number&gt; // string | number 泛型就像函数 函数的本质是什么 函数的本质是推后执行的、部分待定的代码 123456789101112131415// 立即执行console.log(1)// 推后一步执行const f1 = () =&gt; console.log(1)f1()// 推后两步执行const f2 = () =&gt; console.log(1)console.log(2)f2()// 部分待定的const f3 = (fn, n) =&gt; fn(n) // 参数待定f3(console.log, 3) 泛型的本质是什么 泛型的本质是推后执行的、部分待定的类型 没有泛型的类型系统，就如同没有函数的编程语言 什么时候需要泛型当我们需要准确的定义返回值的类型的时候，就需要泛型 这时候你可能会说，做类型收窄不就行了吗？就像下面这样 12345678910function echo(whatever: number | string | boolean) &#123; switch (typeof whatever) &#123; case &#x27;number&#x27;: return whatever; case &#x27;string&#x27;: return whatever; case &#x27;boolean&#x27;: return whatever; &#125;&#125; 但是你会发现，这样写得到的返回值类型是不准确的 123const a = echo(233);// 我们期望 a 的类型是 233// 但 a 的类型却是 string | number | boolean 这时候，泛型就派上用场了 123456function echo&lt;T&gt;(whatever: T): T &#123; return whatever;&#125;const a = echo(233);// a 的类型为 233 简单泛型示例12345678910type Union&lt;A, B&gt; = A | B;type Union3&lt;A, B, C&gt; = A | B | C;type Intersect&lt;A, B&gt; = A &amp; B;type Intersect3&lt;A, B, C&gt; = A &amp; B &amp; C;interface List&lt;A&gt; &#123; [index: number]: A;&#125;interface Hash&lt;V&gt; &#123; [key: string]: V;&#125; 条件类型（Conditional Types） T extends string 可理解为 T &lt;= string（T 包含于 string） 123456type R1 = LikeString&lt;&#x27;hi&#x27;&gt; // truetype R2 = LikeString&lt;true&gt; // falsetype S1 = LikeNumber&lt;2333&gt; // 1type S2 = LikeNumber&lt;false&gt; // 2type T1 = LikePerson&lt;&#123; name: &#x27;ClariS&#x27;, age: 18 &#125;&gt; // yestype T2 = LikePerson&lt;&#123; age: 1 &#125;&gt; // no 泛型中的特殊运算规则 现有如下泛型 ToArray 1type ToArray&lt;T&gt; = T extends unknown ? T[] : never; 问：type Result = ToArray&lt;string | number&gt; 的类型是什么？ 直接说答案：Result 为 string[] | number[] 你可能会疑惑，按照一般的理解，string | number 是包含于 unknown 的，那么 Result 就应该是 (string | number)[] 呀 按照通常的理解是没错，但因为这是在泛型中，因此规则会有些许不同 可以按照如下拆分过程来进行理解记忆： 1234type Result = ToArray&lt;string | number&gt;;// type Result = (string | number) extends unknown ? ...// type Result = (string extends unknown ? ...) | (number extends unknown ? ...)// type Result = string[] | number[] 即泛型中的联合类型会分开进行运算（extends 运算），这就好像是乘法中的分配率 (A + B) X C = A X C + B X C 再问：type Result2 = ToArray&lt;never&gt; 的类型是什么？ 答案是 never 同样按照一般的理解，通常情况下（非泛型中），never 是包含于 unknown 的，那么 Result 应该是 never[] 才对 但 Result 在此处却为 never 1type Result = ToArray&lt;never&gt;; // never 即泛型中的 never 进行任何运算（extends 运算或者 &amp; 运算）都只会得到 never，这就好像是乘法中的零 0 X C = 0 注意：以上讨论的规则只对泛型有效 在非泛型中，使用 extends 运算会得到不一样的结果 12345678// 非泛型type T0 = never extends never ? true : false// ^? type T0 = true// 泛型type IsNever&lt;T&gt; = T extends never ? true : falsetype T1 = IsNever&lt;never&gt;// ^? type T1 = never 那么，如何才能禁用泛型中的自动拆分规则呢？ 我们可以构造一个类型，在外面包裹上一个新的类型来防止 TypeScript 遍历 extends 左侧类型的行为，比如下面的 [] 123456789type IsNever&lt;T&gt; = [T] extends [never] ? true : falsetype T0 = IsNever&lt;never&gt;// ^? type T0 = truetype ToArray&lt;T&gt; = [T] extends unknown ? T[] : never;type Result1 = ToArray&lt;string | number&gt;;// ^? type Result1 = (string | number)[]type Result2 = ToArray&lt;never&gt;;// ^? type Result2 = never[] 在泛型中使用 keyofkeyof 关键字用于获取对象类型的所有键的联合类型 1234type Person = &#123; name: string; age: number &#125;;type GetKeys&lt;T&gt; = keyof T;type Result = GetKeys&lt;Person&gt;;// ^-- &#x27;name&#x27; | &#x27;age&#x27; 常和映射类型一起使用 123type Readonly&lt;T&gt; = &#123; readonly [K in keyof T]: T[K];&#125;; keyof 也可用于数组 &#x2F; 元组 12type A = keyof [1, 2, 3];// A 的类型为 &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | ... 在泛型中使用 extends keyof12345type Person = &#123; name: string; age: number &#125;;type GetKeyType&lt;T, K extends keyof T&gt; = T[K];type Result1 = GetKeyType&lt;Person, &#x27;name&#x27;&gt;; // stringtype Result2 = GetKeyType&lt;Person, &#x27;age&#x27;&gt;; // numbertype Result3 = GetKeyType&lt;Person, &#x27;name&#x27; | &#x27;age&#x27;&gt;; // string | number K extends keyof T 的写法称为泛型约束，GetKeyType 第二个参数 k 的类型必须包含于 string | number 其他PropertyKeyPropertyKey 是 TS 中的一个内置类型，它表示可以用作对象属性键的类型。它是 string | number | symbol 类型的别名，因为这些类型都可以用作对象属性的键。 PropertyKey 类型常用于泛型约束，以确保泛型类型参数只能是可以用作对象属性键的类型。例如，定义一个泛型类型 Foo&lt;K extends PropertyKey&gt;，其中 K 只能是 string、number 或 symbol 类型。 T[number]12type A = [1, 2, 3]type B = A[number] // 3 | 1 | 2，无序 A[number] 表示获取类型 A 的数字索引签名的类型。由于元组类型具有隐式的数字索引签名，因此 A[number] 的类型为元组中所有元素类型的联合类型 1 | 2 | 3","tags":["TypeScript","泛型"],"categories":["学习笔记","TypeScript"]},{"title":"深入函数：函数重载、this 和 as const","path":"/2023/02/03/typescript/ts-8/","content":"函数重载（overload）重载允许一个函数在接受不同数量或类型的参数时，作出不同的处理 1234567891011121314151617function createDate(n: number): Date;function createDate(year: number, month: number, date: number): Date;// 中间不能写其他代码，函数类型声明后面只能接函数的实现function createDate(a: number, b?: number, c?: number): Date &#123; if (a !== undefined &amp;&amp; b !== undefined &amp;&amp; c !== undefined) &#123; return new Date(a, b, c); &#125; else if (a !== undefined &amp;&amp; b === undefined &amp;&amp; c === undefined) &#123; return new Date(a); &#125; else &#123; throw new Error(&#x27;传参错误&#x27;); &#125;&#125;createDate(1677772800000);createDate(2023, 2, 3); 关于函数重载： 重载的思想来自于 Java 或 C#，因为它们都不支持联合类型 重载是为了使同名函数可以接受不同类型的参数 不是非得使用重载，即使不用函数重载也可以实现上述的功能123456789function createDateFromNumber(n: number): Date &#123; return new Date(n);&#125;function createDateFromYMD(year: number, month: number, date: number): Date &#123; return new Date(year, month, date);&#125;createDateFromNumber(1677772800000);createDateFromYMD(2023, 2, 3); 复杂度守恒，你不可能把复杂度凭空抹除掉，因此你只能选择把复杂度留给自己或者抛给用户。比如上面的例子中，使用函数重载就是把复杂度留给自己；而提供两个函数供用户选择就是把复杂度留给用户。 指定 this 的类型1234567891011121314151617181920type Person = &#123; name: string &#125;;function f(this: Person, n: number) &#123; console.log(this.name + n);&#125;// 1. person.f(1)const p: Person &amp; &#123; f: typeof f &#125; = &#123; name: &#x27;ClariS&#x27;, f &#125;;p.f(1);// 2. f.call(person, 1)const p2: Person = &#123; name: &#x27;ClariS&#x27; &#125;;f.call(p2, 1);// 3. f.apply(person, [1])const p3: Person = &#123; name: &#x27;ClariS&#x27; &#125;;f.apply(p3, [1]);// 4. f.bind(person)(1)const p4: Person = &#123; name: &#x27;ClariS&#x27; &#125;;const newF = f.bind(p4);newF(1);// 或newF.bind(null, 1); 剩余参数1234567function sum(name: string, ...array: number[]) &#123; console.log(name); return array.reduce((result, n) =&gt; result + n, 0);&#125;sum(&#x27;one&#x27;, 1);sum(&#x27;two&#x27;, 1, 2);sum(&#x27;three&#x27;, 1, 2, 3); 注意，剩余参数只能是最后一个参数 展开参数12345678function sum(...array: number[]) &#123; f.apply(null, array); // f(array[0], array[1], array[2], array[3], ...) f(...array);&#125;function f(...array: number[]) &#123; console.log(array);&#125; 常量断言（as const）TS 会区别对待可修改和不可修改的值的类型推断 例如下面的 immutableString 会被推断成单值类型 &#39;ClariS&#39; 而 mutableString 则会被推断成通用的 string 类型 12const immutableString = &#x27;ClariS&#x27;; // &#x27;ClariS&#x27;let mutableString = &#x27;vivy&#x27;; // string 而在一般的对象中，由于对象的属性都具有可修改性，TS 都会对它们「从宽」类型推断，例如下面的 prop 的类型被推断为 string 123const obj = &#123; prop: &#x27;xxx&#x27; // string&#125;; 根本原因在于 TS 会根据一个值在后续的逻辑中是否可能被修改而给出不同的类型推断结果： 对于有可能被修改的值，TS 采用较为宽松的类型推断策略，即把上述 mutableString，obj.props 推断为较为宽泛的 string 类型，这使未来可能出现的赋值具有更大的灵活度 对于不可能被重新赋值的值，TS 采用较为严格的类型推断策略，即把上述 immutableString 推断为单值类型 &#39;ClariS&#39;，这样未来把immutableString 赋值给别的变量时，出现类型检查错误的可能性更小 关于这部分内容，详细可参考文章TypeScript夜点心：类型推断的策略 TS 常量断言 常量断言可以把一个值标记为一个不可篡改的常量，从而让 TS 以最严格的策略来进行类型推断 还是使用上述的例子，给他们分别加上 as const 后类型推断如下 12345let mutableString = &#x27;vivy&#x27; as const; // &#x27;vivy&#x27;const obj = &#123; prop: &#x27;xxx&#x27; as const // &#x27;xxx&#x27;&#125;; 再看看其他的例子 12345const array1 = [1, &#x27;hi&#x27;]; // (string | number)[]array1.push(2); // 不报错const array2 = [1, &#x27;hi&#x27;] as const; // readonly [1, &quot;hi&quot;]array2.push(2); // 报错 从以上例子中可以看出，as const 会把类型推窄，并给类型加上 readonly 关于这部分内容，详细可参考文章TypeScript 夜点心：常量断言 const 与 as const 的区别 as const 中的 const 与我们声明常量时使用的 const 有什么区别呢？ 其实两者无论是语法还是语义，都相当不同： const 常量声明是 ES6 的语法，对 TS 而言，它只能反映该常量本身是不可被重新赋值的，它的子属性仍然可以被修改，故 TS 只会对它们做松散的类型推断 as const 是 TS 的语法，它告诉 TS 它所断言的值以及该值的所有层级的子属性都是不可篡改的，故对每一级子属性都会做最严格的类型推断 more about the function完整示例1234567891011121314type Config = &#123; url: string; method: &#x27;GET&#x27; | &#x27;POST&#x27; | &#x27;PATCH&#x27; | &#x27;DELETE&#x27;; data?: unknown; headers?: unknown;&#125;;function ajax1(&#123; url, method, ...rest &#125;: Config = &#123; method: &#x27;GET&#x27;, url: &#x27;&#x27; &#125;) &#123; console.log(url, method, rest);&#125;function ajax2(&#123; url, method, ...rest &#125; = &#123; method: &#x27;GET&#x27;, url: &#x27;&#x27; &#125; as Config) &#123; console.log(url, method, rest);&#125; 类型 Config 可以写在左边，也可以写在右边 void 返回值类型123456789101112131415161718function f1(): void &#123; return;&#125;function f2(): void &#123; return undefined;&#125;function f3(): void &#123;&#125;function f4(): void &#123; return null; // 报错：Type &#x27;null&#x27; is not assignable to type &#x27;void&#x27;&#125;type F5 = () =&gt; void;const f5: F5 = () =&gt; &#123; return;&#125;;","tags":["TypeScript","as const","函数重载"],"categories":["学习笔记","TypeScript"]},{"title":"深入函数：声明、参数、返回值","path":"/2023/02/01/typescript/ts-7/","content":"深入对象语法描述对象的属性使用接口描述对象 12345678type Person = &#123; name: string&#125;// 或者interface Person &#123; name: string&#125; Person 的子集为 12345678910type Children = | &#123; name: string, age: string &#125; | &#123; name: string, age: number &#125; | &#123; name: string, age: boolean &#125; | &#123; name: string, age: null &#125; | &#123; name: string, age: undefined &#125; | &#123; name: string, age: object &#125; | &#123; name: string, gender: string &#125; | &#123; name: string, gender: number &#125;// 以下省略一万行 索引签名（Index Signature）12345678type Hash = &#123; [k: string]: unknown length: number&#125;type List = &#123; [k: number]: unknown length: number&#125; 映射类型（Mapped Type）123456type Hash = &#123; [k in string]: unknown&#125;type List = &#123; [k in number]: unknown&#125; 映射类型多用于泛型 123type Readonly&lt;T&gt; = &#123; readonly [K in keyof T]: T[K];&#125;; 需要注意的是，如果使用了映射类型，对象中就不能再有其他属性了，这点与索引签名有所不同 12345type Hash = &#123; [k in string]: unknown length: number // ^-- A mapped type may not declare properties or methods.&#125; 可选属性可选属性的含义是该属性可以不存在 12345interface InputProps &#123; defaultValue?: string; value?: boolean; onChange?: () =&gt; void;&#125; value?: boolean 可近似的理解成 value: boolean | undefined，但是在声明对象属性时，value? 可以不写，而 value 必须写 只读属性有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性 1234567891011interface User &#123; readonly id: number; readonly name: string; readonly scores: number[]; age?: number;&#125;const u: User = &#123; id: 1, name: &#x27;ClariS&#x27;, scores: [87, 65],&#125;; 使用 readonly 定义的属性初始化后不能被重新赋值 1234u.id = 2;// ^-- Cannot assign to &#x27;id&#x27; because it is a read-only property.tsu.scores = [100, 65]// ^-- Cannot assign to &#x27;scores&#x27; because it is a read-only property.ts 但是并没有对 scores 内部的属性做只读约束（只读约束只在第一层） 12u.scores[0] = 100;// 不报错 深入函数语法对象的语法全都适用于函数 1234567type F = &#123; (a: number, b: number): number; readonly count?: number[];&#125;;const fn: F = (x, y) =&gt; x + y;fn.count[0] = 1; 声明函数的四种方式先写类型再赋值12type F1 = (a: number, b: number) =&gt; number;const f1: F1 = (a, b) =&gt; a + b; 箭头函数1234const f2 = (a: number, b: number): number =&gt; &#123; return a + b;&#125;;type F2 = typeof f2; 普通函数1234function f3(this: unknown, a: number, b: number): number &#123; return a + b;&#125;type F3 = typeof f3; 匿名普通函数1234const f4 = function (this: unknown, a: number, b: number): number &#123; return a + b;&#125;;type F4 = typeof f4; 构造函数12const f5 = new Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;return a + b&#x27;);type F5 = typeof f5; 几乎没人会这么写吧 类型谓词之前在联合类型中讲过，可以使用类型谓词 is 来收窄类型，当时只简单提了一下不推荐使用箭头函数，这里说一下为什么 123456789101112type Person = &#123; name: string &#125;type Animal = &#123;&#125;function isPerson(x: Person | Animal): x is Person &#123; return &#x27;name&#x27; in x&#125;function fn(a: Person | Animal) &#123; if (isPerson(a)) &#123; a // Person &#125;&#125; 可以使用箭头函数实现 isPerson 1const isPerson = (x: Person | Animal): x is Person =&gt; &#x27;name&#x27; in x 但需要注意的是，如果使用的是箭头函数，不能先写类型再赋值 123type A = (x: Person | Animal) =&gt; x is Personconst isPerson: A = x =&gt; &#x27;name&#x27; in x// ^--- Type &#x27;(x: Person | Animal) =&gt; boolean&#x27; is not assignable to type &#x27;A&#x27; 在右边加上 x is Person 就不报错了 12type A = (x: Person | Animal) =&gt; x is Personconst isPerson: A = (x): x is Person =&gt; &#x27;name&#x27; in x 参数相关语法可选参数123456789function addEventListener(eventType: string, fn: unknown, useCapture?: boolean) &#123; if (useCapture === undefined) &#123; useCapture = false &#125; // 浏览器实现 console.log(eventType, fn, useCapture)&#125;addEventListener(&#x27;click&#x27;, () =&gt; 1) 参数默认值123456function addEventListener(eventType: string, fn: unknown, useCapture = false) &#123; // 浏览器实现 console.log(eventType, fn, useCapture)&#125;addEventListener(&#x27;click&#x27;, () =&gt; 1) 参数也可以是函数12345678910111213function addEventListener( eventType: string, fn: (this: HTMLElement, e: Event) =&gt; void, useCapture = false) &#123; // 浏览器实现，这里只提供伪代码 const element = &#123;&#125; as HTMLElement; const event = &#123;&#125; as Event; fn.call(element, event); console.log(eventType, fn, useCapture);&#125;addEventListener(&#x27;click&#x27;, () =&gt; 1); 返回值也可以是函数123456const add = (a: number, b: number) =&gt; a + btype CreateAdd = (x: number) =&gt; (y: number) =&gt; numberconst createAdd: CreateAdd = a =&gt; b =&gt; a + badd(6, 14)createAdd(6)(14)","tags":["TypeScript","映射类型","索引签名"],"categories":["学习笔记","TypeScript"]},{"title":"类型兼容与赋值","path":"/2023/01/30/typescript/ts-6/","content":"为什么要有类型兼容因为实际工作中，往往无法做到类型一致 比如在上面的 JS 代码中，假设 runTask 函数的参数只接受具有 a、b、c 这 3 个 key 的对象，但在一般情况下，即使我们多传一个 d，也不会报错 你有的，我都有，则我能代替你；y 有的，x 都有，则 x 兼容 y 简单类型的兼容类型小的兼容类型大的 注意：图中的大小圆应当是包含关系，即小圆应该在大圆内部，此处为了展示清晰将小圆挪到了外部，后面的图示亦如此 集合 hi 小于集合 A，因此将 hi 赋值给 a 不报错 普通对象的兼容属性多的兼容属性少的 对象属性越多，限制越多，表示的集合范围越小，所以其实还是类型小的兼容类型大的 注意：对象兼容的前提是必须得存在共同的属性，此处两个对象共同的属性是 name 和 age 兼容的情况下，作为参数也不报错 123456789type Person = &#123; name: string; age: number &#125;let user = &#123; name: &#x27;ClariS&#x27;, age: 18, id: 1, email: &#x27;xxx@yyy.com&#x27; &#125;let p: Person = user // 不报错const f1 = (p: Person) =&gt; &#123; console.log(p)&#125;f1(user) // 不报错 接口的兼容子接口兼容父接口 函数的兼容函数的兼容比较复杂，需要考虑参数和返回值 参数个数不同存在相同类型的参数的函数，参数少的兼容参数多的 如何理解上图中的兼容关系？（图中绿色箭头代表可以兼容，红色箭头表示不能兼容） 如何理解上图中的代码？（图中绿色箭头代表可以兼容，红色箭头表示不能兼容）主要看划线的右边参数的部分：从上往下看，箭头全绿（a 和 b 都是 number）从下往上看，存在红色的箭头（参数 s 没有可以兼容的参数）因此 接受一个参数的函数 兼容 接受两个参数的函数，反过来则不行 为什么容忍参数变少呢？从下例中可以窥探一二 在 JS 中，少写参数是很常见的事情 参数类型不同对参数要求少的兼容对参数要求多的 和参数的兼容关系正好相反 从前面的例子我们知道，MyMouseEvent 是兼容 MyEvent 的，这里函数的兼容关系就正好反过来了。 返回值不同不考虑参数类型的情况下，函数的兼容关系和返回值的兼容关系保持一致 思考：如果函数的参数和返回值同时存在且兼容关系相反呢？ 实际工作中的函数12345678910111213141516171819202122232425interface Event &#123; timestamp: number;&#125;interface MyMouseEvent extends Event &#123; x: number; y: number;&#125;function listenEvent(eventType: string, handler: (n: Event) =&gt; void) &#123; /* ... */&#125;// 我们希望这样用，但会报错listenEvent(&quot;click&quot;, (e: MyMouseEvent) =&gt; console.log(e.x + &quot;,&quot; + e.y));// 因此只能这样用listenEvent(&quot;click&quot;, (e: Event) =&gt; console.log((e as MyMouseEvent).x + &quot;,&quot; + (e as MyMouseEvent).y));// 还可以这么用listenEvent(&quot;click&quot;, ((e: MyMouseEvent) =&gt; console.log(e.x + &quot;,&quot; + e.y)) as ( e: Event) =&gt; void);// 这个就太离谱了，也会报错listenEvent(&quot;click&quot;, (e: number) =&gt; console.log(e)); 在不关闭 TS 严格检查的情况下，可以通过设置 &quot;strictFunctionTypes&quot;: false 来避免函数报错 12345678// tsconfig.json&#123; &quot;compilerOptions&quot;: &#123; &quot;strict&quot;: true, &quot;strictFunctionTypes&quot;: false, ... &#125;&#125; 设置 strictFunctionTypes: false 后 特殊类型的兼容顶类型（Top Type）与底类型（Bottom Type）在 TS 中，顶类型（Top Type）表示可以接受任何值的类型，而底类型（Bottom Type）表示不可能有任何值的类型。 顶类型通常称为通用超类型，因为它是系统中所有其他类型的超类型。TS 提供了两种顶类型：any 和 unknown。any 类型表示可以接受任何值，但它不提供任何类型检查。unknown 类型也可以接受任何值，但在使用之前必须先进行类型检查。 底类型通常称为通用子类型，因为它通常是系统中所有其他类型的子类型。TS 提供了一种底类型：never。never 类型表示不可能有任何值，它用于表示永远不会返回值的函数或抛出异常的函数的返回类型。 123456789// Top Type 示例let topType: unknown;topType = 1; // 可以赋任何值topType = &#x27;hello&#x27;;// Bottom Type 示例function throwError(): never &#123; throw new Error(&#x27;Error&#x27;);&#125;","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TS 中的类型运算：交叉类型","path":"/2023/01/17/typescript/ts-5/","content":"交叉类型（交集）英文全称：intersection types 12type A = string &amp; number;// ^-- never 交叉类型一般多用于对象，而不用于简单类型 123456type 有左手的人 = &#123; left: string &#125;const b = &#123; left: &#x27;yse&#x27;, right: &#x27;yes&#x27; &#125;const a1: 有左手的人 = b // 不报错const a2: 有左手的人 = &#123; left: &#x27;yse&#x27;, right: &#x27;yes&#x27; &#125; // 报错 可用于接口求交集 1234567interface Colorful &#123; color: string;&#125;interface Circle &#123; radius: number;&#125;type ColorfulCircle = Colorful &amp; Circle; 可用于模拟继承 1234567891011121314type Person = &#123; name: string; age: number;&#125;;type User = Person &amp; &#123; id: number; email: string;&#125;;const u: User = &#123; id: 1, name: &#x27;ClariS&#x27;, age: 18, email: &#x27;xxx@yyy.com&#x27;&#125;; 交叉类型的特殊情况123456789101112131415type Person = &#123; name: string; age: number; id: string;&#125;;type User = Person &amp; &#123; id: number; email: string;&#125;;const u: User = &#123; id: 1 as never, // 此处 id 的类型为 never name: &#x27;ClariS&#x27;, age: 18, email: &#x27;xxx@yyy.com&#x27;,&#125;; 当把上面 id 的类型从一个比较大的类型，变为比较小的类型时，整个 User 的类型都为 never 12345678910111213141516171819type Person = &#123; name: string; age: number; id: &#x27;A&#x27;;&#125;;type User = Person &amp; &#123; id: &#x27;B&#x27;; email: string;&#125;;const u: User = &#123; // User = never id: 1, name: &#x27;ClariS&#x27;, age: 18, email: &#x27;xxx@yyy.com&#x27;,&#125;;type A = &#123; kind: &#x27;A&#x27;; name: string &#125;;type B = &#123; kind: &#x27;B&#x27;; age: number &#125; &amp; A;// ^-- never 上面的例子中，当对象属性发生冲突时，type 只会把类型变为 never，但类型并不报错，只在使用时报错；而 interface 会直接报错 12345678910interface Person &#123; name: string; age: number; id: string;&#125;interface User extends Person &#123; // ^-- Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27; id: number; email: string;&#125; 函数的交集会得到一个参数的并集 123456789101112type A = &#123; method: (a: number) =&gt; void;&#125;;type B = &#123; method: (a: string) =&gt; void;&#125; &amp; A;const b: B = &#123; method(a) &#123; a; // number | string &#125;&#125;; 总结：交叉类型常用于有交集的类型 A、B，如果 A、B 无交集，可能得到 never，也可能只是属性为 never","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TS 中的类型运算：联合类型","path":"/2023/01/12/typescript/ts-4/","content":"TS &#x3D; JS + 类型系统 JS 可以对值进行加减运算，如果把 TS 的类型系统当作一门语言，TS 也同样可以对类型进行各种运算 联合类型（并集）英文全称：union types type A = &#123; name: string &#125; 表示 name 为 string 的所有对象但不要错误地认为这些对象只有 name 这一个 key比如对象 &#123; name: &#39;ClariS&#39;; age: 18 &#125; 也是属于 A 类型的即 A 类型的对象可以有 age，也可以没有 age同理，type = &#123; age: number &#125; 表示 age 为 number 的对象，这些对象的 name 可以为空，也可以不为空 如何使用联合类型？12345const f1 = (a: number | string) =&gt; &#123; &#x27;既不能把 a 当作 number&#x27; &#x27;也不能把 a 当做 string&#x27; &#x27;那么，怎么使用 a 变量呢？&#x27;&#125; 如果不拆开类型，就只能使用 number 和 string 共同拥有的方法或属性，比如 toString() 因此要使用联合类型，就得先区分类型，也就是进行类型收窄(Narrowing) 如何进行类型收窄？使用 typeof123456789const f1 = (a: number | string) =&gt; &#123; if (typeof a === &#x27;number&#x27;) &#123; a.toFixed(2); &#125; else if (typeof a === &#x27;string&#x27;) &#123; parseFloat(a).toFixed(2); &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; typeof 的局限性：无法区分数组、日期、普通对象以及 null（返回值都是 &quot;object&quot;） 使用 instanceof123456789const f1 = (a: Array&lt;Date&gt; | Date) =&gt; &#123; if (a instanceof Date) &#123; a.toISOString(); &#125; else if (a instanceof Array) &#123; a[0].toISOString(); &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; instanceof 的局限性： 不支持基础类型，string、number、bigint、boolean、symbol、undefined 不支持 TS 独有的类型123456789type Person = &#123; name: string &#125;;const f1 = (a: Person | Person[]) =&gt; &#123; if (a instanceof Person) &#123; // ^--- 报错：type 不能用作 value &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; 使用 in 操作符123456789type Person = &#123; name: string &#125;;const f1 = (a: Person | Person[]) =&gt; &#123; if (&#x27;name&#x27; in a) &#123; a; // Person &#125; else &#123; a; // Person[] &#125;&#125;; in 操作符的局限性：只适用于部分对象 比如当判断的两个对象存在相同的 key （存在相同 key，其中一个对象的 key 可能不存在），或不为键值对形式的对象（比如日期、正则、函数等）时，则无法使用 in 操作符来收窄类型 使用 JS 中判断类型的函数123456789const f1 = (a: string | string[]) =&gt; &#123; if (Array.isArray(a)) &#123; a.join(&#x27; &#x27;).toString(); &#125; else if (typeof a === &#x27;string&#x27;) &#123; parseFloat(a).toFixed(2); &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; 使用逻辑12345678910111213141516171819202122const f1 = (a?: string[]) =&gt; &#123; if (a) &#123; a; // string[] &#125; else &#123; a; // undefined &#125;&#125;;const f2 = (a: string | number) =&gt; &#123; a = 1; a; // number&#125;;const f3 = (x: string | number, y: string | boolean) =&gt; &#123; if (x === y) &#123; x; // string y; // string &#125; else &#123; x; // string | number y; // string | number &#125;&#125;; 使用类型谓词 is上述所有的类型收窄方法都是通过 JavaScript 来实现的，有没有区分类型的万全之法？ 12345678910111213141516type Rect = &#123; height: number; width: number &#125;;type Circle = &#123; center: [number, number]; radius: number &#125;;// 推荐使用普通函数实现 isRect，而不使用箭头函数function isRect(x: Rect | Circle): x is Rect &#123; return &#x27;height&#x27; in x &amp;&amp; &#x27;width&#x27; in x;&#125;const f1 = (a: Rect | Circle) =&gt; &#123; if (isRect(a)) &#123; // `isRect(a)` 判断 a 是不是 Rect a; // Rect &#125; else &#123; a; // Circle &#125;&#125;; 优点：支持所有 TS 类型缺点：需要自己实现，挺麻烦的 有没有更简单的办法？ 可辨别联合12345678910111213interface Circle &#123; kind: &quot;circle&quot;; radius: number; &#125;interface Square &#123; kind: &quot;square&quot;; sideLength: number; &#125;type Shape = Circle | Squareconst f1 = (shape: Shape) =&gt; &#123; if (shape.kind === &#x27;circle&#x27;) &#123; shape // Circle &#125; else if (shape.kind === &#x27;square&#x27;) &#123; shape // Square &#125; else &#123; shape // never &#125;&#125; 让复杂类型的收窄变成简单类型的对比 对于类型 T = A | B | C | D | ...，有以下要求： A、B、C、D... 有相同属性 kind 或其他 kind 的类型是简单类型 各类型中的 kind 可区分 则称 T 为可辨别联合 一句话总结：具有同名、可辨别的简单类型的 key 的联合类型，称为可辨别联合 使用断言可以使用 as 进行强制的类型收缩 1234567interface Circle &#123; kind: &quot;circle&quot;; radius: number; &#125;interface Square &#123; kind: &quot;square&quot;; sideLength: number; &#125;type Shape = Circle | Squareconst f1 = (shape: Shape) =&gt; &#123; (shape as Circle).radius = 4&#125; any 等于所有类型的联合吗？这里直接给出结论：any 不等于所有类型的联合 注意：这里的所有类型不包括 never unknown any void 用反证法可以证明： 只要类型发生了联合，就只能使用它们共同拥有的属性或方法（想要使用各自的方法就必须做类型收窄） 但是使用 any 之后，不做类型收窄可以使用所有类型的方法 说明 any 不是所有类型的联合 1234567891011const f1 = (a: string | number) =&gt; &#123; a.toString(); a.toFixed(); // 报错 a.split(); // 报错&#125;;const f2 = (a: any) =&gt; &#123; a.toString(); a.toFixed(); a.split();&#125;; 且 ts 的绝大部分规则对 any 不生效，但有一种特殊情况，any 无法赋值给 never 那什么等于所有类型的联合呢？ 1234567891011121314151617const f1 = (a: unknown) =&gt; &#123; if (a instanceof Date) &#123; a; // Date &#125;&#125;;type Rect = &#123; height: number; width: number &#125;;type Circle = &#123; center: [number, number]; radius: number &#125;;function isRect(x: Rect | Circle): x is Rect &#123; return &#x27;height&#x27; in x &amp;&amp; &#x27;width&#x27; in x;&#125;const f2 = (a: unknown) =&gt; &#123; if (isRect(a)) &#123; a; // Rect &#125;&#125;; 可以看出，unknown 是可以收窄到任何类型的，因此，unknown 就是所有类型的联合","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TypeScript 中的类型（下）","path":"/2022/12/29/typescript/ts-3/","content":"何时使用 enum 实例一：用 A.todo 将数字映射成一个有意义的语法 实例二：可以用于表示权限 以上代码中，Manage = Read | Write | Delete 是 JS 中的二进制操作（二进制或运算符），0b 在 JS 中表示二进制 何时用 enum 会显得很呆？ 如上所示，将 &#39;apple&#39; 映射为 Fruit.apple 完全是多此一举，还是别再用 enum 来映射字符串了吧ヾ(-_-;) 只推荐用 enum 对数字做映射，除此之外都不推荐使用 enum 何时使用 typeTS 中的 Type 叫作类型别名，Type Aliases，其实就是给其他类型取个名字，示例如下： 1234567891011type Name = string;type FalseLike = &#x27;&#x27; | 0 | false | null | undefined;type Point = &#123; x: number; y: number &#125;;type Points = Point[];type Line = [Point, Point];type Circle = &#123; center: Point; radius: number &#125;;type Fn = (a: number, b: number) =&gt; number;type FnWithProps = &#123; (a: number, b: number): number; prop1: number;&#125;; 如何体现出 type 只是一个别名？ 12type X = &#123; x: number &#125;type A = X 以上 TS 代码中 A 的类型是？由于 type 只是一个别名，并不是声明了一个真正的类型，此处 A 的类型为 { x: number } 如何理解 type FalseLike = &#39;&#39; | 0 | false | null | undefined？ 上面的五个值其实都是类型，类型可以理解为集合，因此可以看作五个集合并在一起，每个集合中只包含一个值；另外，不支持 NaN 作为类型，因为 NaN 表示的是一个值而不是类型 带有属性的函数的声明方式 12345678type FnWithProps = &#123; (a: number, b: number): number; props: string;&#125;;const fn: FnWithProps = (x, y) =&gt; x * y;fn.props = &#x27;hello&#x27;; 多用于 React 中 何时使用 interface声明接口，用于描述对象的属性 declare the shapes of objects 12345interface Data &#123; [k: string]: string; &#125;interface Point &#123; x: number; y: number; &#125;interface Points extends Array&lt;Point&gt; &#123;&#125;interface Fn &#123; (x: number, y: number): number; &#125;interface Date2 extends Date &#123;&#125; type 如何实现继承？ 123456interface X &#123; age: number; &#125;type Al = Array&lt;string&gt; &amp; &#123; name: string; &#125; &amp; X;// A1几乎等价于A2interface A2 extends Array&lt;string&gt;, X &#123; name: string; &#125; type 和 interface 的区别区别一interface 只能描述对象，而 type 能描述所有数据类型 区别二type 并不会创建一个新的类型，只是创建了一个类型别名；而 interface 则是类型声明，会创建一个新的类型 12345type A = string;type B = A; // B 的类型是 stringinterface D extends Date &#123;&#125;type E = D; // E 的类型是 D 区别三type 不可重新赋值，因此不能存在同名的 type；而 interface 可以声明同名的类型，同名的 interface 会自动合并 123456type A = string; // 报错 Duplicate identifier &#x27;A&#x27;type A = number; // 报错 Duplicate identifier &#x27;A&#x27;interface X &#123; name: string; &#125;interface X &#123; age: number; &#125;const x: X = &#123; name: &#x27;ClariS&#x27;, age: 18 &#125;; // X 为 &#123; name: string; age: number; &#125; 使用 type 无法进行类型扩展，因此 对外 API 尽量用 interface，方便用户进行类型扩展；对内 API 尽量用 type，防止代码分散 例如，当你设计一个库或框架的公共 API 时，可以使用接口来定义输入和输出的数据结构，以提供明确的类型信息给用户，并允许用户按照自己的需求扩展接口。 而当你在代码内部定义一些仅在局部范围内使用的类型时，使用类型别名可以让代码更加集中和易于维护。它可以将类型定义与具体的实现逻辑分离开来，使代码更加模块化。 下面是一个扩展 interface 的实例： 扩展 axios 1234567import &#123; AxiosRequestConfig &#125; from &#x27;axios&#x27;;declare module &#x27;axios&#x27; &#123; export interface AxiosRequestConfig &#123; _autoLoading?: boolean; _mock?: string; &#125;&#125; 扩展 string 12345declare global &#123; interface String &#123; padZero(length: number): string; &#125;&#125; 区别四interface 使用 extends 来实现继承，而 type 只能用 &amp; 来模拟继承 123456789interface A &#123; a: string&#125;interface B extends A &#123; b: string&#125;type C = &#123; c: string &#125; &amp; A void12345678910111213141516171819type Fn = () =&gt; void;const fn: Fn = () =&gt; &#123; return &#x27;xxx&#x27;; // 不报错&#125;;const x = fn();console.log(x.toString()); // 报错：Property &#x27;toString&#x27; does not exist on type &#x27;void&#x27;.console.log((x as any).toString()); // 不报错function fn1(a: number): void &#123; return &#x27;xxx&#x27;; // 报错：Type &#x27;string&#x27; is not assignable to type &#x27;void&#x27;.&#125;const fn2 = (a: number): void =&gt; &#123; return &#x27;xxx&#x27;; // 报错：Type &#x27;string&#x27; is not assignable to type &#x27;void&#x27;.&#125;;","tags":["TypeScript","enum"],"categories":["学习笔记","TypeScript"]},{"title":"TypeScript 中的类型（上）","path":"/2022/12/28/typescript/ts-2/","content":"JS&#x2F;TS 中有哪些数据类型 用集合来理解 TS 数据类型 number 可看做 1、1.1、2、2.3 等所有数字值组成的集合string 可看做 a、b、ab、c、abc 等所有字符串值组成的集合boolean 可看做 true 和 false 这两个值组成的集合 JS 中的 Number、String、Boolean 只用于包装对象，一般不会用到它们；同样地在 TS 中也不会用到它们。 TS 中一般不会用 Object 来描述对象的类型，因为 Object 所表示的类型范围太大了 如何用 TS 来描述对象 用 class&#x2F;constructor 描述 用 type&#x2F;interface 描述 描述普通对象由于 object&#x2F;Object 太不精确，所以一般使用索引签名或Record 泛型来描述普通对象 使用索引签名 思考题：key 的类型可以不是 string 吗？经测试，k 的类型只能为 number、string、symbol 这三种 使用 Record 使用具体的字段1234type A = &#123; name: string; age: number;&#125;; 描述数组对象由于 Array 太不精确，所以一般用 Array&lt;?&gt; 或 string[] 或 [string, number] 来描述数组 思考题 12type A = [1, 2, 3]const a: A = ?????? 以上 TS 代码中 a 的值是？当于只有一个元素的集合，因此 a 的值只能是 [1, 2, 3] 描述函数对象由于 Function 太不精确，所以一般用 () =&gt; ? 来描述函数 1234567891011121314type FnA = (a: number, b: number) =&gt; number;type FnReturnVoid = (s: string) =&gt; void;type FnReturnUndefined = (s: string) =&gt; undefined;const v: FnReturnVoid = (s: string) =&gt; &#123; console.log(s);&#125;;const u: FnReturnUndefined = (s: string) =&gt; &#123; console.log(s); return undefined;&#125;; 带有 this 的函数声明 123456789101112type Person = &#123;name: string, age: number, sayHi: FnWithThis&#125;type FnWithThis = (this: Person, name: string) =&gt; voidconst sayHi: FnWithThis = function(name) &#123; // 此处不能使用箭头函数，因为箭头函数内不存在 this console.log(&quot;hi&quot;, this.name)&#125;const x: Person = &#123;name: &quot;vivy&quot;, age: 18, sayHi&#125;// 如果函数声明中有 this，那么调用函数时必须显示地传递这个 thisx.sayHi(&quot;Citrus&quot;)sayHi.call(x, &quot;Citrus&quot;) 描述其他对象直接用 class（构造函数） 描述即可 12345678910111213const d: Date = new Date();const r: RegExp = /ab+c/;const m: Map&lt;string, number&gt; = new Map();m.set(&#x27;xxx&#x27;, 1);const wm: WeakMap&lt;&#123; name: string &#125;, number&gt; = new WeakMap();const s: Set&lt;&#123; name: string &#125;&gt; = new Set();s.add(&#123; name: &#x27;ClariS&#x27; &#125;);const ws: WeakSet&lt;string[]&gt; = new WeakSet(); any、unknown、never 是什么从集合的角度理解：any 是全集，never 是空集，unknown 是未知集 TS 的绝大部分规则对 any 类型不生效（TS 不报错） 可对 unknown 进行断言，适用于值是从外部获取的，没办法提前知道类型的情况；比如当使用 ajax 获取数据时，后台返回的数据格式不确定，此时可将接口响应的数据类型可定义为 unknown，然后再对其进行断言 12const a: unknown = await ajax.get(&#x27;/api/users&#x27;)const b = a as number never 一般不会用来声明类型，而是用来进行类型推断的 12345678910111213type A = string | number | boolean;const a: A = &#x27;hello&#x27; as any;if (typeof a === &#x27;string&#x27;) &#123; a.split(&#x27;&#x27;);&#125; else if (typeof a === &#x27;number&#x27;) &#123; a.toFixed(2);&#125; else if (typeof a === &#x27;boolean&#x27;) &#123; a.valueOf();&#125; else &#123; a.toString(); // 报错：Property &#x27;toString&#x27; does not exist on type &#x27;never&#x27;&#125; JS 类型与 TS 类型的区别我是这么理解的： JS 这门语言其实并没有提供类型相关的关键字（如小写的 number、string、boolean），只是提供了typeof让我们获取变量的类型，所以我认为 JS 对类型非常不重视。 而 TS 则将 JS 中的类型提升到很高的位置，高到如果你把类型写错了代码就不能通过编译。因此这两门语言中的类型其实没有可比性，只是看起来有重叠部分而已。如果一定要比较，我会这么说： 粒度不同：在 JS 中的类型 number 不可再细分，而 TS 中的 number 可以看做 1、1.1、2、2.3 等无数个小类型的联合 可变性不同：JS 中的变量类型是可变的，一个 number 随时可以变成一个 string；TS 中除了 any，其他类型要么是不可变的，要么就算可变也是有限制的","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TypeScript 的运行与调试","path":"/2022/09/07/typescript/ts-1/","content":"如何擦除类型 如何运行 TypeScript在线编辑 TypeScript Playground（缺点是 URL 太长） playcode stackblitz codesandbox 本地编辑 + 浏览器使用 vite 和 chrome 本地编辑 + Node ts-node swc-node @esbuild-kit&#x2F;esm-loader esno 如何调试 TypeScript鼠标悬浮上去看报错提示即可 学习资料推荐 编程与类型系统 TypeScript 编程 类型和程序设计语言","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"DNS 与 TCP","path":"/2021/08/20/dns-and-tcp/","content":"一图概览image.png DNS &amp; hostsDNS，全称：Domain Name System，中文：域名系统 域名系统本身的原理是比较复杂的，但域名系统的功能很简单，就是输入一个域名，输出一个 IP，这里我们只对 DNS 做简单讨论 举例说明： 在浏览器输入 baidu.com 这个地址 浏览器需要知道你访问的这个地址对应的 IP 是多少，于是浏览器就会去问操作系统 如果操作系统也不知道，就会去问电信、移动、联通这样的网络运行商（以下简称 ISP） 当你付费之后，网络运营商就会告诉你 baidu.com 这个地址对应的 IP 是多少（假设这里 baidu.com 对应的 IP 是 1.2.3.4），然后将 IP 返回给你 浏览器获取到 baidu.com 对应的 IP 之后，就会与 1.2.3.4 这个 IP 建立 TCP 连接 细化过程： 在浏览器输入 baidu.com 这个地址的时候，浏览器首先会去检查自身是否有缓存，如果发现之前访问过 baidu.com ，那么浏览器就会直接将上一次的 IP 进行返回 如果浏览器没有缓存，就回去询问操作系统，然后操作系统首先也是会检查自身是否有缓存，如果没有就会去询问 ISP（网络运行商） 平时我们修改 hosts 这个文件，其实就是在手动给操作系统设置缓存，比如我们在 hosts 中写入baidu.com 2.3.4.5，以后每次访问 baidu.com 这个地址的时候就不会再去询问 ISP 了，直接会通过 hosts 中的设置去访问 2.3.4.5 这个 IP TCP 三次握手TCP 全称：Transmission Control Protocol，即传输控制协议 image.png 假设 A 是浏览器，B 是服务器 A 首先会向 B 发送一个叫做SYN(x)（假设这里 x &#x3D; 100）的信息 SYN 是 synchronize(同步) 的缩写，同步不是指「同步异步」中的同步，而是「同步信息」中的同步；这里的 x 一般是一个数字编号，且 x 和 y 一般都是从 0 开始的，这里我们对 x 和 y 的意义不做讨论，有兴趣的请自行研究 B 收到 A 发来的同步信息后，就会返回ACK(x+1)（101） SYN(y)（这里假设 y &#x3D; 200） ACK 是 acknowledge(知道) 的缩写 然后 A 会回复消息 ACK(y+1)（201）给 B 从以上过程中能够确保以下几件事： A 可以向 B 发送信息 B 能收到 A 发送的信息 B 也可以向 A 发送信息 A 也能收到 B 发送的信息 三次握手成功后就开始建立 TCP 连接了，建立连接后就可以开始传输内容了（一般是 HTTP 内容，也可以是其他内容，且传输的过程也可以是双向的，并非一定是单向的），HTTP 内容传输结束后，就会「关闭」 TCP 四次挥手image.png 上述内容传输完成后，A 会发送一个FIN(x) 注意：不一定是 A 先发送 FIN，也可以是 B 先发送 B 先回复ACK(x+1) 注意：关闭时的 x 和 y 一般都不是 0 然后再回复FIN(y) 步骤 2 和步骤 3 中间可能会夹杂着其他内容 A 回复ACK(y+1) 最后，A 和 B 各自关闭自己的 TCP 连接 一些 Q &amp; A为什么需要关闭 TCP 连接？因为一直保持连接会浪费内存和 CPU TCP 和 UDP 的区别是什么？ 八股文，面试必背 TCP 面向连接有状态，UDP 无状态 TCP 可靠（不丢失不重复），UDP 不可靠 TCP 传输效率较低，UDP 较高 为什么 TCP 的三次握手不能精简为两次？为了确保客户端（A端）能接收到服务端（B端）的数据（只有两次的话，无法判断 A 是否能接收到 B 的数据） 为什么 TCP 的四次挥手不能将中间两步合并成一步？因为两步中间（指发送ACK(x+1)和FIN(y)之间）往往会有其他数据需要发送，需要等其他数据发送完成之后，再发送FIN(y)","tags":["DNS","TCP"],"categories":["学习笔记"]},{"title":"浅析 Promise、Async/Await","path":"/2021/08/17/promise-async-await/","content":"Promise基本用法Promise 的简单封装与使用 1234567891011// 封装function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(Math.floor(Math.random() * 6) + 1) &#125;, 3000) &#125;)&#125;// 使用摇色子().then(success1, failed1).then(success2, failed2) Ma Mi 任务模型 Ma 指 MacroTask(宏任务)，Mi 指 MicroTask(微任务) 先 Ma 再 Mi，即先执行宏任务再执行微任务 JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务 其实最初 JS 只存在一个任务队列，为了让 Promise 回调更早执行，强行又插入了一个异步的任务队列，用来存放 Mi 任务 宏任务：setTimeout()、setInterval()、 setImmediate()、 I&#x2F;O、UI渲染（常见的定时器，用户交互事件等等） 微任务：Promise、process.nextTick、Object.observe、MutationObserver Promise 的其他 APIPromise.resolve(result): 制造一个成功（或失败）制造成功 123456789101112function 摇色子() &#123; return Promise.resolve(4)&#125;// 等价于function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(4) &#125;)&#125;摇色子().then(n =&gt; console.log(n)) // 4 制造失败 123456function 摇色子() &#123; // 此处 Promise.resolve 接收的是一个失败的 Promise 实例（状态为 reject） return Promise.resolve(new Promise((resolve, reject) =&gt; reject()))&#125;摇色子().then(n =&gt; console.log(n)) // 1 Uncaught (in promise) undefined 关于 Promise.resolve 接收参数的问题，ECMAScript 6 入门里其实说得很清楚 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例；如果参数是一个原始值，或者没有参数，Promise.resolve都会直接返回一个resolved状态的 Promise 对象。 Promise.reject(reason): 制造一个失败12345Promise.reject(&#x27;我错了&#x27;)// 等价于new Promise((resolve, reject) =&gt; reject(&#x27;我错了&#x27;))Promise.reject(&#x27;我错了&#x27;).then(null, reason =&gt; console.log(reason)) // 我错了 Promise.all(数组): 等待全部成功，或者有一个失败全部成功，将所有成功 promise 结果组成的数组返回 12Promise.all([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]) .then(values =&gt; console.log(values)) // [1, 2, 3] 只要有一个失败，就结束，返回最先被 reject 失败状态的值 12Promise.all([Promise.reject(1), Promise.resolve(2), Promise.resolve(3)]) .then(values =&gt; console.log(values)) // Uncaught (in promise) 1 Promse.all 在需要对多个异步进行处理时往往非常有用； 不过在某些特殊情况下，直接使用Promse.all就显得不那么方便了 举个例子，比如现在有 3 个请求，request1, request2 和 request3，我们需要对这 3 个请求进行统一处理，并且不管请求成功还是失败，都需要拿到所有的响应结果，如果这时候使用Promise.all([request1, request2, request3])的话，request1 请求失败了，后面的两个请求 request2, request3 就都不会执行了（这里实际上是 request1 在 rejected 之后，被 Promise.all([]).catch 给捕获了 ）。 如何解决 Promise.all() 在第一个 Promise 失败就会中断的问题？ 利用 .then() 后会返回一个状态为 resolved 的 Promise（即会自动包装成一个已resolved的promise），从而避免被 Promise.all([]).catch 捕获 123456789101112131415161718192021222324// 3 个请求const request1 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;第 1 个请求失败&#x27;) &#125;, 1000)&#125;)const request2 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;第 2 个请求失败&#x27;) &#125;, 2000)&#125;)const request3 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;第 3 个请求成功&#x27;) &#125;, 3000)&#125;)Promise.all([ request1().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;)), request2().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;)), request3().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;))]).then(result =&gt; console.log(result)) 可以把对每个请求的.then操作封装一下 123456789101112const x = promiseList =&gt; promiseList.map(promise =&gt; promise.then(value =&gt; (&#123; status: &#x27;ok&#x27;, value&#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason&#125;)))const xxx = promiseList =&gt; Promise.all(x(promiseList))xxx([request1(), request2(), request3()]) .then(result =&gt; console.log(result)) 打印结果如下： Promise.allSettled(数组): 等待全部状态改变12Promise.allSettled([Promise.reject(1), Promise.resolve(2), Promise.resolve(3)]) .then(result =&gt; console.log(result)) 打印结果如下： 可以看出 Promise.allSettled 的作用其实和上面我们实现的 xxx 函数的作用是一致的，因此针对上文提到场景，可以直接使用 Promise.allSettled，更加简洁。 Promise.race(数组): 等待第一个状态改变12345Promise.race([request1(), request2(), request3()]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 第 1 个请求失败&#125;) Promise.race([request1, request2, request3])里面哪个请求最先响应，就返回其对应的结果，不管结果本身是成功状态还是失败状态（这里最先响应的请求是 request1）。 一般情况下用不到 Promise.race 这个 api，不过在某些场景下还是有用的。例如在多台服务器部署了同样的服务端代码，要从一个商品列表的接口拿数据，这时候就可以在 race 中写上所有服务器中的查询商品列表的接口地址，哪个服务器响应快，就优先从哪个服务器拿数据。 Promise 的应用场景多次处理一个结果1摇色子().then(v =&gt; v1).then(v1 =&gt; v2) 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 串行 这里有一个悖论：一旦 promise 出现，那么任务就已经执行了 所以不是 promise 串行，而是任务串行 解法：把任务放进队列，完成一个再做下一个（用 Reduce 实现 Promise 串行执行） 并行Promise.all、Promise.allSettled、Promise.race都可以看作是并行地在处理任务 这里可能你会产生疑问，JS 不是单线程吗，怎么做到并行执行任务？ 这里指的是并行地做网络请求的任务，而网络请求实际上是由浏览器来做的，并非是 JS 做的，就像 setTimeout 是浏览器的功能而不是 JS 的，setTimeout 只是浏览器提供给 JS 的一个接口。 Promise 的错误处理自身的错误处理promise 自身的错误处理其实挺好用的，直接在.then的第二个回调参数中进行错误处理即可 1promise.then(s1, f1) 或者使用.catch语法糖 12// 上面写法的语法糖promise.then(s1).catch(f1) 建议总是使用catch()方法，而不使用then()方法的第二个参数，原因是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch） 全局错误处理以axios为例，Axios 作弊表 错误处理之后 如果你没有继续抛错，那么错误就不再出现 如果你继续抛错，那么后续回调就要继续处理错误 前端似乎对 Promise 不满Async&#x2F;Await替代Promise的6个理由，主要是以下 6 个方面： 简洁 错误处理 条件语句 中间值 错误栈 调试（在.then代码块中设置断点，使用 Step Over 快捷键，调试器不会跳到下一个.then，因为它只会跳过异步代码） async &#x2F; awaitasync &#x2F; await 基本用法最常见的用法 1234const fn = async() =&gt; &#123; const temp = await makePromise() return temp + 1&#125; 优点：完全没有缩进，就像是在写同步代码 封装一个 async 函数async的封装和使用 1234567891011121314function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(Math.floor(Math.random() * 6) + 1) &#125;, 3000) &#125;)&#125;async function fn() &#123; const result = await 摇色子() console.log(result)&#125;fn() 用try...catch进行错误处理 1234567891011121314async function 摇色子() &#123; throw new Error(&#x27;色子坏了&#x27;)&#125;async function fn() &#123; try &#123; const result = await 摇色子() console.log(result) &#125; catch (error) &#123; console.log(error) &#125;&#125;fn() 为什么需要 async在函数前面加一个async，这看起来非常多余，await所在的函数就是async，不是吗？ 理由之一： 在 ES 标准的 async&#x2F;await 出来之前，有些人自己用函数实现了 await，为了兼容旧代码里普通函数的 await(xxx)（为了将旧代码里面的 await 和新的 ES 标准里的 async&#x2F;await 区分开来），其实 async 本身并没有什么意义。 你可能会说，async函数会隐式地返回一个 Promise 对象呀，但这并不能成为必须要在函数前加async的理由，有兴趣的可以去看看知乎上关于async的讨论。 为什么js里使用了await的方法必须定义成async的？ C#中，async关键字到底起什么作用？ await 错误处理用 try&#x2F;catch 来同时处理同步和异步错误是很常见的做法 12345678910let responsetry &#123; response = await axios.get(&#x27;/xxx&#x27;)&#125; catch (e) &#123; if (e.response) &#123; console.log(e.response.status) throw e &#125;&#125;console.log(response) 但其实还有更好的写法，就像下面这样 123456789101112const errorHandler = error =&gt; &#123; console.log(error) // 注意这里要抛出一个错误 throw error // 或者 return Promise.reject(error)，注意：一定要 return&#125;// 只用一句代码就可以处理成功和失败const response = await axios.get(&#x27;/xxx&#x27;).then(null, errorHandler)// 或者使用 catch 语法糖const response = await axios.get(&#x27;/xxx&#x27;).catch(errorHandler) 需要注意的是，errorHandler函数中不要直接return一个值，一定要抛出一个错误（打断程序的运行）。因为在请求调用失败的情况下，会把errorHandler里return的值直接赋值给 response（通俗的说法就是“Promise 会吃掉错误”），在errorHandler中抛出一个错误能够保证在请求成功的情况下才会有 response，请求失败的情况下一定是会进入errorHandler函数中的 下面是一个实际的例子 123456789101112131415161718const ajax = function() &#123; return new Promise((resolve, reject) =&gt; &#123; reject(&#x27;这是失败后的提示&#x27;) // resolve(&#x27;这是成功后的结果&#x27;) &#125;)&#125;const error = (error) =&gt; &#123; console.log(&#x27;error:&#x27;, error) return Promise.reject(error)&#125;async function fn() &#123; const response = await ajax().then(null, error) console.log(&#x27;response:&#x27;, response)&#125;fn() 可以看到，我们仅仅只用了一句代码就可以同时处理 Promise 成功和失败的情况了，绝大多数的 ajax 调用都是可以用这样的方式来处理的。 所以，对于async/await，并不是一定需要使用try/catch来做错误处理的。 之前我常常陷入一个误区：就是认为await和.then是对立的，始终觉得用了await后就不应该再出现.then。 但其实并非如此，说到底async/await也只不过是.then的语法糖而已。就像上面的例子一样，.then和await完全是可以结合在一起使用的，在.then中进行错误处理，而await左边只接受成功结果。 另外，我们还可以把 4xx&#x2F;5xx 等常见错误用拦截器全局处理，errorHandler也可以放在拦截器里。 await 的传染性代码： 123console.log(1)await console.log(2)console.log(3) // await 会使这句代码变成异步的，如果想要让他立即执行，放到 await 前面即可 分析： await会使得所有它左边的和下面的代码变成异步代码 console.log(3)变成异步任务了 Promise 同样有传染性（同步变异步），放到.then回调函数中的代码会变成异步的，不过相比于await，.then下面的代码并不会变成异步的 回调没有传染性 await 的应用场景多次处理一个结果123const r1 = await makePromise()const r2 = handleR1(r1)const r3 = handleR2(r2) 串行天生串行（多个await并排时，从上到下依次执行，后面的会等前面执行完了再执行） 1234await promise1await promise2await promise3... 并行同 Promise，await Promise.all([p1, p2, p3])、await Promise.allSettled([p1, p2, p3])、await Promise.race([p1, p2, p3]) 都是并行的 循环的时候存在 bug正常情况下，即便在循环中，await也应当是串行执行的。 例如 for 循环中的 await 是串行的（后面等前面） 1234567891011121314151617181920async function runPromiseByQueue(myPromises) &#123; for (let i = 0; i &lt; myPromises.length; i++) &#123; await myPromises[i](); &#125;&#125;const createPromise = (time, id) =&gt; () =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(&quot;promise&quot;, id); resolve(); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 4 2 1 但是在某些循环中，如 forEach 和 map 中，await 会并行执行（后面不等前面） 1234567891011121314151617181920async function runPromiseByQueue(myPromises) &#123; myPromises.forEach(async (task) =&gt; &#123; await task(); &#125;);&#125;const createPromise = (time, id) =&gt; () =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(&quot;promise&quot;, id); resolve(); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 1 2 4 后面 JS 又出了一个新的东西 for await…of 来弥补这个 bug 123456789101112131415161718192021async function runPromiseByQueue(myPromises) &#123; // 异步迭代 for await (let item of myPromises) &#123; console.log(&#x27;promise&#x27;, item); &#125;&#125;const createPromise = (time, id) =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; resolve(id); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 4 2 1","tags":["Promise","async/await"],"categories":["学习笔记"]},{"title":"JavaScript Snippets","path":"/2021/07/23/javascript-snippets/","content":":::info收集的一些常用的 JavaScript 代码片段::: 将给定字符串中每个单词的首字母转为大写1234const capitalizeWord = (string) =&gt; string.replace(/\\b[a-z]/g, (char) =&gt; char.toUpperCase());console.log(capitalizeWord(&quot;hello world in javascript&quot;)); // Hello World In Javascript 计算给定字符串的字节长度1234const byteSize = (string) =&gt; new Blob([string]).size;console.log(byteSize(&quot;vivy&quot;)); // 4console.log(byteSize(&quot;潮鸣&quot;)); // 6 将数组元素转换为指定的 HTML 元素，主要用于将数据转换为界面 HTML 格式12345const arrayToHtmlList = (array, tag = &quot;li&quot;) =&gt; array.map((item) =&gt; `&lt;$&#123;tag&#125;&gt;$&#123;item&#125;&lt;/$&#123;tag&#125;&gt;`).join(&quot;&quot;);console.log(arrayToHtmlList([&quot;第一条&quot;, &quot;第二条&quot;])); // &lt;li&gt;第一条&lt;/li&gt;&lt;li&gt;第二条&lt;/li&gt;console.log(arrayToHtmlList([&quot;第一条&quot;, &quot;第二条&quot;], &quot;p&quot;)); // &lt;p&gt;第一条&lt;/p&gt;&lt;p&gt;第二条&lt;/p&gt; 多个数值求平均值1234567const average = (...nums) =&gt; nums.reduce((acc, val) =&gt; acc + val, 0) / nums.length;const ages = [23, 56, 15, 28];// 此代码也展示了函数如何传递不定参数（使用 ES6 扩展运算符）console.log(average(...ages)); // 30.5console.log(average(23, 56, 15, 28)); // 30.5 计算 map 数组按照指定 key 的平均值，也可以给定一个迭代函数123456789101112const averageBy = (array, fn) =&gt; array.map(typeof fn === &quot;function&quot; ? fn : (val) =&gt; val[fn]).reduce((acc, val) =&gt; acc + val, 0) / array.length;const users = [ &#123; name: &quot;saber&quot;, size: 23 &#125;, &#123; name: &quot;vivy&quot;, size: 56 &#125;, &#123; name: &quot;tico&quot;, size: 15 &#125;, &#123; name: &quot;k423&quot;, size: 28 &#125;,];const average1 = averageBy(users, (item) =&gt; item.size);const average2 = averageBy(users, &quot;size&quot;);console.log(average1); // 30.5console.log(average2); // 30.5 封装 localStorage12345678910111213141516171819202122232425const useStorage = (storageKey = &quot;authorization&quot;) =&gt; &#123; const localKey = `devpoint.local.$&#123;storageKey&#125;`; const save = (data) =&gt; &#123; window.localStorage.setItem(localKey, JSON.stringify(data)); &#125;; const get = () =&gt; &#123; const localData = window.localStorage.getItem(localKey); if (localData &amp;&amp; localData !== &quot;&quot;) &#123; return JSON.parse(localData); &#125; else &#123; return false; &#125; &#125;; const clear = () =&gt; &#123; window.localStorage.setItem(localKey, &quot;&quot;); &#125;; return &#123; save, get, clear &#125;;&#125;;const storageAuth = useStorage();const loginInfo = &#123; username: &quot;vivy&quot;, age: 18,&#125;;storageAuth.save(loginInfo);console.log(storageAuth.get()); 计算数组中某个值的重复次数123456789const countOccurrences = (array, value) =&gt; array.reduce( (accumulator, current) =&gt; current === value ? accumulator + 1 : accumulator, 0 );console.log(countOccurrences([...&quot;vivy&quot;], &quot;v&quot;)); // 2console.log(countOccurrences([1, 3, 3, 4, 3, 3, 2, 3], 3)); // 5 检查值是否属于某个数据类型123456789const isCheck = (type, val) =&gt; ![undefined, null].includes(val) &amp;&amp; val.constructor === type;console.log(isCheck(Array, [&quot;a&quot;])); // trueconsole.log(isCheck(Object, &#123;&#125;)); // trueconsole.log(isCheck(ArrayBuffer, new ArrayBuffer())); // trueconsole.log(isCheck(Boolean, new Boolean(true))); // trueconsole.log(isCheck(RegExp, /./g)); // trueconsole.log(isCheck(Number, 0)); // true 遍历对象的每个属性，并分别为每个属性迭代一个回调123456789101112const forObject = (obj, callback) =&gt; Object.keys(obj).forEach((key) =&gt; callback(obj[key], key, obj));const testObj = &#123; word: &quot;信じる心があなたの魔法〜&quot;, author: &quot;篝敦子&quot;,&#125;;forObject(testObj, (val, key) =&gt; &#123; console.log(`$&#123;key&#125;:$&#123;val&#125;`);&#125;);// word:信じる心があなたの魔法〜// author:篝敦子 通过键值查找对象，返回满足给定函数的第一个 key12345678910const findKey = (obj, fn) =&gt; Object.keys(obj).find((key) =&gt; fn(obj[key], key, obj));const testObj = &#123; vivy: &#123; age: 17 &#125;, k423: &#123; age: 18 &#125;, saber: &#123; age: 19 &#125;,&#125;;console.log(findKey(testObj, (item) =&gt; item.age &gt; 18)); // saber 将一组数据按照指定的 key 的进行分组，并按照分组进行归类1234567891011121314151617181920212223242526272829303132333435363738const groupBy = (obj, key) =&gt; &#123; const values = obj instanceof Map || obj instanceof Set ? Array.from(obj.values()) : Object.values(obj); return values.reduce((acc, value) =&gt; &#123; const groupKey = value[key]; if (!Array.isArray(acc[groupKey])) &#123; acc[groupKey] = [value]; &#125; else &#123; acc[groupKey].push(value); &#125; return acc; &#125;, &#123;&#125;);&#125;;const arrayRoles = [ &#123; title: &quot;Mieruko-chan&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Vladilena Mirizé&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Nakano Azusa&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Shirahane Suou&quot;, category: &quot;yyy&quot; &#125;, &#123; title: &quot;Mio Akiyama&quot;, category: &quot;yyy&quot; &#125;,];console.log(groupBy(arrayRoles, &quot;category&quot;));/*&#123; &#x27;xxx&#x27;: [ &#123; title: &#x27;Mieruko-chan&#x27;, category: &#x27;xxx&#x27; &#125;, &#123; title: &#x27;Vladilena Mirizé&#x27;, category: &#x27;xxx&#x27; &#125;, &#123; title: &#x27;Nakano Azusa&#x27;, category: &#x27;xxx&#x27; &#125; ], &#x27;yyy&#x27;: [ &#123; title: &#x27;Shirahane Suou&#x27;, category: &#x27;yyy&#x27; &#125;, &#123; title: &#x27;Mio Akiyama&#x27;, category: &#x27;yyy&#x27; &#125; ]&#125;*/","tags":["JavaScript Snippets","Tool function"],"categories":["学习笔记"]},{"title":"第三方应用授权：OAuth 2.0","path":"/2021/06/21/oauth2.0/","content":"介绍OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。 简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（access_token），用来代替密码，供第三方应用使用。 OAuth 2.0 的优点：保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全 令牌与密码的区别令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。 令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。 令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。 令牌有权限范围（scope）。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。 :::warning只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。::: 四种授权类型（authorization grant）即四种颁发令牌的方式： 授权码（authorization-code） 隐藏式（implicit） 密码式（password）： 客户端凭证（client credentials） :::primary不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。::: 第一种授权方式：授权码授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。:::info这种方式是&#x3D;&#x3D;最常用的流程&#x3D;&#x3D;，安全性也最高，它适用于那些++有后端的 Web 应用++{.wavy .success}。授权码通过前端传送，++令牌则是储存在后端++{.dot}，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。::: 举例说明： A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用 12345https://b.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。 用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码 1https://a.com/callback?code=AUTHORIZATION_CODE A 网站拿到授权码以后，就可以&#x3D;&#x3D;在后端&#x3D;&#x3D;，向 B 网站请求令牌 123456https://b.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL client_id参数和client_secret参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri参数是令牌颁发后的回调网址。 B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据 123456789&#123; &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;token_type&quot;:&quot;bearer&quot;, &quot;expires_in&quot;:2592000, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, &quot;scope&quot;:&quot;read&quot;, &quot;uid&quot;:100101, &quot;info&quot;:&#123;...&#125;&#125; access_token字段就是令牌，A 网站在后端拿到了。 第二种方式：隐藏式有些 Web 应用是&#x3D;&#x3D;纯前端应用&#x3D;&#x3D;，没有后端。这时就不能用上面的方式了，必须++将令牌储存在前端++{.dot}。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式++没有授权码这个中间步骤++{.dot}，所以称为（授权码）”隐藏式”（implicit）。 A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用 12345https://b.com/oauth/authorize? response_type=token&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read response_type参数为token，表示要求直接返回令牌。 用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。 1https://a.com/callback#token=ACCESS_TOKEN token参数就是令牌，A 网站因此直接在前端拿到令牌。 :::info注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。另外，这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。::: 第三种方式：密码式如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。 A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。 12345https://oauth.b.com/token? grant_type=password&amp; username=USERNAME&amp; password=PASSWORD&amp; client_id=CLIENT_ID grant_type参数是授权方式，这里的password表示”密码式”，username和password是 B 的用户名和密码。 B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 响应，A 因此拿到令牌。 :::danger这种方式需要用户给出自己的用户名&#x2F;密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。::: 第四种方式：凭证式最后一种方式是凭证式（client credentials），适用于++没有前端的命令行应用++{.dot}，即在命令行下请求令牌。 A 应用在命令行向 B 发出请求。 1234https://oauth.b.com/token? grant_type=client_credentials&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET grant_type参数等于client_credentials表示采用凭证式，client_id和client_secret用来让 B 确认 A 的身份。 B 网站验证通过以后，直接返回令牌 :::info这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。::: 令牌的使用A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。 此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。 12curl -H &quot;Authorization: Bearer ACCESS_TOKEN&quot; \\&quot;https://api.b.com&quot; 更新令牌令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。 具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。 12345https://b.com/oauth/token? grant_type=refresh_token&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; refresh_token=REFRESH_TOKEN grant_type参数为refresh_token表示要求更新令牌，client_id参数和client_secret参数用于确认身份，refresh_token参数就是用于更新令牌的令牌。 B 网站验证通过以后，就会颁发新的令牌。","tags":["OAuth 2.0","第三方应用授权"],"categories":["学习笔记"]},{"title":"npm & package.json","path":"/2021/06/17/npm&package.json/","content":"npm 是什么npm 是 Node.js 的包管理工具，Node.js package manger，通过 npm Node.js 可以方便地使用第三方开发的开源模块，同时也可以把自己的模块发布到 npm 供其它开发者使用。 npm 主要由三部分组成： npm website：https://npmjs.com，开发者查找发现 package 的站点 CLI（命令行）：开发者可以使用命令行工具和 npm 进行交互，对 package 进行安装、更新、删除等操作 registry（注册表）：package 及其元信息存储的数据库 :::info注册表是一个巨大的数据库，保存了每个包（package）的信息。例如我们要查询 vue 包的信息，可以访问https://registry.npmjs.org/vue，就会看到 vue 模块所有版本的信息。模块名后面，还可以跟上版本号或者标签，用来查询某个具体版本的信息，例如：https://registry.npmjs.org/vue/3.0.0 查看 vue 3.0.0 版本的信息具体用法就是，https://registry.npmjs.org/模块名/版本号::: yarnyarn 是 Facebook 2017 年推出的和 npm 功能类似的包管理工具，主要解决当时 npm 的几个核心问题 安装包不够快速与稳定 存在安全隐患 同时 yarn 的 cli 工具提供了更简单的命令，当然面对 yarn 带来的压力，npm 在 5.0 后提供了类似的改进，两者现在差距不再巨大，开发者可以根据个人习惯和项目规范自由选择（我个人更喜欢使用 yarn） npxnpm 从5.2版本开始，增加了 npx 命令，npx 想要解决的主要问题，就是调用项目内部安装的模块。原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在；如果存在，则执行；不存在，则进行临时安装，然后执行，执行完毕后将包删除。 对 npx 的详细介绍见npx使用教程 package.jsonnpm 通过 Node.js 模块根目录的 package.json 文件获取模块元数据和依赖关系等，例如react 的 package.json 包含如下信息:::info可以通过npm init -y或者yarn init -y生成一份默认的 package.json 配置::: react 的 package.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; &quot;name&quot;: &quot;react&quot;, &quot;description&quot;: &quot;React is a JavaScript library for building user interfaces.&quot;, &quot;keywords&quot;: [ &quot;react&quot; ], &quot;version&quot;: &quot;17.0.3&quot;, &quot;homepage&quot;: &quot;https://reactjs.org/&quot;, &quot;bugs&quot;: &quot;https://github.com/facebook/react/issues&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;files&quot;: [ &quot;LICENSE&quot;, &quot;README.md&quot;, &quot;build-info.json&quot;, &quot;index.js&quot;, &quot;cjs/&quot;, &quot;umd/&quot;, &quot;jsx-runtime.js&quot;, &quot;jsx-dev-runtime.js&quot;, &quot;unstable-shared-subset.js&quot; ], &quot;main&quot;: &quot;index.js&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &#123; &quot;react-server&quot;: &quot;./unstable-shared-subset.js&quot;, &quot;default&quot;: &quot;./index.js&quot; &#125;, &quot;./index&quot;: &#123; &quot;react-server&quot;: &quot;./unstable-shared-subset.js&quot;, &quot;default&quot;: &quot;./index.js&quot; &#125;, &quot;./build-info.json&quot;: &quot;./build-info.json&quot;, &quot;./jsx-runtime&quot;: &quot;./jsx-runtime.js&quot;, &quot;./jsx-dev-runtime&quot;: &quot;./jsx-dev-runtime.js&quot;, &quot;./&quot;: &quot;./&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/facebook/react.git&quot;, &quot;directory&quot;: &quot;packages/react&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=0.10.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;loose-envify&quot;: &quot;^1.1.0&quot;, &quot;object-assign&quot;: &quot;^4.1.1&quot; &#125;, &quot;browserify&quot;: &#123; &quot;transform&quot;: [ &quot;loose-envify&quot; ] &#125;&#125; namename 是模块的唯一标识，安装、使用模块都需要使用模块的 name，可以使用字母（只能使用小写字母）、数字、_、-和.，例如安装和使用 vue 需要用到如下命令 1yarn add vue 1import &#123;inject, Ref&#125; from &#x27;vue&#x27; 可以通过 scope 组织具有相关性的模块，模块名义@开头的包就是一个 scoped package，scope 就是@和/之间的内容 1@scope/project-name 例如@antv&#x2F;g2plot version版本号遵从语义化版本规范，使用x.y.z形式，对应主版本.次版本.修订版本 ，版本号递增规则如下： 主版本（major）：当你做了不兼容的 API 修改，一般改动很大，不兼容低版本 次版本（minor）：当你做了向下兼容的功能性新增，兼容同一个大版本的 API 和用法 修订版本（patch）：当你做了向下兼容的问题修正，一般用来修复 bug 先行版本x.y.z格式是模块正式版本，重要模块为了保证稳定，会在放出正式版本之前提供先行版本 alpha: 内部版本 beta: 公测版本 rc: Release candidate，正式版本的候选版本 stable: 稳定版 csp 例：npm 上 vue 部分版本记录 这种特殊版本除非开发者&#x3D;&#x3D;精确声明使用&#x3D;&#x3D;，例如npm install vue@3.0.0-rc.13，否则npm install不会自动安装对应版本内容 快捷命令npm 提供了快捷升级命令 升级主版本号：npm version major 升级次版本号：npm version minor 升级修订版本号：npm version patch 设置版本号为指定的版本号：npm version 版本号 升级先行版本号：npm version prerelease 升级先行版本号并指定先行版本的名字：npm version prerelease --preid=&lt;prerelease-id&gt; 示例： 1234567# 假定现在的版本号是1.1.1npm version major # 2.0.0npm version minor # 1.2.0npm version patch # 1.1.2npm version prerelease # 1.1.2-0npm version prerelease --preid=alpha # 1.1.2-alpha.0npm version 4.1.2 # 4.1.2 :::info执行npm version修改完版本号之后，还会默认执行 git add -&gt; git commit -&gt; git tag 操作，commit 的信息和为 tag 均为版本号，且该步骤应在npm publish之前进行。::: tagnpm 中的 tag 类似于 git 中的 branch ，发布者可以在指定的 tag 上进行发版，使用者可以选择指定 tag 来安装，默认的 tag 是latest。这对于我们日常开发非常有用，很多时候我们想要发布版本来进行验证功能，但是又不想影响正在使用的人，我们就可以利用 tag 和先行版本来进行发包。 12npm publish --tag alpha # 发版到名为 alpha 的 tag 上npm i &lt;package&gt;@&lt;tag&gt; # 从指定 tag 上安装包 dependencies &amp; devDependenciesdependencies 和 devDependencies 字段用来表示模块的依赖和开发环境依赖，模块依赖的版本号有些几种不同写法，来保证安装的时候使用对应的版本 x.y.z 使用精确版本号 * 任意版本，第一次安装会使用模块最新版本 ^x.y.z x 位锁死，y、z 位使用最新版本 3.x和^3.0.0含义相同，x 位使用指定版本，y、z 位使用最新 ~x.y.z x、y 锁定，z 位使用最新版本 npm 提供了快捷命令，可以在安装的时候就自动把对应内容写到 package.json 中 12npm install &lt;package_name&gt; --save # 安装模块并写入 dependenciesnpm install &lt;package_name&gt; --save-dev # 安装模块并写入 devDependencies peerDependencies有时候模块需要与宿主模块共享依赖，也就是有可能会用到某个模块，但自己不安装，希望宿主环境安装的时候使用 peerDependencies 声明，比如 react-dom 的 package.json 的使用 12345678&quot;dependencies&quot;: &#123; &quot;loose-envify&quot;: &quot;^1.1.0&quot;, &quot;object-assign&quot;: &quot;^4.1.1&quot;, &quot;scheduler&quot;: &quot;^0.20.1&quot;&#125;,&quot;peerDependencies&quot;: &#123; &quot;react&quot;: &quot;17.0.3&quot;&#125; repositoryrepository 用来指定模块源代码信息 12345&quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/facebook/react.git&quot;, &quot;directory&quot;: &quot;packages/react&quot;&#125; main 字段main 字段用来标识模块的默认入口文件，比如 react main: &quot;index.js&quot; ，下面两句写法含义相同 12const react = require(&#x27;react&#x27;);const react = require(&#x27;react/index.js&#x27;); 发布 package 在 npmjs.com 上注册账号 在++命令行++{.dot}使用npm login登录 使用npm publish进行发布 :::warning在进行npm publish操作前，请确认使用的是 npm 官方源，如果当前使用的是非官方源，可以使用npm config set registry https://registry.npmjs.org或者nrm切换至 npm 官方源:::","tags":["npm","package.json"],"categories":["学习笔记"]},{"title":"Google 搜索技巧","path":"/2021/03/01/google-search-skills/","content":"使用引号强制进行精确匹配搜索:::default no-icon“what is javascript”::: AND运算符将只返回与这两个术语相关的结果:::default no-iconhtml AND css::: 使用OR运算符获取与其中一个搜索词相关的结果:::default no-icon(javascript OR python) free course或者(javascript | python) free course::: search_skill_03 -运算符将排除包含以下术语或短语的结果:::default no-iconjavascript -css::: search_skill_04 使用*通配符作为占位符，它将被任何单词或短语替换:::default no-icon“how to start * in 6 months”::: search_skill_05 在单个网站内搜索:::default no-iconsite:freecodecamp.org::: search_skill_06 也可以用site:来限制搜索结果的顶级域，例如.com、.edu、.org search_skill_06 查找特定的文件类型:::default no-iconfiletype:pdf learn css或者ext:pdf learn css::: search_skill_07 搜索一个数字范围:::default no-iconecmascript 2016..2018::: search_skill_08","tags":["Google 搜索技巧"],"categories":["其他"]},{"title":"浅析前端路由","path":"/2021/02/22/frontend-routing/","content":"什么是前端路由用最简单的话来说就是，页面间的跳转仅由前端来控制，而不需要向后端发起请求。前端路由反映的是URL和组件之间的映射关系。 前端路由反映的是 URL 和组件之间的映射关系 route_01 如何实现前端路由vue-router 中有 3 种路由模式：hash、history、abstract（不常用），这里仅介绍下 hash 模式和 history 模式的简单实现 hash 模式早期的前端路由的实现就是基于 location.hash 来实现的。实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 &#39;#first&#39;。 1http://www.example.com#first hash 路由模式的实现主要基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分并不会被发送； hash 值的任意改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮来控制 hash 的切换； 通过设置 a 标签的 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者直接对 loaction.hash 进行赋值，改变 URL 的 hash 值； 通过浏览器原生的 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。 12345678910111213141516171819202122232425262728293031323334&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--渲染对应组件的地方--&gt;&lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 第一次加载的时候，不会执行 hashchange 监听事件，默认执行一次 // DOMContentLoaded 为浏览器 DOM 加载完成时触发 window.addEventListener(&#x27;DOMContentLoaded&#x27;, Load); window.addEventListener(&#x27;hashchange&#x27;, HashChange); // 展示页面组件的节点 var routeView = null; function Load() &#123; routeView = document.getElementById(&#x27;route-view&#x27;); HashChange(); &#125; function HashChange() &#123; // 每次触发 hashchange 事件，通过 location.hash 拿到当前浏览器地址的 hash 值 // 根据不同的路径展示不同的内容 switch (location.hash) &#123; case &#x27;#/page1&#x27;: routeView.innerHTML = &#x27;page1&#x27;; return; case &#x27;#/page2&#x27;: routeView.innerHTML = &#x27;page2&#x27;; return; default: routeView.innerHTML = &#x27;page1&#x27;; return; &#125; &#125;&lt;/script&gt; 这仅是最简易的实现，真实的 hash 模式，还要考虑到很多复杂的情况，具体情况可以去看 Vue Router 的源码。 history 模式history 模式的实现基于 HTML5 提供的 History API，其中最主要的 API 为：history.pushState() 和 history.repalceState()。这两个 API 均可在不刷新页面的情况下，对浏览器的历史记录进行操作。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。 history 路由模式的实现主要基于下面几个特性： 通过 history.pushState() 和 history.repalceState() 这两个 API 来操作实现 URL 的变化（实际上是改变了浏览器的 location.pathname 属性值）； 通过浏览器原生的 popstate 事件来监听浏览器动作的变化，从而对页面进行跳转（渲染）； 但 history.pushState() 或 history.replaceState() 只能改变 URL，并不会触发 popstate 事件，需要手动触发页面跳转（渲染）。 需要注意的是调用 history.pushState() 或 history.replaceState() 不会触发 popstate 事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在 Javascript 代码中调用 history.back() 或者 history.forward() 方法）（摘自 MDN 对 popstate 的解释） 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&#x27;DOMContentLoaded&#x27;, Load); window.addEventListener(&#x27;popstate&#x27;, PopChange); var routeView = null; function Load() &#123; routeView = document.getElementById(&#x27;route-view&#x27;); // 默认执行一次 popstate 的回调函数，匹配一次页面组件 PopChange(); // 获取所有带 href 属性的 a 标签节点 var aList = document.querySelectorAll(&#x27;a[href]&#x27;); // 遍历 a 标签节点数组，阻止默认事件，添加点击事件回调函数 aList.forEach((aNode) =&gt; aNode.addEventListener(&#x27;click&#x27;, function (e) &#123; e.preventDefault(); //阻止a标签的默认事件 var href = aNode.getAttribute(&#x27;href&#x27;); // 手动修改浏览器的地址栏 history.pushState(null, &#x27;&#x27;, href); // 通过 history.pushState 手动修改地址栏， // popstate 是监听不到地址栏的变化，所以此处需要手动执行回调函数 PopChange PopChange(); &#125;) ); &#125; function PopChange() &#123; console.log(&#x27;location&#x27;, location); switch (location.pathname) &#123; case &#x27;/page1&#x27;: routeView.innerHTML = &#x27;page1&#x27;; return; case &#x27;/page2&#x27;: routeView.innerHTML = &#x27;page2&#x27;; return; default: routeView.innerHTML = &#x27;page1&#x27;; return; &#125; &#125;&lt;/script&gt; 思路：通过遍历页面上的所有 a 标签，阻止 a 标签的默认事件的同时，加上点击事件的回调函数，在回调函数内获取 a 标签的 href 属性值，再通过 pushState 去改变浏览器的 location.pathname 属性值。然后手动执行 popstate 事件的回调函数，去匹配相应的路由。 注意，以上代码不能在浏览器直接打开静态文件（会报错），需要通过 web 服务，启动端口去浏览网址。 单页面应用 v.s. 多页面应用对前端来说，路由概念的出现是伴随着SPA出现的；在SPA出现之前，页面的跳转(导航)都是通过服务端来控制的，并且页面跳转存在一个明显白屏跳转过程；SPA出现后，用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染，就不再让服务端控制页面跳转了，于是前端路由出现了，前端可以自由控制组件的渲染，来模拟页面跳转。 单页面应用和多页面应用的对比如下： 单页面应用（SinglePage Web Application，SPA） 多页面应用（MultiPage Application，MPA） 组成 一个外壳页面和多个页面片段组成 多个完整页面构成 资源共用（css，js） 共用，只需在外壳部分加载 不共用，每个页面都需要加载 刷新方式 页面局部刷新或更改 整页刷新 URL 模式 xxx.com/#/firstxxx.com/#/second xxx.com/#/first.htmlxxx.com/#/second.html 用户体验 页面片段间切换快，用户体验好 页面切换加载缓慢，流畅度不够，用户体验较差 转场动画 容易实现 无法实现 数据传递 容易 依赖 URL 传参，或者 cookie、localStorage 等 搜索引擎优化（SEO） 需要单独方案、实现较为困难、不利于SEO检索、可利用服务端渲染（SSR）优化 容易实现 使用范围 高要求的体验度、追求界面流畅的应用（一般是后台管理系统） 适用于追求高度支持搜索引擎的应用 维护成本 相对容易 相对复杂","tags":["前端路由"],"categories":["学习笔记"]},{"title":"Vue 两个版本的区别（完整版 v.s. 运行时版）","path":"/2020/06/30/vue-difference-version/","content":"使用 Vue 实例的三种方式 方法一：从 HTML 得到视图 使用「完整版 Vue」 通过 cdn 或 import 来引入 vue.js 或者 vue.min.js 将视图写在 HTML 中或者写在 template 选项中 方法二：用 JS 来构建视图 使用「非完整版 Vue」 通过 cdn 或 import 来引入 vue.runtime.js 或者 vue.runtime.min.js 使用 render 函数 方法三：使用 vue-loader（webpack 的一个 loader） 使用「非完整版 Vue」 vue-loader 可以把 *.vue 文件翻译成 h 构建方法 这种做法的缺点是，HTML 内就只有一个 div#app，对 SEO 不友好 完整版（运行时 + 编译器） v.s. 非完整版（只包含运行时）对比如下： Vue 完整版 （运行时 + 编译器） Vue 非完整版（只包含运行时） 评价 特点 有 compiler 没有 compiler compiler 占 30% 体积 视图 写在 HTML 中或者写在 template 选项中 写在 render 函数里用 h 来创建标签 h 是尤雨溪写好传给 render 的 cdn 引入 vue.js vue.runtime.js 文件名不同，生产环境后缀为 .min.js webpack 引入 需要配置 alias 默认使用此版 尤雨溪配置的 @vue&#x2F;cli 引入 需要额外配置 默认使用此版 尤雨溪、蒋豪群配置的 1234567891011// 需要编译器new Vue(&#123; template: &#x27;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#x27;&#125;)// 不需要编译器new Vue(&#123; render (h) &#123; return h(&#x27;div&#x27;, this.hi) &#125;&#125;) 当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。 最佳实践：总是使用非完整版，然后配合vue-loader 和 vue 单文件组件。 Vue 作者的思路： 为了保证用户体验，让用户下载的 JS 文件体积更小，但只支持 h 函数 为了保证开发体验，让开发者可以直接在 vue 文件里写 HTML 标签，而不写 h 函数 由此发明了 vue-loader，脏活儿让 loader 来做，vue-loader 把 vue 文件里的 HTML 转为 h 函数 SEO 基本原理 全称：Search Engine Optimization，中文：搜索引擎优化 你可以认为搜索引擎就是在不停的发起 curl 搜索引擎根据 curl 的结果来猜测页面的内容 如果页面的内容是通过 JS 渲染上去的，则不利于 SEO JS 创建 div 比如 Vue 的 HTML 内初始就只有一个 div#app，这个 div 的内容是通过 JS 后面填充进去的，因此 Vue 不利于 SEO（可以用 SSR 来解决 Vue 的 SEO 问题） 解决「SEO 不友好」方法： 原则上只要让 curl 能得到页面的信息，SEO 就能正常工作 把 title、description、keyword、meta、h1、a 写好即可 百度的 SEO 就是个笑话，充钱你就能变强 Google 其实可以获取 JS 创建的内容，但毕竟在墙外，国内还是别想了","tags":["Vue","SEO","Vue compiler"],"categories":["学习笔记"]},{"title":"朋友们","path":"/friends/index.html","content":"Notev優萌初華云之巅涼風桜雨星日语Hairy'Blog初之音"}]