[{"title":"深入函数：声明、参数、返回值","path":"/2023/02/01/typescript/ts-7/","content":"深入对象语法描述对象的属性索引签名（Index Signature）映射类型（Mapped Type）可选属性只读属性深入函数语法声明函数的四种方式类型谓词参数相关语法可选参数参数默认值参数也可以是函数返回值也可以是函数","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"类型兼容与赋值","path":"/2023/01/30/typescript/ts-6/","content":"为什么要有类型兼容简单类型的兼容普通对象的兼容接口的兼容函数的兼容参数个数不同参数类型不同返回值不同实际工作中的函数特殊类型的兼容顶类型(Top Type) 与 底类型(Bottom Type)","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TS 中的类型运算：交叉类型","path":"/2023/01/17/typescript/ts-5/","content":"交叉类型（交集）英文全称：intersection types 12type A = string &amp; number;// ^-- never 交叉类型一般多用于对象 用于接口求交集 1234567interface Colorful &#123; color: string;&#125;interface Circle &#123; radius: number;&#125;type ColorfulCircle = Colorful &amp; Circle; 用于模拟继承 1234567891011121314type Person = &#123; name: string; age: number;&#125;;type User = Person &amp; &#123; id: number; email: string;&#125;;const u: User = &#123; id: 1, name: &#x27;ClariS&#x27;, age: 18, email: &#x27;xxx@yyy.com&#x27;&#125;; 交叉类型的特殊情况123456789101112131415type Person = &#123; name: string; age: number; id: string;&#125;;type User = Person &amp; &#123; id: number; email: string;&#125;;const u: User = &#123; id: 1, // 报错：Type &#x27;number&#x27; is not assignable to type &#x27;never&#x27; name: &#x27;ClariS&#x27;, age: 18, email: &#x27;xxx@yyy.com&#x27;,&#125;; 123type A = &#123; kind: &#x27;A&#x27;; name: string &#125;;type B = &#123; kind: &#x27;B&#x27;; age: number &#125; &amp; A;// ^-- never 12345678910interface Person &#123; name: string; age: number; id: string;&#125;interface User extends Person &#123; // ^-- Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27; id: number; email: string;&#125; 123456789101112type A = &#123; method: (a: number) =&gt; void;&#125;;type B = &#123; method: (a: string) =&gt; void;&#125; &amp; A;const b: B = &#123; method(a) &#123; a; // number | string &#125;&#125;;","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TS 中的类型运算：联合类型","path":"/2023/01/12/typescript/ts-4/","content":"TS &#x3D; JS + 类型系统 JS 可以对值进行加减运算，如果把 TS 的类型系统当作一门语言，TS 也同样可以对类型进行各种运算 联合类型（并集）英文全称：union types type A = &#123; name: string &#125; 表示 name 为 string 的所有对象但不要错误地认为这些对象只有 name 这一个 key比如对象 &#123; name: &#39;ClariS&#39;; age: 18 &#125; 也是属于 A 类型的即 A 类型的对象可以有 age，也可以没有 age同理，type = &#123; age: number &#125; 表示 age 为 number 的对象，这些对象的 name 可以为空，也可以不为空 如何使用联合类型？12345const f1 = (a: number | string) =&gt; &#123; &#x27;既不能把 a 当作 number&#x27; &#x27;也不能把 a 当做 string&#x27; &#x27;那么，怎么使用 a 变量呢？&#x27;&#125; 如果不拆开类型，就只能使用 number 和 string 共同拥有的方法或属性，比如 toString() 因此要使用联合类型，就得先区分类型，也就是进行类型收窄(Narrowing) 如何进行类型收窄？使用 typeof123456789const f1 = (a: number | string) =&gt; &#123; if (typeof a === &#x27;number&#x27;) &#123; a.toFixed(2); &#125; else if (typeof a === &#x27;string&#x27;) &#123; parseFloat(a).toFixed(2); &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; typeof 的局限性：无法区分数组、日期、普通对象以及 null（返回值都是 &quot;object&quot;） 使用 instanceof123456789const f1 = (a: Array&lt;Date&gt; | Date) =&gt; &#123; if (a instanceof Date) &#123; a.toISOString(); &#125; else if (a instanceof Array) &#123; a[0].toISOString(); &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; instanceof 的局限性： 不支持基础类型，string、number、bigint、boolean、symbol、undefined 不支持 TS 独有的类型123456789type Person = &#123; name: string &#125;;const f1 = (a: Person | Person[]) =&gt; &#123; if (a instanceof Person) &#123; // ^--- 报错：type 不能用作 value &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; 使用 in 操作符123456789type Person = &#123; name: string &#125;;const f1 = (a: Person | Person[]) =&gt; &#123; if (&#x27;name&#x27; in a) &#123; a; // Person &#125; else &#123; a; // Person[] &#125;&#125;; in 操作符的局限性：只适用于部分对象 比如当判断的两个对象存在相同的 key （存在相同 key，其中一个对象的 key 可能不存在），或不为键值对形式的对象（比如日期、正则、函数等）时，则无法使用 in 操作符来收窄类型 使用 JS 中判断类型的函数123456789const f1 = (a: string | string[]) =&gt; &#123; if (Array.isArray(a)) &#123; a.join(&#x27; &#x27;).toString(); &#125; else if (typeof a === &#x27;string&#x27;) &#123; parseFloat(a).toFixed(2); &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; 使用逻辑12345678910111213141516171819202122const f1 = (a?: string[]) =&gt; &#123; if (a) &#123; a; // string[] &#125; else &#123; a; // undefined &#125;&#125;;const f2 = (a: string | number) =&gt; &#123; a = 1; a; // number&#125;;const f3 = (x: string | number, y: string | boolean) =&gt; &#123; if (x === y) &#123; x; // string y; // string &#125; else &#123; x; // string | number y; // string | number &#125;&#125;; 使用类型谓词 is上述所有的类型收窄方法都是通过 JavaScript 来实现的，有没有区分类型的万全之法？ 12345678910111213141516type Rect = &#123; height: number; width: number &#125;;type Circle = &#123; center: [number, number]; radius: number &#125;;// 推荐使用普通函数实现 isRect，而不使用箭头函数function isRect(x: Rect | Circle): x is Rect &#123; return &#x27;height&#x27; in x &amp;&amp; &#x27;width&#x27; in x;&#125;const f1 = (a: Rect | Circle) =&gt; &#123; if (isRect(a)) &#123; // `isRect(a)` 判断 a 是不是 Rect a; // Rect &#125; else &#123; a; // Circle &#125;&#125;; 优点：支持所有 TS 类型缺点：需要自己实现，挺麻烦的 有没有更简单的办法？ 可辨别联合12345678910111213interface Circle &#123; kind: &quot;circle&quot;; radius: number; &#125;interface Square &#123; kind: &quot;square&quot;; sideLength: number; &#125;type Shape = Circle | Squareconst f1 = (shape: Shape) =&gt; &#123; if (shape.kind === &#x27;circle&#x27;) &#123; shape // Circle &#125; else if (shape.kind === &#x27;square&#x27;) &#123; shape // Square &#125; else &#123; shape // never &#125;&#125; 让复杂类型的收窄变成简单类型的对比 对于类型 T = A | B | C | D | ...，有以下要求： A、B、C、D... 有相同属性 kind 或其他 kind 的类型是简单类型 各类型中的 kind 可区分 则称 T 为可辨别联合 一句话总结：具有同名、可辨别的简单类型的 key 的联合类型，称为可辨别联合 使用断言可以使用 as 进行强制的类型收缩 1234567interface Circle &#123; kind: &quot;circle&quot;; radius: number; &#125;interface Square &#123; kind: &quot;square&quot;; sideLength: number; &#125;type Shape = Circle | Squareconst f1 = (shape: Shape) =&gt; &#123; (shape as Circle).radius = 4&#125; any 等于所有类型的联合吗？这里直接给出结论：any 不等于所有类型的联合 注意：这里的所有类型不包括 never unknown any void 用反证法可以证明： 只要类型发生了联合，就只能使用它们共同拥有的属性或方法（想要使用各自的方法就必须做类型收窄） 但是使用 any 之后，不做类型收窄可以使用所有类型的方法 说明 any 不是所有类型的联合 1234567891011const f1 = (a: string | number) =&gt; &#123; a.toString(); a.toFixed(); // 报错 a.split(); // 报错&#125;;const f2 = (a: any) =&gt; &#123; a.toString(); a.toFixed(); a.split();&#125;; 且 ts 的绝大部分规则对 any 不生效，但有一种特殊情况，any 无法赋值给 never 那什么等于所有类型的联合呢？ 1234567891011121314151617const f1 = (a: unknown) =&gt; &#123; if (a instanceof Date) &#123; a; // Date &#125;&#125;;type Rect = &#123; height: number; width: number &#125;;type Circle = &#123; center: [number, number]; radius: number &#125;;function isRect(x: Rect | Circle): x is Rect &#123; return &#x27;height&#x27; in x &amp;&amp; &#x27;width&#x27; in x;&#125;const f2 = (a: unknown) =&gt; &#123; if (isRect(a)) &#123; a; // Rect &#125;&#125;; 可以看出，unknown 是可以收窄到任何类型的，因此，unknown 就是所有类型的联合","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TypeScript 中的类型（下）","path":"/2022/12/29/typescript/ts-3/","content":"何时使用 enum 实例一：用 A.todo 将数字映射成一个有意义的语法 实例二：可以用于表示权限 以上代码中，Manage = Read | Write | Delete 是 JS 中的二进制操作（二进制或运算符），0b 在 JS 中表示二进制 何时用 enum 会显得很呆？ 如上所示，将 &#39;apple&#39; 映射为 Fruit.apple 完全是多此一举，还是别再用 enum 来映射字符串了吧ヾ(-_-;) 只推荐用 enum 对数字做映射，除此之外都不推荐使用 enum 何时使用 typeTS 中的 Type 叫作类型别名，Type Aliases，其实就是给其他类型取个名字，示例如下： 1234567891011type Name = string;type FalseLike = &#x27;&#x27; | 0 | false | null | undefined;type Point = &#123; x: number; y: number &#125;;type Points = Point[];type Line = [Point, Point];type Circle = &#123; center: Point; radius: number &#125;;type Fn = (a: number, b: number) =&gt; number;type FnWithProps = &#123; (a: number, b: number): number; prop1: number;&#125;; 如何体现出 type 只是一个别名？ 12type X = &#123; x: number &#125;type A = X 以上 TS 代码中 A 的类型是？由于 type 只是一个别名，并不是声明了一个真正的类型，此处 A 的类型为 { x: number } 如何理解 type FalseLike = &#39;&#39; | 0 | false | null | undefined？ 上面的五个值其实都是类型，类型可以理解为集合，因此可以看作五个集合并在一起，每个集合中只包含一个值；另外，不支持 NaN 作为类型，因为 NaN 表示的是一个值而不是类型 带有属性的函数的声明方式 12345678type FnWithProps = &#123; (a: number, b: number): number; props: string;&#125;;const fn: FnWithProps = (x, y) =&gt; x * y;fn.props = &#x27;hello&#x27;; 多用于 React 中 何时使用 interface声明接口，用于描述对象的属性 declare the shapes of objects 12345interface Data &#123; [k: string]: string; &#125;interface Point &#123; x: number; y: number; &#125;interface Points extends Array&lt;Point&gt; &#123;&#125;interface Fn &#123; (x: number, y: number): number; &#125;interface Date2 extends Date &#123;&#125; type 如何实现继承？ 123456interface X &#123; age: number; &#125;type Al = Array&lt;string&gt; &amp; &#123; name: string; &#125; &amp; X;// A1几乎等价于A2interface A2 extends Array&lt;string&gt;, X &#123; name: string; &#125; type 和 interface 的区别区别一interface 只能描述对象，而 type 能描述所有数据类型 区别二type 只是别名，而 interface 则是类型声明 12345type A = string;type B = A; // B 的类型是 stringinterface D extends Date &#123;&#125;type E = D; // E 的类型是 D 区别三type 不可重新赋值，因此不能存在同名的 type；而 interface 可以声明同名的类型，同名的 interface 会自动合并 123456type A = string; // 报错 Duplicate identifier &#x27;A&#x27;type A = number; // 报错 Duplicate identifier &#x27;A&#x27;interface X &#123; name: string; &#125;interface X &#123; age: number; &#125;const x: X = &#123; name: &#x27;ClariS&#x27;, age: 18 &#125;; // X 为 &#123; name: string; age: number; &#125; 使用 type 无法进行类型扩展，因此 对外 API 尽量用 interface，方便用户进行类型扩展；对内 API 尽量用 type，防止代码分散 扩展 interface 的实例： 扩展 axios 1234567import &#123; AxiosRequestConfig &#125; from &#x27;axios&#x27;;declare module &#x27;axios&#x27; &#123; export interface AxiosRequestConfig &#123; _autoLoading?: boolean; _mock?: string; &#125;&#125; 扩展 string 12345declare global &#123; interface String &#123; padZero(length: number): string; &#125;&#125; void12345678910111213141516171819type Fn = () =&gt; void;const fn: Fn = () =&gt; &#123; return &#x27;xxx&#x27;; // 不报错&#125;;const x = fn();console.log(x.toString()); // 报错：Property &#x27;toString&#x27; does not exist on type &#x27;void&#x27;.console.log((x as any).toString()); // 不报错function fn1(a: number): void &#123; return &#x27;xxx&#x27;; // 报错：Type &#x27;string&#x27; is not assignable to type &#x27;void&#x27;.&#125;const fn2 = (a: number): void =&gt; &#123; return &#x27;xxx&#x27;; // 报错：Type &#x27;string&#x27; is not assignable to type &#x27;void&#x27;.&#125;;","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TypeScript 中的类型（上）","path":"/2022/12/28/typescript/ts-2/","content":"JS&#x2F;TS 中有哪些数据类型 用集合来理解 TS 数据类型 number 可看做 1、1.1、2、2.3 等所有数字值组成的集合string 可看做 a、b、ab、c、abc 等所有字符串值组成的集合boolean 可看做 true 和 false 这两个值组成的集合 JS 中的 Number、String、Boolean 只用于包装对象，一般不会用到它们；同样地在 TS 中也不会用到它们。 TS 中一般不会用 Object 来描述对象的类型，因为 Object 所表示的类型范围太大了 如何用 TS 来描述对象 用 class&#x2F;constructor 描述 用 type&#x2F;interface 描述 描述普通对象由于 object&#x2F;Object 太不精确，所以一般使用索引签名或Record 泛型来描述普通对象 使用索引签名 思考题：key 的类型可以不是 string 吗？经测试，k 的类型只能为 number、string、symbol 这三种 使用 Record 使用具体的字段1234type A = &#123; name: string; age: number;&#125;; 描述数组对象由于 Array 太不精确，所以一般用 Array&lt;?&gt; 或 string[] 或 [string, number] 来描述数组 思考题 12type A = [1, 2, 3]const a: A = ?????? 以上 TS 代码中 a 的值是？当于只有一个元素的集合，因此 a 的值只能是 [1, 2, 3] 描述函数对象由于 Function 太不精确，所以一般用 () =&gt; ? 来描述函数 1234567891011121314type FnA = (a: number, b: number) =&gt; number;type FnReturnVoid = (s: string) =&gt; void;type FnReturnUndefined = (s: string) =&gt; undefined;const v: FnReturnVoid = (s: string) =&gt; &#123; console.log(s);&#125;;const u: FnReturnUndefined = (s: string) =&gt; &#123; console.log(s); return undefined;&#125;; 带有 this 的函数声明 123456789101112type Person = &#123;name: string, age: number, sayHi: FnWithThis&#125;type FnWithThis = (this: Person, name: string) =&gt; voidconst sayHi: FnWithThis = function(name) &#123; // 此处不能使用箭头函数，因为箭头函数内不存在 this console.log(&quot;hi&quot;, this.name)&#125;const x: Person = &#123;name: &quot;vivy&quot;, age: 18, sayHi&#125;// 如果函数声明中有 this，那么调用函数时必须显示地传递这个 thisx.sayHi(&quot;Citrus&quot;)sayHi.call(x, &quot;Citrus&quot;) 描述其他对象直接用 class（构造函数） 描述即可 12345678910111213const d: Date = new Date();const r: RegExp = /ab+c/;const m: Map&lt;string, number&gt; = new Map();m.set(&#x27;xxx&#x27;, 1);const wm: WeakMap&lt;&#123; name: string &#125;, number&gt; = new WeakMap();const s: Set&lt;&#123; name: string &#125;&gt; = new Set();s.add(&#123; name: &#x27;ClariS&#x27; &#125;);const ws: WeakSet&lt;string[]&gt; = new WeakSet(); any、unknown、never 是什么从集合的角度理解：any 是全集，never 是空集，unknown 是未知集 TS 的绝大部分规则对 any 类型不生效（TS 不报错） 可对 unknown 进行断言，适用于值是从外部获取的，没办法提前知道类型的情况；比如当使用 ajax 获取数据时，后台返回的数据格式不确定，此时可将接口响应的数据类型可定义为 unknown，然后再对其进行断言 12const a: unknown = await ajax.get(&#x27;/api/users&#x27;)const b = a as number never 一般不会用来声明类型，而是用来进行类型推断的 12345678910111213type A = string | number | boolean;const a: A = &#x27;hello&#x27; as any;if (typeof a === &#x27;string&#x27;) &#123; a.split(&#x27;&#x27;);&#125; else if (typeof a === &#x27;number&#x27;) &#123; a.toFixed(2);&#125; else if (typeof a === &#x27;boolean&#x27;) &#123; a.valueOf();&#125; else &#123; a.toString(); // 报错：Property &#x27;toString&#x27; does not exist on type &#x27;never&#x27;&#125; JS 类型与 TS 类型的区别我是这么理解的： JS 这门语言其实并没有提供类型相关的关键字（如小写的 number、string、boolean），只是提供了typeof让我们获取变量的类型，所以我认为 JS 对类型非常不重视。 而 TS 则将 JS 中的类型提升到很高的位置，高到如果你把类型写错了代码就不能通过编译。因此这两门语言中的类型其实没有可比性，只是看起来有重叠部分而已。如果一定要比较，我会这么说： 粒度不同：在 JS 中的类型 number 不可再细分，而 TS 中的 number 可以看做 1、1.1、2、2.3 等无数个小类型的联合 可变性不同：JS 中的变量类型是可变的，一个 number 随时可以变成一个 string；TS 中除了 any，其他类型要么是不可变的，要么就算可变也是有限制的","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TypeScript 的运行与调试","path":"/2022/09/07/typescript/ts-1/","content":"如何擦除类型 如何运行 TypeScript在线编辑 TypeScript Playground（缺点是 URL 太长） playcode stackblitz codesandbox 本地编辑 + 浏览器使用 vite 和 chrome 本地编辑 + Node ts-node swc-node @esbuild-kit&#x2F;esm-loader esno 如何调试 TypeScript鼠标悬浮上去看报错提示即可 学习资料推荐 编程与类型系统 TypeScript 编程 类型和程序设计语言","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"DNS 与 TCP","path":"/2021/08/20/dns-and-tcp/","content":"一图概览image.png DNS &amp; hostsDNS，全称：Domain Name System，中文：域名系统 域名系统本身的原理是比较复杂的，但域名系统的功能很简单，就是输入一个域名，输出一个 IP，这里我们只对 DNS 做简单讨论 举例说明： 在浏览器输入 baidu.com 这个地址 浏览器需要知道你访问的这个地址对应的 IP 是多少，于是浏览器就会去问操作系统 如果操作系统也不知道，就会去问电信、移动、联通这样的网络运行商（以下简称 ISP） 当你付费之后，网络运营商就会告诉你 baidu.com 这个地址对应的 IP 是多少（假设这里 baidu.com 对应的 IP 是 1.2.3.4），然后将 IP 返回给你 浏览器获取到 baidu.com 对应的 IP 之后，就会与 1.2.3.4 这个 IP 建立 TCP 连接 细化过程： 在浏览器输入 baidu.com 这个地址的时候，浏览器首先会去检查自身是否有缓存，如果发现之前访问过 baidu.com ，那么浏览器就会直接将上一次的 IP 进行返回 如果浏览器没有缓存，就回去询问操作系统，然后操作系统首先也是会检查自身是否有缓存，如果没有就会去询问 ISP（网络运行商） 平时我们修改 hosts 这个文件，其实就是在手动给操作系统设置缓存，比如我们在 hosts 中写入baidu.com 2.3.4.5，以后每次访问 baidu.com 这个地址的时候就不会再去询问 ISP 了，直接会通过 hosts 中的设置去访问 2.3.4.5 这个 IP TCP 三次握手TCP 全称：Transmission Control Protocol，即传输控制协议 image.png 假设 A 是浏览器，B 是服务器 A 首先会向 B 发送一个叫做SYN(x)（假设这里 x &#x3D; 100）的信息 SYN 是 synchronize(同步) 的缩写，同步不是指「同步异步」中的同步，而是「同步信息」中的同步；这里的 x 一般是一个数字编号，且 x 和 y 一般都是从 0 开始的，这里我们对 x 和 y 的意义不做讨论，有兴趣的请自行研究 B 收到 A 发来的同步信息后，就会返回ACK(x+1)（101） SYN(y)（这里假设 y &#x3D; 200） ACK 是 acknowledge(知道) 的缩写 然后 A 会回复消息 ACK(y+1)（201）给 B 从以上过程中能够确保以下几件事： A 可以向 B 发送信息 B 能收到 A 发送的信息 B 也可以向 A 发送信息 A 也能收到 B 发送的信息 三次握手成功后就开始建立 TCP 连接了，建立连接后就可以开始传输内容了（一般是 HTTP 内容，也可以是其他内容，且传输的过程也可以是双向的，并非一定是单向的），HTTP 内容传输结束后，就会「关闭」 TCP 四次挥手image.png 上述内容传输完成后，A 会发送一个FIN(x) 注意：不一定是 A 先发送 FIN，也可以是 B 先发送 B 先回复ACK(x+1) 注意：关闭时的 x 和 y 一般都不是 0 然后再回复FIN(y) 步骤 2 和步骤 3 中间可能会夹杂着其他内容 A 回复ACK(y+1) 最后，A 和 B 各自关闭自己的 TCP 连接 一些 Q &amp; A为什么需要关闭 TCP 连接？因为一直保持连接会浪费内存和 CPU TCP 和 UDP 的区别是什么？ 八股文，面试必背 TCP 面向连接有状态，UDP 无状态 TCP 可靠（不丢失不重复），UDP 不可靠 TCP 传输效率较低，UDP 较高 为什么 TCP 的三次握手不能精简为两次？为了确保客户端（A端）能接收到服务端（B端）的数据（只有两次的话，无法判断 A 是否能接收到 B 的数据） 为什么 TCP 的四次挥手不能将中间两步合并成一步？因为两步中间（指发送ACK(x+1)和FIN(y)之间）往往会有其他数据需要发送，需要等其他数据发送完成之后，再发送FIN(y)","tags":["DNS","TCP"],"categories":["学习笔记"]},{"title":"浅析 Promise、Async/Await","path":"/2021/08/17/promise-async-await/","content":"Promise基本用法Promise 的简单封装与使用 1234567891011// 封装function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(Math.floor(Math.random() * 6) + 1) &#125;, 3000) &#125;)&#125;// 使用摇色子().then(success1, failed1).then(success2, failed2) Ma Mi 任务模型 Ma 指 MacroTask(宏任务)，Mi 指 MicroTask(微任务) 先 Ma 再 Mi，即先执行宏任务再执行微任务 JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务 其实最初 JS 只存在一个任务队列，为了让 Promise 回调更早执行，强行又插入了一个异步的任务队列，用来存放 Mi 任务 宏任务：setTimeout()、setInterval()、 setImmediate()、 I&#x2F;O、UI渲染（常见的定时器，用户交互事件等等） 微任务：Promise、process.nextTick、Object.observe、MutationObserver Promise 的其他 APIPromise.resolve(result): 制造一个成功（或失败）制造成功 123456789101112function 摇色子() &#123; return Promise.resolve(4)&#125;// 等价于function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(4) &#125;)&#125;摇色子().then(n =&gt; console.log(n)) // 4 制造失败 123456function 摇色子() &#123; // 此处 Promise.resolve 接收的是一个失败的 Promise 实例（状态为 reject） return Promise.resolve(new Promise((resolve, reject) =&gt; reject()))&#125;摇色子().then(n =&gt; console.log(n)) // 1 Uncaught (in promise) undefined 关于 Promise.resolve 接收参数的问题，ECMAScript 6 入门里其实说得很清楚 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例；如果参数是一个原始值，或者没有参数，Promise.resolve都会直接返回一个resolved状态的 Promise 对象。 Promise.reject(reason): 制造一个失败12345Promise.reject(&#x27;我错了&#x27;)// 等价于new Promise((resolve, reject) =&gt; reject(&#x27;我错了&#x27;))Promise.reject(&#x27;我错了&#x27;).then(null, reason =&gt; console.log(reason)) // 我错了 Promise.all(数组): 等待全部成功，或者有一个失败全部成功，将所有成功 promise 结果组成的数组返回 12Promise.all([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]) .then(values =&gt; console.log(values)) // [1, 2, 3] 只要有一个失败，就结束，返回最先被 reject 失败状态的值 12Promise.all([Promise.reject(1), Promise.resolve(2), Promise.resolve(3)]) .then(values =&gt; console.log(values)) // Uncaught (in promise) 1 Promse.all 在需要对多个异步进行处理时往往非常有用； 不过在某些特殊情况下，直接使用Promse.all就显得不那么方便了 举个例子，比如现在有 3 个请求，request1, request2 和 request3，我们需要对这 3 个请求进行统一处理，并且不管请求成功还是失败，都需要拿到所有的响应结果，如果这时候使用Promise.all([request1, request2, request3])的话，request1 请求失败了，后面的两个请求 request2, request3 就都不会执行了（这里实际上是 request1 在 rejected 之后，被 Promise.all([]).catch 给捕获了 ）。 如何解决 Promise.all() 在第一个 Promise 失败就会中断的问题？ 利用 .then() 后会返回一个状态为 resolved 的 Promise（即会自动包装成一个已resolved的promise），从而避免被 Promise.all([]).catch 捕获 123456789101112131415161718192021222324// 3 个请求const request1 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;第 1 个请求失败&#x27;) &#125;, 1000)&#125;)const request2 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;第 2 个请求失败&#x27;) &#125;, 2000)&#125;)const request3 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;第 3 个请求成功&#x27;) &#125;, 3000)&#125;)Promise.all([ request1().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;)), request2().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;)), request3().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;))]).then(result =&gt; console.log(result)) 可以把对每个请求的.then操作封装一下 123456789101112const x = promiseList =&gt; promiseList.map(promise =&gt; promise.then(value =&gt; (&#123; status: &#x27;ok&#x27;, value&#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason&#125;)))const xxx = promiseList =&gt; Promise.all(x(promiseList))xxx([request1(), request2(), request3()]) .then(result =&gt; console.log(result)) 打印结果如下： Promise.allSettled(数组): 等待全部状态改变12Promise.allSettled([Promise.reject(1), Promise.resolve(2), Promise.resolve(3)]) .then(result =&gt; console.log(result)) 打印结果如下： 可以看出 Promise.allSettled 的作用其实和上面我们实现的 xxx 函数的作用是一致的，因此针对上文提到场景，可以直接使用 Promise.allSettled，更加简洁。 Promise.race(数组): 等待第一个状态改变12345Promise.race([request1(), request2(), request3()]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 第 1 个请求失败&#125;) Promise.race([request1, request2, request3])里面哪个请求最先响应，就返回其对应的结果，不管结果本身是成功状态还是失败状态（这里最先响应的请求是 request1）。 一般情况下用不到 Promise.race 这个 api，不过在某些场景下还是有用的。例如在多台服务器部署了同样的服务端代码，要从一个商品列表的接口拿数据，这时候就可以在 race 中写上所有服务器中的查询商品列表的接口地址，哪个服务器响应快，就优先从哪个服务器拿数据。 Promise 的应用场景多次处理一个结果1摇色子().then(v =&gt; v1).then(v1 =&gt; v2) 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 串行 这里有一个悖论：一旦 promise 出现，那么任务就已经执行了 所以不是 promise 串行，而是任务串行 解法：把任务放进队列，完成一个再做下一个（用 Reduce 实现 Promise 串行执行） 并行Promise.all、Promise.allSettled、Promise.race都可以看作是并行地在处理任务 这里可能你会产生疑问，JS 不是单线程吗，怎么做到并行执行任务？ 这里指的是并行地做网络请求的任务，而网络请求实际上是由浏览器来做的，并非是 JS 做的，就像 setTimeout 是浏览器的功能而不是 JS 的，setTimeout 只是浏览器提供给 JS 的一个接口。 Promise 的错误处理自身的错误处理promise 自身的错误处理其实挺好用的，直接在.then的第二个回调参数中进行错误处理即可 1promise.then(s1, f1) 或者使用.catch语法糖 12// 上面写法的语法糖promise.then(s1).catch(f1) 建议总是使用catch()方法，而不使用then()方法的第二个参数，原因是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch） 全局错误处理以axios为例，Axios 作弊表 错误处理之后 如果你没有继续抛错，那么错误就不再出现 如果你继续抛错，那么后续回调就要继续处理错误 前端似乎对 Promise 不满Async&#x2F;Await替代Promise的6个理由，主要是以下 6 个方面： 简洁 错误处理 条件语句 中间值 错误栈 调试（在.then代码块中设置断点，使用 Step Over 快捷键，调试器不会跳到下一个.then，因为它只会跳过异步代码） async &#x2F; awaitasync &#x2F; await 基本用法最常见的用法 1234const fn = async() =&gt; &#123; const temp = await makePromise() return temp + 1&#125; 优点：完全没有缩进，就像是在写同步代码 封装一个 async 函数async的封装和使用 1234567891011121314function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(Math.floor(Math.random() * 6) + 1) &#125;, 3000) &#125;)&#125;async function fn() &#123; const result = await 摇色子() console.log(result)&#125;fn() 用try...catch进行错误处理 1234567891011121314async function 摇色子() &#123; throw new Error(&#x27;色子坏了&#x27;)&#125;async function fn() &#123; try &#123; const result = await 摇色子() console.log(result) &#125; catch (error) &#123; console.log(error) &#125;&#125;fn() 为什么需要 async在函数前面加一个async，这看起来非常多余，await所在的函数就是async，不是吗？ 理由之一： 在 ES 标准的 async&#x2F;await 出来之前，有些人自己用函数实现了 await，为了兼容旧代码里普通函数的 await(xxx)（为了将旧代码里面的 await 和新的 ES 标准里的 async&#x2F;await 区分开来），其实 async 本身并没有什么意义。 你可能会说，async函数会隐式地返回一个 Promise 对象呀，但这并不能成为必须要在函数前加async的理由，有兴趣的可以去看看知乎上关于async的讨论。 为什么js里使用了await的方法必须定义成async的？ C#中，async关键字到底起什么作用？ await 错误处理用 try&#x2F;catch 来同时处理同步和异步错误是很常见的做法 12345678910let responsetry &#123; response = await axios.get(&#x27;/xxx&#x27;)&#125; catch (e) &#123; if (e.response) &#123; console.log(e.response.status) throw e &#125;&#125;console.log(response) 但其实还有更好的写法，就像下面这样 123456789101112const errorHandler = error =&gt; &#123; console.log(error) // 注意这里要抛出一个错误 throw error // 或者 return Promise.reject(error)，注意：一定要 return&#125;// 只用一句代码就可以处理成功和失败const response = await axios.get(&#x27;/xxx&#x27;).then(null, errorHandler)// 或者使用 catch 语法糖const response = await axios.get(&#x27;/xxx&#x27;).catch(errorHandler) 需要注意的是，errorHandler函数中不要直接return一个值，一定要抛出一个错误（打断程序的运行）。因为在请求调用失败的情况下，会把errorHandler里return的值直接赋值给 response（通俗的说法就是“Promise 会吃掉错误”），在errorHandler中抛出一个错误能够保证在请求成功的情况下才会有 response，请求失败的情况下一定是会进入errorHandler函数中的 下面是一个实际的例子 123456789101112131415161718const ajax = function() &#123; return new Promise((resolve, reject) =&gt; &#123; reject(&#x27;这是失败后的提示&#x27;) // resolve(&#x27;这是成功后的结果&#x27;) &#125;)&#125;const error = (error) =&gt; &#123; console.log(&#x27;error:&#x27;, error) return Promise.reject(error)&#125;async function fn() &#123; const response = await ajax().then(null, error) console.log(&#x27;response:&#x27;, response)&#125;fn() 可以看到，我们仅仅只用了一句代码就可以同时处理 Promise 成功和失败的情况了，绝大多数的 ajax 调用都是可以用这样的方式来处理的。 所以，对于async/await，并不是一定需要使用try/catch来做错误处理的。 之前我常常陷入一个误区：就是认为await和.then是对立的，始终觉得用了await后就不应该再出现.then。 但其实并非如此，说到底async/await也只不过是.then的语法糖而已。就像上面的例子一样，.then和await完全是可以结合在一起使用的，在.then中进行错误处理，而await左边只接受成功结果。 另外，我们还可以把 4xx&#x2F;5xx 等常见错误用拦截器全局处理，errorHandler也可以放在拦截器里。 await 的传染性代码： 123console.log(1)await console.log(2)console.log(3) // await 会使这句代码变成异步的，如果想要让他立即执行，放到 await 前面即可 分析： await会使得所有它左边的和下面的代码变成异步代码 console.log(3)变成异步任务了 Promise 同样有传染性（同步变异步），放到.then回调函数中的代码会变成异步的，不过相比于await，.then下面的代码并不会变成异步的 回调没有传染性 await 的应用场景多次处理一个结果123const r1 = await makePromise()const r2 = handleR1(r1)const r3 = handleR2(r2) 串行天生串行（多个await并排时，从上到下依次执行，后面的会等前面执行完了再执行） 1234await promise1await promise2await promise3... 并行同 Promise，await Promise.all([p1, p2, p3])、await Promise.allSettled([p1, p2, p3])、await Promise.race([p1, p2, p3]) 都是并行的 循环的时候存在 bug正常情况下，即便在循环中，await也应当是串行执行的。 例如 for 循环中的 await 是串行的（后面等前面） 1234567891011121314151617181920async function runPromiseByQueue(myPromises) &#123; for (let i = 0; i &lt; myPromises.length; i++) &#123; await myPromises[i](); &#125;&#125;const createPromise = (time, id) =&gt; () =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(&quot;promise&quot;, id); resolve(); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 4 2 1 但是在某些循环中，如 forEach 和 map 中，await 会并行执行（后面不等前面） 1234567891011121314151617181920async function runPromiseByQueue(myPromises) &#123; myPromises.forEach(async (task) =&gt; &#123; await task(); &#125;);&#125;const createPromise = (time, id) =&gt; () =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(&quot;promise&quot;, id); resolve(); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 1 2 4 后面 JS 又出了一个新的东西 for await…of 来弥补这个 bug 123456789101112131415161718192021async function runPromiseByQueue(myPromises) &#123; // 异步迭代 for await (let item of myPromises) &#123; console.log(&#x27;promise&#x27;, item); &#125;&#125;const createPromise = (time, id) =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; resolve(id); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 4 2 1","tags":["Promise","async/await"],"categories":["学习笔记"]},{"title":"JavaScript Snippets","path":"/2021/07/23/javascript-snippets/","content":":::info收集的一些常用的 JavaScript 代码片段::: 将给定字符串中每个单词的首字母转为大写1234const capitalizeWord = (string) =&gt; string.replace(/\\b[a-z]/g, (char) =&gt; char.toUpperCase());console.log(capitalizeWord(&quot;hello world in javascript&quot;)); // Hello World In Javascript 计算给定字符串的字节长度1234const byteSize = (string) =&gt; new Blob([string]).size;console.log(byteSize(&quot;vivy&quot;)); // 4console.log(byteSize(&quot;潮鸣&quot;)); // 6 将数组元素转换为指定的 HTML 元素，主要用于将数据转换为界面 HTML 格式12345const arrayToHtmlList = (array, tag = &quot;li&quot;) =&gt; array.map((item) =&gt; `&lt;$&#123;tag&#125;&gt;$&#123;item&#125;&lt;/$&#123;tag&#125;&gt;`).join(&quot;&quot;);console.log(arrayToHtmlList([&quot;第一条&quot;, &quot;第二条&quot;])); // &lt;li&gt;第一条&lt;/li&gt;&lt;li&gt;第二条&lt;/li&gt;console.log(arrayToHtmlList([&quot;第一条&quot;, &quot;第二条&quot;], &quot;p&quot;)); // &lt;p&gt;第一条&lt;/p&gt;&lt;p&gt;第二条&lt;/p&gt; 多个数值求平均值1234567const average = (...nums) =&gt; nums.reduce((acc, val) =&gt; acc + val, 0) / nums.length;const ages = [23, 56, 15, 28];// 此代码也展示了函数如何传递不定参数（使用 ES6 扩展运算符）console.log(average(...ages)); // 30.5console.log(average(23, 56, 15, 28)); // 30.5 计算 map 数组按照指定 key 的平均值，也可以给定一个迭代函数123456789101112const averageBy = (array, fn) =&gt; array.map(typeof fn === &quot;function&quot; ? fn : (val) =&gt; val[fn]).reduce((acc, val) =&gt; acc + val, 0) / array.length;const users = [ &#123; name: &quot;saber&quot;, size: 23 &#125;, &#123; name: &quot;vivy&quot;, size: 56 &#125;, &#123; name: &quot;tico&quot;, size: 15 &#125;, &#123; name: &quot;k423&quot;, size: 28 &#125;,];const average1 = averageBy(users, (item) =&gt; item.size);const average2 = averageBy(users, &quot;size&quot;);console.log(average1); // 30.5console.log(average2); // 30.5 封装 localStorage12345678910111213141516171819202122232425const useStorage = (storageKey = &quot;authorization&quot;) =&gt; &#123; const localKey = `devpoint.local.$&#123;storageKey&#125;`; const save = (data) =&gt; &#123; window.localStorage.setItem(localKey, JSON.stringify(data)); &#125;; const get = () =&gt; &#123; const localData = window.localStorage.getItem(localKey); if (localData &amp;&amp; localData !== &quot;&quot;) &#123; return JSON.parse(localData); &#125; else &#123; return false; &#125; &#125;; const clear = () =&gt; &#123; window.localStorage.setItem(localKey, &quot;&quot;); &#125;; return &#123; save, get, clear &#125;;&#125;;const storageAuth = useStorage();const loginInfo = &#123; username: &quot;vivy&quot;, age: 18,&#125;;storageAuth.save(loginInfo);console.log(storageAuth.get()); 计算数组中某个值的重复次数123456789const countOccurrences = (array, value) =&gt; array.reduce( (accumulator, current) =&gt; current === value ? accumulator + 1 : accumulator, 0 );console.log(countOccurrences([...&quot;vivy&quot;], &quot;v&quot;)); // 2console.log(countOccurrences([1, 3, 3, 4, 3, 3, 2, 3], 3)); // 5 检查值是否属于某个数据类型123456789const isCheck = (type, val) =&gt; ![undefined, null].includes(val) &amp;&amp; val.constructor === type;console.log(isCheck(Array, [&quot;a&quot;])); // trueconsole.log(isCheck(Object, &#123;&#125;)); // trueconsole.log(isCheck(ArrayBuffer, new ArrayBuffer())); // trueconsole.log(isCheck(Boolean, new Boolean(true))); // trueconsole.log(isCheck(RegExp, /./g)); // trueconsole.log(isCheck(Number, 0)); // true 遍历对象的每个属性，并分别为每个属性迭代一个回调123456789101112const forObject = (obj, callback) =&gt; Object.keys(obj).forEach((key) =&gt; callback(obj[key], key, obj));const testObj = &#123; word: &quot;信じる心があなたの魔法〜&quot;, author: &quot;篝敦子&quot;,&#125;;forObject(testObj, (val, key) =&gt; &#123; console.log(`$&#123;key&#125;:$&#123;val&#125;`);&#125;);// word:信じる心があなたの魔法〜// author:篝敦子 通过键值查找对象，返回满足给定函数的第一个 key12345678910const findKey = (obj, fn) =&gt; Object.keys(obj).find((key) =&gt; fn(obj[key], key, obj));const testObj = &#123; vivy: &#123; age: 17 &#125;, k423: &#123; age: 18 &#125;, saber: &#123; age: 19 &#125;,&#125;;console.log(findKey(testObj, (item) =&gt; item.age &gt; 18)); // saber 将一组数据按照指定的 key 的进行分组，并按照分组进行归类1234567891011121314151617181920212223242526272829303132333435363738const groupBy = (obj, key) =&gt; &#123; const values = obj instanceof Map || obj instanceof Set ? Array.from(obj.values()) : Object.values(obj); return values.reduce((acc, value) =&gt; &#123; const groupKey = value[key]; if (!Array.isArray(acc[groupKey])) &#123; acc[groupKey] = [value]; &#125; else &#123; acc[groupKey].push(value); &#125; return acc; &#125;, &#123;&#125;);&#125;;const arrayRoles = [ &#123; title: &quot;Mieruko-chan&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Vladilena Mirizé&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Nakano Azusa&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Shirahane Suou&quot;, category: &quot;yyy&quot; &#125;, &#123; title: &quot;Mio Akiyama&quot;, category: &quot;yyy&quot; &#125;,];console.log(groupBy(arrayRoles, &quot;category&quot;));/*&#123; &#x27;xxx&#x27;: [ &#123; title: &#x27;Mieruko-chan&#x27;, category: &#x27;xxx&#x27; &#125;, &#123; title: &#x27;Vladilena Mirizé&#x27;, category: &#x27;xxx&#x27; &#125;, &#123; title: &#x27;Nakano Azusa&#x27;, category: &#x27;xxx&#x27; &#125; ], &#x27;yyy&#x27;: [ &#123; title: &#x27;Shirahane Suou&#x27;, category: &#x27;yyy&#x27; &#125;, &#123; title: &#x27;Mio Akiyama&#x27;, category: &#x27;yyy&#x27; &#125; ]&#125;*/","tags":["JavaScript Snippets","Tool function"],"categories":["学习笔记"]},{"title":"第三方应用授权：OAuth 2.0","path":"/2021/06/21/oauth2.0/","content":"介绍OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。 简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（access_token），用来代替密码，供第三方应用使用。 OAuth 2.0 的优点：保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全 令牌与密码的区别令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。 令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。 令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。 令牌有权限范围（scope）。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。 :::warning只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。::: 四种授权类型（authorization grant）即四种颁发令牌的方式： 授权码（authorization-code） 隐藏式（implicit） 密码式（password）： 客户端凭证（client credentials） :::primary不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。::: 第一种授权方式：授权码授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。:::info这种方式是&#x3D;&#x3D;最常用的流程&#x3D;&#x3D;，安全性也最高，它适用于那些++有后端的 Web 应用++{.wavy .success}。授权码通过前端传送，++令牌则是储存在后端++{.dot}，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。::: 举例说明： A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用 12345https://b.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。 用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码 1https://a.com/callback?code=AUTHORIZATION_CODE A 网站拿到授权码以后，就可以&#x3D;&#x3D;在后端&#x3D;&#x3D;，向 B 网站请求令牌 123456https://b.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL client_id参数和client_secret参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri参数是令牌颁发后的回调网址。 B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据 123456789&#123; &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;token_type&quot;:&quot;bearer&quot;, &quot;expires_in&quot;:2592000, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, &quot;scope&quot;:&quot;read&quot;, &quot;uid&quot;:100101, &quot;info&quot;:&#123;...&#125;&#125; access_token字段就是令牌，A 网站在后端拿到了。 第二种方式：隐藏式有些 Web 应用是&#x3D;&#x3D;纯前端应用&#x3D;&#x3D;，没有后端。这时就不能用上面的方式了，必须++将令牌储存在前端++{.dot}。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式++没有授权码这个中间步骤++{.dot}，所以称为（授权码）”隐藏式”（implicit）。 A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用 12345https://b.com/oauth/authorize? response_type=token&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read response_type参数为token，表示要求直接返回令牌。 用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。 1https://a.com/callback#token=ACCESS_TOKEN token参数就是令牌，A 网站因此直接在前端拿到令牌。 :::info注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。另外，这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。::: 第三种方式：密码式如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。 A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。 12345https://oauth.b.com/token? grant_type=password&amp; username=USERNAME&amp; password=PASSWORD&amp; client_id=CLIENT_ID grant_type参数是授权方式，这里的password表示”密码式”，username和password是 B 的用户名和密码。 B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 响应，A 因此拿到令牌。 :::danger这种方式需要用户给出自己的用户名&#x2F;密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。::: 第四种方式：凭证式最后一种方式是凭证式（client credentials），适用于++没有前端的命令行应用++{.dot}，即在命令行下请求令牌。 A 应用在命令行向 B 发出请求。 1234https://oauth.b.com/token? grant_type=client_credentials&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET grant_type参数等于client_credentials表示采用凭证式，client_id和client_secret用来让 B 确认 A 的身份。 B 网站验证通过以后，直接返回令牌 :::info这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。::: 令牌的使用A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。 此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。 12curl -H &quot;Authorization: Bearer ACCESS_TOKEN&quot; \\&quot;https://api.b.com&quot; 更新令牌令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。 具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。 12345https://b.com/oauth/token? grant_type=refresh_token&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; refresh_token=REFRESH_TOKEN grant_type参数为refresh_token表示要求更新令牌，client_id参数和client_secret参数用于确认身份，refresh_token参数就是用于更新令牌的令牌。 B 网站验证通过以后，就会颁发新的令牌。","tags":["OAuth 2.0","第三方应用授权"],"categories":["学习笔记"]},{"title":"npm & package.json","path":"/2021/06/17/npm&package.json/","content":"npm 是什么npm 是 Node.js 的包管理工具，Node.js package manger，通过 npm Node.js 可以方便地使用第三方开发的开源模块，同时也可以把自己的模块发布到 npm 供其它开发者使用。 npm 主要由三部分组成： npm website：https://npmjs.com，开发者查找发现 package 的站点 CLI（命令行）：开发者可以使用命令行工具和 npm 进行交互，对 package 进行安装、更新、删除等操作 registry（注册表）：package 及其元信息存储的数据库 :::info注册表是一个巨大的数据库，保存了每个包（package）的信息。例如我们要查询 vue 包的信息，可以访问https://registry.npmjs.org/vue，就会看到 vue 模块所有版本的信息。模块名后面，还可以跟上版本号或者标签，用来查询某个具体版本的信息，例如：https://registry.npmjs.org/vue/3.0.0 查看 vue 3.0.0 版本的信息具体用法就是，https://registry.npmjs.org/模块名/版本号::: yarnyarn 是 Facebook 2017 年推出的和 npm 功能类似的包管理工具，主要解决当时 npm 的几个核心问题 安装包不够快速与稳定 存在安全隐患 同时 yarn 的 cli 工具提供了更简单的命令，当然面对 yarn 带来的压力，npm 在 5.0 后提供了类似的改进，两者现在差距不再巨大，开发者可以根据个人习惯和项目规范自由选择（我个人更喜欢使用 yarn） npxnpm 从5.2版本开始，增加了 npx 命令，npx 想要解决的主要问题，就是调用项目内部安装的模块。原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在；如果存在，则执行；不存在，则进行临时安装，然后执行，执行完毕后将包删除。 对 npx 的详细介绍见npx使用教程 package.jsonnpm 通过 Node.js 模块根目录的 package.json 文件获取模块元数据和依赖关系等，例如react 的 package.json 包含如下信息:::info可以通过npm init -y或者yarn init -y生成一份默认的 package.json 配置::: react 的 package.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; &quot;name&quot;: &quot;react&quot;, &quot;description&quot;: &quot;React is a JavaScript library for building user interfaces.&quot;, &quot;keywords&quot;: [ &quot;react&quot; ], &quot;version&quot;: &quot;17.0.3&quot;, &quot;homepage&quot;: &quot;https://reactjs.org/&quot;, &quot;bugs&quot;: &quot;https://github.com/facebook/react/issues&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;files&quot;: [ &quot;LICENSE&quot;, &quot;README.md&quot;, &quot;build-info.json&quot;, &quot;index.js&quot;, &quot;cjs/&quot;, &quot;umd/&quot;, &quot;jsx-runtime.js&quot;, &quot;jsx-dev-runtime.js&quot;, &quot;unstable-shared-subset.js&quot; ], &quot;main&quot;: &quot;index.js&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &#123; &quot;react-server&quot;: &quot;./unstable-shared-subset.js&quot;, &quot;default&quot;: &quot;./index.js&quot; &#125;, &quot;./index&quot;: &#123; &quot;react-server&quot;: &quot;./unstable-shared-subset.js&quot;, &quot;default&quot;: &quot;./index.js&quot; &#125;, &quot;./build-info.json&quot;: &quot;./build-info.json&quot;, &quot;./jsx-runtime&quot;: &quot;./jsx-runtime.js&quot;, &quot;./jsx-dev-runtime&quot;: &quot;./jsx-dev-runtime.js&quot;, &quot;./&quot;: &quot;./&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/facebook/react.git&quot;, &quot;directory&quot;: &quot;packages/react&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=0.10.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;loose-envify&quot;: &quot;^1.1.0&quot;, &quot;object-assign&quot;: &quot;^4.1.1&quot; &#125;, &quot;browserify&quot;: &#123; &quot;transform&quot;: [ &quot;loose-envify&quot; ] &#125;&#125; namename 是模块的唯一标识，安装、使用模块都需要使用模块的 name，可以使用字母（只能使用小写字母）、数字、_、-和.，例如安装和使用 vue 需要用到如下命令 1yarn add vue 1import &#123;inject, Ref&#125; from &#x27;vue&#x27; 可以通过 scope 组织具有相关性的模块，模块名义@开头的包就是一个 scoped package，scope 就是@和/之间的内容 1@scope/project-name 例如@antv&#x2F;g2plot version版本号遵从语义化版本规范，使用x.y.z形式，对应主版本.次版本.修订版本 ，版本号递增规则如下： 主版本（major）：当你做了不兼容的 API 修改，一般改动很大，不兼容低版本 次版本（minor）：当你做了向下兼容的功能性新增，兼容同一个大版本的 API 和用法 修订版本（patch）：当你做了向下兼容的问题修正，一般用来修复 bug 先行版本x.y.z格式是模块正式版本，重要模块为了保证稳定，会在放出正式版本之前提供先行版本 alpha: 内部版本 beta: 公测版本 rc: Release candidate，正式版本的候选版本 stable: 稳定版 csp 例：npm 上 vue 部分版本记录 这种特殊版本除非开发者&#x3D;&#x3D;精确声明使用&#x3D;&#x3D;，例如npm install vue@3.0.0-rc.13，否则npm install不会自动安装对应版本内容 快捷命令npm 提供了快捷升级命令 升级主版本号：npm version major 升级次版本号：npm version minor 升级修订版本号：npm version patch 设置版本号为指定的版本号：npm version 版本号 升级先行版本号：npm version prerelease 升级先行版本号并指定先行版本的名字：npm version prerelease --preid=&lt;prerelease-id&gt; 示例： 1234567# 假定现在的版本号是1.1.1npm version major # 2.0.0npm version minor # 1.2.0npm version patch # 1.1.2npm version prerelease # 1.1.2-0npm version prerelease --preid=alpha # 1.1.2-alpha.0npm version 4.1.2 # 4.1.2 :::info执行npm version修改完版本号之后，还会默认执行 git add -&gt; git commit -&gt; git tag 操作，commit 的信息和为 tag 均为版本号，且该步骤应在npm publish之前进行。::: tagnpm 中的 tag 类似于 git 中的 branch ，发布者可以在指定的 tag 上进行发版，使用者可以选择指定 tag 来安装，默认的 tag 是latest。这对于我们日常开发非常有用，很多时候我们想要发布版本来进行验证功能，但是又不想影响正在使用的人，我们就可以利用 tag 和先行版本来进行发包。 12npm publish --tag alpha # 发版到名为 alpha 的 tag 上npm i &lt;package&gt;@&lt;tag&gt; # 从指定 tag 上安装包 dependencies &amp; devDependenciesdependencies 和 devDependencies 字段用来表示模块的依赖和开发环境依赖，模块依赖的版本号有些几种不同写法，来保证安装的时候使用对应的版本 x.y.z 使用精确版本号 * 任意版本，第一次安装会使用模块最新版本 ^x.y.z x 位锁死，y、z 位使用最新版本 3.x和^3.0.0含义相同，x 位使用指定版本，y、z 位使用最新 ~x.y.z x、y 锁定，z 位使用最新版本 npm 提供了快捷命令，可以在安装的时候就自动把对应内容写到 package.json 中 12npm install &lt;package_name&gt; --save # 安装模块并写入 dependenciesnpm install &lt;package_name&gt; --save-dev # 安装模块并写入 devDependencies peerDependencies有时候模块需要与宿主模块共享依赖，也就是有可能会用到某个模块，但自己不安装，希望宿主环境安装的时候使用 peerDependencies 声明，比如 react-dom 的 package.json 的使用 12345678&quot;dependencies&quot;: &#123; &quot;loose-envify&quot;: &quot;^1.1.0&quot;, &quot;object-assign&quot;: &quot;^4.1.1&quot;, &quot;scheduler&quot;: &quot;^0.20.1&quot;&#125;,&quot;peerDependencies&quot;: &#123; &quot;react&quot;: &quot;17.0.3&quot;&#125; repositoryrepository 用来指定模块源代码信息 12345&quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/facebook/react.git&quot;, &quot;directory&quot;: &quot;packages/react&quot;&#125; main 字段main 字段用来标识模块的默认入口文件，比如 react main: &quot;index.js&quot; ，下面两句写法含义相同 12const react = require(&#x27;react&#x27;);const react = require(&#x27;react/index.js&#x27;); 发布 package 在 npmjs.com 上注册账号 在++命令行++{.dot}使用npm login登录 使用npm publish进行发布 :::warning在进行npm publish操作前，请确认使用的是 npm 官方源，如果当前使用的是非官方源，可以使用npm config set registry https://registry.npmjs.org或者nrm切换至 npm 官方源:::","tags":["npm","package.json"],"categories":["学习笔记"]},{"title":"Google 搜索技巧","path":"/2021/03/01/google-search-skills/","content":"使用引号强制进行精确匹配搜索:::default no-icon“what is javascript”::: AND运算符将只返回与这两个术语相关的结果:::default no-iconhtml AND css::: 使用OR运算符获取与其中一个搜索词相关的结果:::default no-icon(javascript OR python) free course或者(javascript | python) free course::: search_skill_03 -运算符将排除包含以下术语或短语的结果:::default no-iconjavascript -css::: search_skill_04 使用*通配符作为占位符，它将被任何单词或短语替换:::default no-icon“how to start * in 6 months”::: search_skill_05 在单个网站内搜索:::default no-iconsite:freecodecamp.org::: search_skill_06 也可以用site:来限制搜索结果的顶级域，例如.com、.edu、.org search_skill_06 查找特定的文件类型:::default no-iconfiletype:pdf learn css或者ext:pdf learn css::: search_skill_07 搜索一个数字范围:::default no-iconecmascript 2016..2018::: search_skill_08","tags":["Google 搜索技巧"],"categories":["其他"]},{"title":"浅析前端路由","path":"/2021/02/22/frontend-routing/","content":"什么是前端路由用最简单的话来说就是，页面间的跳转仅由前端来控制，而不需要向后端发起请求。前端路由反映的是URL和组件之间的映射关系。 前端路由反映的是 URL 和组件之间的映射关系 route_01 如何实现前端路由vue-router 中有 3 种路由模式：hash、history、abstract（不常用），这里仅介绍下 hash 模式和 history 模式的简单实现 hash 模式早期的前端路由的实现就是基于 location.hash 来实现的。实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#first’。 1http://www.example.com#first hash 路由模式的实现主要基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，&#x3D;&#x3D;hash 部分并不会被发送&#x3D;&#x3D;； hash 值的任意改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过&#x3D;&#x3D;浏览器的回退、前进按钮&#x3D;&#x3D;来控制 hash 的切换； 通过&#x3D;&#x3D;设置 a 标签的 href 属性&#x3D;&#x3D;，当用户点击这个标签后，URL 的 hash 值会发生改变；或者直接&#x3D;&#x3D;对 loaction.hash 进行赋值&#x3D;&#x3D;，改变 URL 的 hash 值； 通过浏览器原生的hashchange事件来++监听 hash 值的变化++{.dot .warning}，从而对页面进行跳转（渲染）。 1234567891011121314151617181920212223242526272829303132333435&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--渲染对应组件的地方--&gt;&lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 第一次加载的时候，不会执行 hashchange 监听事件，默认执行一次 // DOMContentLoaded 为浏览器 DOM 加载完成时触发 window.addEventListener(&#x27;DOMContentLoaded&#x27;, Load) window.addEventListener(&#x27;hashchange&#x27;, HashChange) // 展示页面组件的节点 var routeView = null function Load() &#123; routeView = document.getElementById(&#x27;route-view&#x27;) HashChange() &#125; function HashChange() &#123; // 每次触发 hashchange 事件，通过 location.hash 拿到当前浏览器地址的 hash 值 // 根据不同的路径展示不同的内容 switch(location.hash) &#123; case &#x27;#/page1&#x27;: routeView.innerHTML = &#x27;page1&#x27; return case &#x27;#/page2&#x27;: routeView.innerHTML = &#x27;page2&#x27; return default: routeView.innerHTML = &#x27;page1&#x27; return &#125; &#125;&lt;/script&gt; :::info这仅是最简易的实现，真实的 hash 模式，还要考虑到很多复杂的情况，具体情况可以去看 Vue Router 的源码。::: history 模式history 模式的实现基于 HTML5 提供的 History API，其中最主要的 API 为：history.pushState()和history.repalceState()。这两个 API 均可在不刷新页面的情况下，对浏览器的历史纪录进行操作。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。 history 路由模式的实现主要基于下面几个特性： 通过 pushState 和 repalceState 这两个 API 来操作实现 URL 的变化（实际上是改变了浏览器的location.pathname属性值） ； 通过浏览器原生的popstate事件来&#x3D;&#x3D;监听浏览器动作的变化&#x3D;&#x3D;，从而对页面进行跳转（渲染）； 但history.pushState()或history.replaceState()只能改变 URL，并不会触发 popstate 事件，需要&#x3D;&#x3D;手动触发页面跳转（渲染）&#x3D;&#x3D;。 :::info需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在 Javascript 代码中调用history.back()或者history.forward()方法）（摘自 MDN 对 popstate 的解释）::: 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&#x27;DOMContentLoaded&#x27;, Load) window.addEventListener(&#x27;popstate&#x27;, PopChange) var routeView = null function Load() &#123; routeView = document.getElementById(&#x27;route-view&#x27;) // 默认执行一次 popstate 的回调函数，匹配一次页面组件 PopChange() // 获取所有带 href 属性的 a 标签节点 var aList = document.querySelectorAll(&#x27;a[href]&#x27;) // 遍历 a 标签节点数组，阻止默认事件，添加点击事件回调函数 aList.forEach(aNode =&gt; aNode.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() //阻止a标签的默认事件 var href = aNode.getAttribute(&#x27;href&#x27;) // 手动修改浏览器的地址栏 history.pushState(null, &#x27;&#x27;, href) // 通过 history.pushState 手动修改地址栏， // popstate 是监听不到地址栏的变化，所以此处需要手动执行回调函数 PopChange PopChange() &#125;)) &#125; function PopChange() &#123; console.log(&#x27;location&#x27;, location) switch(location.pathname) &#123; case &#x27;/page1&#x27;: routeView.innerHTML = &#x27;page1&#x27; return case &#x27;/page2&#x27;: routeView.innerHTML = &#x27;page2&#x27; return default: routeView.innerHTML = &#x27;page1&#x27; return &#125; &#125;&lt;/script&gt; 以上代码的思路：通过遍历页面上的所有 a 标签，阻止 a 标签的默认事件的同时，加上点击事件的回调函数，在回调函数内获取 a 标签的 href 属性值，再通过 pushState 去改变浏览器的 location.pathname 属性值。然后手动执行 popstate 事件的回调函数，去匹配相应的路由。 :::warning这里注意，以上代码不能在浏览器直接打开静态文件（会报错），需要通过 web 服务，启动端口去浏览网址。::: 单页面应用 v.s. 多页面应用对前端来说，路由概念的出现是伴随着SPA出现的；在SPA出现之前，页面的跳转(导航)都是通过服务端来控制的，并且页面跳转存在一个明显白屏跳转过程；SPA出现后，用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染，就不再让服务端控制页面跳转了，于是前端路由出现了，前端可以自由控制组件的渲染，来模拟页面跳转。 单页面应用和多页面应用的对比如下： 单页面应用（SinglePage Web Application，SPA） 多页面应用（MultiPage Application，MPA） 组成 一个外壳页面和多个页面片段组成 多个完整页面构成 资源共用（css，js） 共用，只需在外壳部分加载 不共用，每个页面都需要加载 刷新方式 页面局部刷新或更改 整页刷新 URL 模式 xxx.com/#/firstxxx.com/#/second xxx.com/#/first.htmlxxx.com/#/second.html 用户体验 页面片段间切换快，用户体验好 页面切换加载缓慢，流畅度不够，用户体验较差 转场动画 容易实现 无法实现 数据传递 容易 依赖 URL 传参，或者 cookie、localStorage 等 搜索引擎优化（SEO） 需要单独方案、实现较为困难、不利于SEO检索、可利用服务端渲染（SSR）优化 容易实现 使用范围 高要求的体验度、追求界面流畅的应用（一般是后台管理系统） 适用于追求高度支持搜索引擎的应用 维护成本 相对容易 相对复杂","tags":["前端路由"],"categories":["学习笔记"]},{"title":"Vue 两个版本的区别（完整版 v.s. 运行时版）","path":"/2020/06/30/vue-difference-version/","content":"使用 Vue 实例的三种方式 方法一：从 HTML 得到视图 使用「完整版 Vue」 通过 cdn 或 import 来引入 vue.js 或者 vue.min.js 将视图写在 HTML 中或者写在 template 选项中 方法二：用 JS 来构建视图 使用「非完整版 Vue」 通过 cdn 或 import 来引入 vue.runtime.js 或者 vue.runtime.min.js 使用 render 函数 方法三：使用 vue-loader（webpack 的一个 loader） 使用「非完整版 Vue」 vue-loader 可以把 *.vue 文件翻译成 h 构建方法 这种做法的缺点是，HTML 内就只有一个 div#app，对 SEO 不友好 完整版（运行时 + 编译器） v.s. 非完整版（只包含运行时）对比如下： Vue 完整版 （运行时 + 编译器） Vue 非完整版（只包含运行时） 评价 特点 有 compiler 没有 compiler compiler 占 30% 体积 视图 写在 HTML 中或者写在 template 选项中 写在 render 函数里用 h 来创建标签 h 是尤雨溪写好传给 render 的 cdn 引入 vue.js vue.runtime.js 文件名不同，生产环境后缀为 .min.js webpack 引入 需要配置 alias 默认使用此版 尤雨溪配置的 @vue&#x2F;cli 引入 需要额外配置 默认使用此版 尤雨溪、蒋豪群配置的 1234567891011// 需要编译器new Vue(&#123; template: &#x27;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#x27;&#125;)// 不需要编译器new Vue(&#123; render (h) &#123; return h(&#x27;div&#x27;, this.hi) &#125;&#125;) 当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。 最佳实践：总是使用非完整版，然后配合vue-loader 和 vue 单文件组件。 Vue 作者的思路： 为了保证用户体验，让用户下载的 JS 文件体积更小，但只支持 h 函数 为了保证开发体验，让开发者可以直接在 vue 文件里写 HTML 标签，而不写 h 函数 由此发明了 vue-loader，脏活儿让 loader 来做，vue-loader 把 vue 文件里的 HTML 转为 h 函数 SEO 基本原理 全称：Search Engine Optimization，中文：搜索引擎优化 你可以认为搜索引擎就是在不停的发起 curl 搜索引擎根据 curl 的结果来猜测页面的内容 如果页面的内容是通过 JS 渲染上去的，则不利于 SEO JS 创建 div 比如 Vue 的 HTML 内初始就只有一个 div#app，这个 div 的内容是通过 JS 后面填充进去的，因此 Vue 不利于 SEO（可以用 SSR 来解决 Vue 的 SEO 问题） 解决「SEO 不友好」方法： 原则上只要让 curl 能得到页面的信息，SEO 就能正常工作 把 title、description、keyword、meta、h1、a 写好即可 百度的 SEO 就是个笑话，充钱你就能变强 Google 其实可以获取 JS 创建的内容，但毕竟在墙外，国内还是别想了","tags":["Vue","SEO","Vue compiler"],"categories":["学习笔记"]},{"title":"关于","path":"/about/index.html","content":""},{"title":"朋友们","path":"/friends/index.html","content":"Notev優萌初華云之巅涼風桜雨星日语Hairy'Blog"}]