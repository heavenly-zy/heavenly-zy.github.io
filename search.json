[{"title":"script 标签的 defer 与 async 属性（转载）","path":"/2023/03/17/async-and-defer/","content":"原文戳这里👉：https://github.com/mrlmx/blogs/issues/4 前言在面试的时候，经常会遇到一道经典的面试题： 如何优化网页加载速度？ 常规的回答中总会有一条： 把 css 文件放在页面顶部，把 js 文件放在页面底部。 那么，为什么要把 js 文件放在页面的最底部呢？ 我们先来看下这段代码： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;Hi&lt;/title&gt; &lt;script&gt; console.log(&quot;Howdy ~&quot;); &lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue@3.2.41/dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router@4.1.5/dist/vue-router.global.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello 👋🏻 ~ &lt;/body&gt;&lt;/html&gt; 他的执行顺序是： 在控制台打印：Howdy ~ 请求并执行 vue.global.js 请求并执行 vue-router.global.js 在页面中展示：Hello 👋🏻 ~ 触发 DOMContentLoaded 事件 浏览器的解析规则是：如果遇到 script 标签，则暂停构建 DOM，转而开始执行 script 标签，如果是外部 script，那么浏览器还需要一直等待其「下载」并「执行」后，再继续解析后面的 HTML。 如果请求并执行「vue.global.js」需要 3 秒，「vue-router.global.js」需要 2 秒，那么页面中的 Hello 👋🏻 ~，则至少需要 5 秒以上才会展示出来。 可以看到，script 标签会阻塞浏览器解析 HTML，如果把 script 都放在 head 中，在网络不佳的情况下，就会导致页面长期处于白屏状态。 在很久以前，一般都是将这些外联脚本，放在 body 标签的最后面，确保先解析展示 body 中的内容，然后再一个个请求执行这些外联脚本。 那有没有其他更优雅的解决方案呢？ 答案是肯定的，现在 script 标签新增了 2 个属性：defer 和 async，就是为了解决此类问题，提升页面性能的。 &lt;script defer&gt;先看一下 MDN 上的解释： 这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。有 defer 属性的脚本会阻止 DOMContentLoaded 事件，直到脚本被加载并且解析完成。 文档是直接总结了他的特性，我们先看看下面的代码，展开说说细节，加深一下理解。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;Hi&lt;/title&gt; &lt;script&gt; console.log(&quot;Howdy ~&quot;); &lt;/script&gt; &lt;script defer src=&quot;https://unpkg.com/vue@3.2.41/dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;https://unpkg.com/vue-router@4.1.5/dist/vue-router.global.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello 👋🏻 ~ &lt;/body&gt;&lt;/html&gt; 他的执行顺序是： 在控制台打印：Howdy ~ 在页面中展示：Hello 👋🏻 ~ 请求并执行 vue.global.js 请求并执行 vue-router.global.js 触发 DOMContentLoaded 事件 如果在 script 标签上设置了 defer 属性，那么在浏览器解析到这里时，会默默的在后台开始下载此脚本，并继续解析后面的 HTML，并不会阻塞解析操作。 等到 HTML 解析完成之后，浏览器会立即执行后台下载的脚本，脚本执行完成之后，才会触发 DOMContentLoaded 事件。 看起来还是蛮好理解的吧？咱们再来讨论 2 个小细节： Q1：如果 HTML 解析完成之后，设置了 defer 属性的脚本还没下载完成，会怎样？A1：浏览器会等脚本下载完成之后，再执行此脚本，执行完成之后，再触发 DOMContentLoaded 事件。 Q2：如果有多个设置了 defer 属性的脚本，那浏览器会如何处理？A2：浏览器会并行的在后台下载这些脚本，等 HTML 解析完成，并且所有脚本下载完成之后，再按照他们在 HTML 中出现的相对顺序执行，等所有脚本执行完成之后，再触发 DOMContentLoaded 事件。 最佳实践： 建议所有的外联脚本都默认设置此属性，因为他不会阻塞 HTML 解析，可以并行下载 JavaScript 资源，还可以按照他们在 HTML 中的相对顺序执行，确保有依赖关系的脚本运行时，不会缺少依赖。 在 SPA 的应用中，可以考虑把所有的 script 标签加上 defer 属性，并且放到 body 的最后面。在现代浏览器中，可以并行下载提升速度，也可以确保在老浏览器中，不阻塞浏览器解析 HTML，起到降级的作用。 注意： defer 属性仅适用于外部脚本，如果 script 脚本没有 src，则会忽略 defer 特性。 defer 属性对模块脚本（&lt;script type=&#39;module&#39;&gt;&lt;/script&gt;）无效，因为模块脚本就是以 defer 的形式加载的。 &lt;script async&gt;按照惯例，先看一下 MDN 上的解释： 对于普通脚本，如果存在 async 属性，那么普通脚本会被并行请求，并尽快解析和执行。对于模块脚本，如果存在 async 属性，那么脚本及其所有依赖都会在延缓队列中执行，因此它们会被并行请求，并尽快解析和执行。该属性能够消除解析阻塞的 Javascript。解析阻塞的 Javascript 会导致浏览器必须加载并且执行脚本，之后才能继续解析。 感觉这段描述的已经蛮清晰了，不过咱们还是先看看下面的代码，展开说说细节，加深一下理解。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;Hi&lt;/title&gt; &lt;script&gt; console.log(&quot;Howdy ~&quot;); &lt;/script&gt; &lt;script async src=&quot;https://google-analytics.com/analytics.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;https://ads.google.cn/ad.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello 👋🏻 ~ &lt;/body&gt;&lt;/html&gt; 他的执行顺序是： 在控制台打印：Howdy ~ 并行请求 analytics.js 和 ad.js 在页面中展示：Hello 👋🏻 ~ 根据网络的实际情况，以下几项会无序执行 执行 analytics.js （下载完后，立即执行） 执行 ad.js （下载完后，立即执行） 触发 DOMContentLoaded 事件（可能在在上面 2 个脚本之前，之间，之后触发） 浏览器在解析到带有 async 属性的 script 标签时，也不会阻塞页面，同样是在后台默默下载此脚本。当他下载完后，浏览器会暂停解析 HTML，立马执行此脚本。 看起来还是蛮好理解的吧？咱们再来讨论 2 个小细节： Q1：如果设置了 async 属性的 script 下载完之后，浏览器还没解析完 HTML，会怎样？A1：浏览器会暂停解析 HTML，立马执行此脚本，等执行完之后，再继续解析 HTML。 Q2：如果有多个 async 属性的 script 标签，那等他们下载完成之后，会按照代码顺序执行吗？A2：不会。执行顺序是：谁先下载完成，谁先执行。async 的特点是「完全独立」，不依赖其他内容。 最佳实践： 当我们的项目，需要集成其他独立的第三方库时，可以使用此属性，他们不依赖我们，我们也不依赖于他们。通过设置此属性，让浏览器异步下载并执行他，是个不错的优化方案。 注意： async 特性仅适用于外部脚本，如果 script 脚本没有 src，则会忽略 async 特性。 总结defer 不阻塞浏览器解析 HTML，等解析完 HTML 之后，才会执行 script。 会并行下载 JavaScript 资源。 会按照 HTML 中的相对顺序执行脚本。 会在脚本下载并执行完成之后，才会触发 DOMContentLoaded 事件。 在脚本执行过程中，一定可以获取到 HTML 中已有的元素。 defer 属性对模块脚本无效。 适用于：所有外部脚本（通过 src 引用的 script）。 async 不阻塞浏览器解析 HTML，但是 script 下载完成后，会立即中断浏览器解析 HTML，并执行此 script。 会并行下载 JavaScript 资源。 互相独立，谁先下载完，谁先执行，没有固定的先后顺序，不可控。 由于没有确定的执行时机，所以在脚本里面可能会获取不到 HTML 中已有的元素。 DOMContentLoaded 事件和 script 脚本无相关性，无法确定他们的先后顺序。 适用于：独立的第三方脚本。 另外：async 和 defer 之间最大的区别在于它们的执行时机。 One More Thing 你有没有想过，如果一个 script 标签同时设置 defer 和 async，浏览器会如何处理？ 先说结论：从表现形式上来说，async 的优先级比 defer 高，也就是如果同时存在这 2 个属性，那么浏览器将会以 async 的特性去加载此脚本。 这主要分 2 种情况： 如果是「普通脚本」，浏览器会优先判断 async 属性是否存在，如果存在，则以 async 特性去加载此脚本，如果不存在，再去判断是否存在 defer 属性。 如果是「模块脚本」，浏览器会判断 async 属性是否存在： 如果存在，浏览器会并行下载此模块和他的所有依赖模块，等全部下载完成之后，会立刻执行此脚本。 如果不存在，浏览器也会并行下载此模块和他的所有依赖模块，然后等浏览器解析完 HTML 之后，再执行此脚本。 另外需要注意的是：在模块脚本上设置 defer 属性是无效的。 一图胜千言 最后，用一张图概括一下这两个属性的加载模式吧： 思考题🤔 为什么浏览器在解析到普通的 script 标签时，必须先执行他？ 普通的 script 标签会阻塞浏览器解析 HTML，这会导致什么问题？","tags":["async","defer"],"categories":["学习笔记"]},{"title":"泛型编程（下）","path":"/2023/02/07/typescript/ts-10/","content":"介绍一些 TS 内置工具类型的用法及实现 Readonly &amp; Mutable123456789101112131415161718192021type Person = &#123; id: number; name: string; age: number &#125;;type Readonly&lt;T&gt; = &#123; readonly [K in keyof T]: T[K];&#125;;type X1 = Readonly&lt;Person&gt;;// &#123;// readonly id: number;// readonly name: string;// readonly age: number;// &#125;type Mutable&lt;T&gt; = &#123; -readonly [K in keyof T]: T[K];&#125;;type X9 = Mutable&lt;Readonly&lt;Person&gt;&gt;;// &#123;// id: number;// name: string;// age: number;// &#125; 注意： Mutable 并不是 TS 内置的函数 -readonly [] 表示去掉属性前面的 Readonly Partial &amp; Required123456789101112131415161718192021type Person = &#123; id: number; name: string; age: number &#125;;type Partial&lt;T&gt; = &#123; [K in keyof T]?: T[K];&#125;;type X2 = Partial&lt;Person&gt;;// &#123;// id?: number;// name?: string;// age?: number;// &#125;type Required&lt;T&gt; = &#123; [K in keyof T]-?: T[K];&#125;;type X3 = Required&lt;Person&gt;;// &#123;// id: number;// name: string;// age: number;// &#125; 注意 -?，表示去掉属性的可选，变为必选 Exclude &amp; Extract12345type Exclude&lt;A, B&gt; = A extends B ? never : A;type X5 = Exclude&lt;1 | 2 | 3, 1 | 2&gt;; // 3type Extract&lt;A, B&gt; = A extends B ? A : never;type X6 = Extract&lt;1 | 2 | 3, 2 | 4&gt;; // 2 按照之前讲的乘法分配律，有如下理解过程： 12345678type X5 = 1 | 2 | 3 extends 1 | 2 ? never : Atype X5 = | 1 extends 1 | 2 ? never : 1 // never| 2 extends 1 | 2 ? never : 2 // never| 3 extends 1 | 2 ? never : 3 // 3type X5 = never | never | 3 // 3 X6 的理解过程同 X5，这里不赘述 Omit &amp; Pick12345678910111213type Person = &#123; id: number; name: string; age: number &#125;;type Omit&lt;T, Key extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, Key&gt;&gt;;// 或者type Omit&lt;T, Key&gt; = &#123; [K2 in keyof T as (K2 extends Key ? never : K2)]: T[K2];&#125;;type X7 = Omit&lt;Person, &#x27;name&#x27; | &#x27;age&#x27;&gt;; // &#123; id: number &#125;type Pick&lt;T, Key extends keyof T&gt; = &#123; [K2 in Key]: T[K2];&#125;;type X8 = Pick&lt;Person, &#x27;name&#x27; | &#x27;age&#x27;&gt;; // &#123; name: string; age: number &#125; Key extends keyof T 是一个泛型约束，约束所传的 key 必须包含在 keyof T 中，即必须是 &#39;id&#39; | &#39;name&#39; | &#39;age&#39; 的子集 Record12345type Record&lt;Key extends string | number | symbol, Value&gt; = &#123; [k in Key]: Value;&#125;;type X4 = Record&lt;string, string&gt;; // &#123; [x: string]: string &#125; ReturnType12345function f(a: number, b: number) &#123; return &#x27;a + b&#x27;&#125;type F = ReturnType&lt;typeof f&gt; // string 其他这里推荐一个用于练习 TS 类型体操的 repo：TypeScript 类型体操姿势合集 看看别人的体操： 用 TypeScript 类型运算实现一个中国象棋程序 TypeScript 类型体操天花板，用类型运算写一个 Lisp 解释器","tags":["TypeScript","泛型"],"categories":["学习笔记","TypeScript"]},{"title":"泛型编程（上）","path":"/2023/02/06/typescript/ts-9/","content":"泛型就像函数函数 12const f = (a, b) =&gt; a + bconst result = f(1, 2) // 3 泛型 12type F&lt;A, B&gt; = A | Btype Result = F&lt;string, number&gt; // string | number 泛型就像函数 函数的本质是什么 函数的本质是推后执行的、部分待定的代码 123456789101112131415// 立即执行console.log(1)// 推后一步执行const f1 = () =&gt; console.log(1)f1()// 推后两步执行const f2 = () =&gt; console.log(1)console.log(2)f2()// 部分待定的const f3 = (fn, n) =&gt; fn(n) // 参数待定f3(console.log, 3) 泛型的本质是什么 泛型的本质是推后执行的、部分待定的类型 没有泛型的类型系统，就如同没有函数的编程语言 什么时候需要泛型当我们需要准确的定义返回值的类型的时候，就需要泛型 这时候你可能会说，做类型收窄不就行了吗？就像下面这样 12345678910function echo(whatever: number | string | boolean) &#123; switch (typeof whatever) &#123; case &#x27;number&#x27;: return whatever; case &#x27;string&#x27;: return whatever; case &#x27;boolean&#x27;: return whatever; &#125;&#125; 但是你会发现，这样写得到的返回值类型是不准确的 123const a = echo(233);// 我们期望 a 的类型是 233// 但 a 的类型却是 string | number | boolean 这时候，泛型就派上用场了 123456function echo&lt;T&gt;(whatever: T): T &#123; return whatever;&#125;const a = echo(233);// a 的类型为 233 简单泛型示例12345678910type Union&lt;A, B&gt; = A | B;type Union3&lt;A, B, C&gt; = A | B | C;type Intersect&lt;A, B&gt; = A &amp; B;type Intersect3&lt;A, B, C&gt; = A &amp; B &amp; C;interface List&lt;A&gt; &#123; [index: number]: A;&#125;interface Hash&lt;V&gt; &#123; [key: string]: V;&#125; 条件类型（Conditional Types） T extends string 可理解为 T &lt;= string（T 包含于 string） 123456type R1 = LikeString&lt;&#x27;hi&#x27;&gt; // truetype R2 = LikeString&lt;true&gt; // falsetype S1 = LikeNumber&lt;2333&gt; // 1type S2 = LikeNumber&lt;false&gt; // 2type T1 = LikePerson&lt;&#123; name: &#x27;ClariS&#x27;, age: 18 &#125;&gt; // yestype T2 = LikePerson&lt;&#123; age: 1 &#125;&gt; // no 泛型中的特殊运算规则 现有如下泛型 ToArray 1type ToArray&lt;T&gt; = T extends unknown ? T[] : never; 问：type Result = ToArray&lt;string | number&gt; 的类型是什么？ 直接说答案：Result 为 string[] | number[] 你可能会疑惑，按照一般的理解，string | number 是包含于 unknown 的，那么 Result 就应该是 (string | number)[] 呀 按照通常的理解是没错，但因为这是在泛型中，因此规则会有些许不同 可以按照如下拆分过程来进行理解记忆： 1234type Result = ToArray&lt;string | number&gt;;// type Result = (string | number) extends unknown ? ...// type Result = (string extends unknown ? ...) | (number extends unknown ? ...)// type Result = string[] | number[] 即泛型中的联合类型会分开进行运算，这就好像是乘法中的分配率 (A + B) X C = A X C + B X C 再问：type Result2 = ToArray&lt;never&gt; 的类型是什么？ 答案是 never 同样按照一般的理解，通常情况下（非泛型中），never 是包含于 unknown 的，那么 Result 应该是 never[] 才对 但 Result 在此处却为 never 1type Result = ToArray&lt;never&gt;; // never 即泛型中的 never 进行任何运算都只会得到 never，这就好像是乘法中的零 0 X C = 0 注意：以上讨论的规则只对泛型有效 在泛型中使用 keyofkeyof 能获取对象的所有 key，并将获取到的 key 做一个联合（并集） 1234type Person = &#123; name: string; age: number &#125;;type GetKeys&lt;T&gt; = keyof T;type Result = GetKeys&lt;Person&gt;;// ^-- &#x27;name&#x27; | &#x27;age&#x27; 常和映射类型一起使用 123type Readonly&lt;T&gt; = &#123; readonly [K in keyof T]: T[K];&#125;; 在泛型中使用 extends keyof12345type Person = &#123; name: string; age: number &#125;;type GetKeyType&lt;T, K extends keyof T&gt; = T[K];type Result1 = GetKeyType&lt;Person, &#x27;name&#x27;&gt;; // stringtype Result2 = GetKeyType&lt;Person, &#x27;age&#x27;&gt;; // numbertype Result3 = GetKeyType&lt;Person, &#x27;name&#x27; | &#x27;age&#x27;&gt;; // string | number K extends keyof T 的写法称为泛型约束，GetKeyType 第二个参数 k 的类型必须包含于 string | number","tags":["TypeScript","泛型"],"categories":["学习笔记","TypeScript"]},{"title":"深入函数：函数重载、this 和 as const","path":"/2023/02/03/typescript/ts-8/","content":"函数重载（overload）重载允许一个函数在接受不同数量或类型的参数时，作出不同的处理 1234567891011121314151617function createDate(n: number): Date;function createDate(year: number, month: number, date: number): Date;// 中间不能写其他代码，函数类型声明后面只能接函数的实现function createDate(a: number, b?: number, c?: number): Date &#123; if (a !== undefined &amp;&amp; b !== undefined &amp;&amp; c !== undefined) &#123; return new Date(a, b, c); &#125; else if (a !== undefined &amp;&amp; b === undefined &amp;&amp; c === undefined) &#123; return new Date(a); &#125; else &#123; throw new Error(&#x27;传参错误&#x27;); &#125;&#125;createDate(1677772800000);createDate(2023, 2, 3); 关于函数重载： 重载的思想来自于 Java 或 C#，因为它们都不支持联合类型 重载是为了使同名函数可以接受不同类型的参数 不是非得使用重载，即使不用函数重载也可以实现上述的功能123456789function createDateFromNumber(n: number): Date &#123; return new Date(n);&#125;function createDateFromYMD(year: number, month: number, date: number): Date &#123; return new Date(year, month, date);&#125;createDateFromNumber(1677772800000);createDateFromYMD(2023, 2, 3); 复杂度守恒，你不可能把复杂度凭空抹除掉，因此你只能选择把复杂度留给自己或者抛给用户。比如上面的例子中，使用函数重载就是把复杂度留给自己；而提供两个函数供用户选择就是把复杂度留给用户。 指定 this 的类型1234567891011121314151617181920type Person = &#123; name: string &#125;;function f(this: Person, n: number) &#123; console.log(this.name + n);&#125;// 1. person.f(1)const p: Person &amp; &#123; f: typeof f &#125; = &#123; name: &#x27;ClariS&#x27;, f &#125;;p.f(1);// 2. f.call(person, 1)const p2: Person = &#123; name: &#x27;ClariS&#x27; &#125;;f.call(p2, 1);// 3. f.apply(person, [1])const p3: Person = &#123; name: &#x27;ClariS&#x27; &#125;;f.apply(p3, [1]);// 4. f.bind(person)(1)const p4: Person = &#123; name: &#x27;ClariS&#x27; &#125;;const newF = f.bind(p4);newF(1);// 或newF.bind(null, 1); 剩余参数1234567function sum(name: string, ...array: number[]) &#123; console.log(name); return array.reduce((result, n) =&gt; result + n, 0);&#125;sum(&#x27;one&#x27;, 1);sum(&#x27;two&#x27;, 1, 2);sum(&#x27;three&#x27;, 1, 2, 3); 注意，剩余参数只能是最后一个参数 展开参数12345678function sum(...array: number[]) &#123; f.apply(null, array); // f(array[0], array[1], array[2], array[3], ...) f(...array);&#125;function f(...array: number[]) &#123; console.log(array);&#125; 常量断言（as const）TS 会区别对待可修改和不可修改的值的类型推断 例如下面的 immutableString 会被推断成单值类型 &#39;ClariS&#39; 而 mutableString 则会被推断成通用的 string 类型 12const immutableString = &#x27;ClariS&#x27;; // &#x27;ClariS&#x27;let mutableString = &#x27;vivy&#x27;; // string 而在一般的对象中，由于对象的属性都具有可修改性，TS 都会对它们「从宽」类型推断，例如下面的 prop 的类型被推断为 string 123const obj = &#123; prop: &#x27;xxx&#x27; // string&#125;; 根本原因在于 TS 会根据一个值在后续的逻辑中是否可能被修改而给出不同的类型推断结果： 对于有可能被修改的值，TS 采用较为宽松的类型推断策略，即把上述 mutableString，obj.props 推断为较为宽泛的 string 类型，这使未来可能出现的赋值具有更大的灵活度 对于不可能被重新赋值的值，TS 采用较为严格的类型推断策略，即把上述 immutableString 推断为单值类型 &#39;ClariS&#39;，这样未来把immutableString 赋值给别的变量时，出现类型检查错误的可能性更小 关于这部分内容，详细可参考文章TypeScript夜点心：类型推断的策略 TS 常量断言 常量断言可以把一个值标记为一个不可篡改的常量，从而让 TS 以最严格的策略来进行类型推断 还是使用上述的例子，给他们分别加上 as const 后类型推断如下 12345let mutableString = &#x27;vivy&#x27; as const; // &#x27;vivy&#x27;const obj = &#123; prop: &#x27;xxx&#x27; as const // &#x27;xxx&#x27;&#125;; 再看看其他的例子 12345const array1 = [1, &#x27;hi&#x27;]; // (string | number)[]array1.push(2); // 不报错const array2 = [1, &#x27;hi&#x27;] as const; // readonly [1, &quot;hi&quot;]array2.push(2); // 报错 从以上例子中可以看出，as const 会把类型推窄，并给类型加上 readonly 关于这部分内容，详细可参考文章TypeScript 夜点心：常量断言 const 与 as const 的区别 as const 中的 const 与我们声明常量时使用的 const 有什么区别呢？ 其实两者无论是语法还是语义，都相当不同： const 常量声明是 ES6 的语法，对 TS 而言，它只能反映该常量本身是不可被重新赋值的，它的子属性仍然可以被修改，故 TS 只会对它们做松散的类型推断 as const 是 TS 的语法，它告诉 TS 它所断言的值以及该值的所有层级的子属性都是不可篡改的，故对每一级子属性都会做最严格的类型推断 more about the function完整示例1234567891011121314type Config = &#123; url: string; method: &#x27;GET&#x27; | &#x27;POST&#x27; | &#x27;PATCH&#x27; | &#x27;DELETE&#x27;; data?: unknown; headers?: unknown;&#125;;function ajax1(&#123; url, method, ...rest &#125;: Config = &#123; method: &#x27;GET&#x27;, url: &#x27;&#x27; &#125;) &#123; console.log(url, method, rest);&#125;function ajax2(&#123; url, method, ...rest &#125; = &#123; method: &#x27;GET&#x27;, url: &#x27;&#x27; &#125; as Config) &#123; console.log(url, method, rest);&#125; 类型 Config 可以写在左边，也可以写在右边 void 返回值类型123456789101112131415161718function f1(): void &#123; return;&#125;function f2(): void &#123; return undefined;&#125;function f3(): void &#123;&#125;function f4(): void &#123; return null; // 报错：Type &#x27;null&#x27; is not assignable to type &#x27;void&#x27;&#125;type F5 = () =&gt; void;const f5: F5 = () =&gt; &#123; return;&#125;;","tags":["TypeScript","as const","函数重载"],"categories":["学习笔记","TypeScript"]},{"title":"深入函数：声明、参数、返回值","path":"/2023/02/01/typescript/ts-7/","content":"深入对象语法描述对象的属性使用接口描述对象 12345678type Person = &#123; name: string&#125;// 或者interface Person &#123; name: string&#125; Person 的子集为 12345678910type Children = | &#123; name: string, age: string &#125; | &#123; name: string, age: number &#125; | &#123; name: string, age: boolean &#125; | &#123; name: string, age: null &#125; | &#123; name: string, age: undefined &#125; | &#123; name: string, age: object &#125; | &#123; name: string, gender: string &#125; | &#123; name: string, gender: number &#125;// 以下省略一万行 索引签名（Index Signature）12345678type Hash = &#123; [k: string]: unknown length: number&#125;type List = &#123; [k: number]: unknown length: number&#125; 映射类型（Mapped Type）123456type Hash = &#123; [k in string]: unknown&#125;type List = &#123; [k in number]: unknown&#125; 映射类型多用于泛型 123type Readonly&lt;T&gt; = &#123; readonly [K in keyof T]: T[K];&#125;; 需要注意的是，如果使用了映射类型，对象中就不能再有其他属性了，这点与索引签名有所不同 12345type Hash = &#123; [k in string]: unknown length: number // ^-- A mapped type may not declare properties or methods.&#125; 可选属性可选属性的含义是该属性可以不存在 12345interface InputProps &#123; defaultValue?: string; value?: boolean; onChange?: () =&gt; void;&#125; value?: boolean 可近似的理解成 value: boolean | undefined，但是在声明对象属性时，value? 可以不写，而 value 必须写 只读属性有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性 1234567891011interface User &#123; readonly id: number; readonly name: string; readonly scores: number[]; age?: number;&#125;const u: User = &#123; id: 1, name: &#x27;ClariS&#x27;, scores: [87, 65],&#125;; 使用 readonly 定义的属性初始化后不能被重新赋值 1234u.id = 2;// ^-- Cannot assign to &#x27;id&#x27; because it is a read-only property.tsu.scores = [100, 65]// ^-- Cannot assign to &#x27;scores&#x27; because it is a read-only property.ts 但是并没有对 scores 内部的属性做只读约束（只读约束只在第一层） 12u.scores[0] = 100;// 不报错 深入函数语法对象的语法全都适用于函数 1234567type F = &#123; (a: number, b: number): number; readonly count?: number[];&#125;;const fn: F = (x, y) =&gt; x + y;fn.count[0] = 1; 声明函数的四种方式先写类型再赋值12type F1 = (a: number, b: number) =&gt; number;const f1: F1 = (a, b) =&gt; a + b; 箭头函数1234const f2 = (a: number, b: number): number =&gt; &#123; return a + b;&#125;;type F2 = typeof f2; 普通函数1234function f3(this: unknown, a: number, b: number): number &#123; return a + b;&#125;type F3 = typeof f3; 匿名普通函数1234const f4 = function (this: unknown, a: number, b: number): number &#123; return a + b;&#125;;type F4 = typeof f4; 构造函数12const f5 = new Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;return a + b&#x27;);type F5 = typeof f5; 几乎没人会这么写吧 类型谓词之前在联合类型中讲过，可以使用类型谓词 is 来收窄类型，当时只简单提了一下不推荐使用箭头函数，这里说一下为什么 123456789101112type Person = &#123; name: string &#125;type Animal = &#123;&#125;function isPerson(x: Person | Animal): x is Person &#123; return &#x27;name&#x27; in x&#125;function fn(a: Person | Animal) &#123; if (isPerson(a)) &#123; a // Person &#125;&#125; 可以使用箭头函数实现 isPerson 1const isPerson = (x: Person | Animal): x is Person =&gt; &#x27;name&#x27; in x 但需要注意的是，如果使用的是箭头函数，不能先写类型再赋值 123type A = (x: Person | Animal) =&gt; x is Personconst isPerson: A = x =&gt; &#x27;name&#x27; in x// ^--- Type &#x27;(x: Person | Animal) =&gt; boolean&#x27; is not assignable to type &#x27;A&#x27; 在右边加上 x is Person 就不报错了 12type A = (x: Person | Animal) =&gt; x is Personconst isPerson: A = (x): x is Person =&gt; &#x27;name&#x27; in x 参数相关语法可选参数123456789function addEventListener(eventType: string, fn: unknown, useCapture?: boolean) &#123; if (useCapture === undefined) &#123; useCapture = false &#125; // 浏览器实现 console.log(eventType, fn, useCapture)&#125;addEventListener(&#x27;click&#x27;, () =&gt; 1) 参数默认值123456function addEventListener(eventType: string, fn: unknown, useCapture = false) &#123; // 浏览器实现 console.log(eventType, fn, useCapture)&#125;addEventListener(&#x27;click&#x27;, () =&gt; 1) 参数也可以是函数12345678910111213function addEventListener( eventType: string, fn: (this: HTMLElement, e: Event) =&gt; void, useCapture = false) &#123; // 浏览器实现，这里只提供伪代码 const element = &#123;&#125; as HTMLElement; const event = &#123;&#125; as Event; fn.call(element, event); console.log(eventType, fn, useCapture);&#125;addEventListener(&#x27;click&#x27;, () =&gt; 1); 返回值也可以是函数123456const add = (a: number, b: number) =&gt; a + btype CreateAdd = (x: number) =&gt; (y: number) =&gt; numberconst createAdd: CreateAdd = a =&gt; b =&gt; a + badd(6, 14)createAdd(6)(14)","tags":["TypeScript","映射类型","索引签名"],"categories":["学习笔记","TypeScript"]},{"title":"类型兼容与赋值","path":"/2023/01/30/typescript/ts-6/","content":"为什么要有类型兼容因为实际工作中，往往无法做到类型一致 比如在上面的 JS 代码中，假设 runTask 函数的参数只接受具有 a、b、c 这 3 个 key 的对象，但在一般情况下，即使我们多传一个 d，也不会报错 你有的，我都有，则我能代替你；y 有的，x 都有，则 x 兼容 y 简单类型的兼容类型小的兼容类型大的 注意：图中的大小圆应当是包含关系，即小圆应该在大圆内部，此处为了展示清晰将小圆挪到了外部，后面的图示亦如此 集合 hi 小于集合 A，因此将 hi 赋值给 a 不报错 普通对象的兼容属性多的兼容属性少的 对象属性越多，限制越多，表示的集合范围越小，所以其实还是类型小的兼容类型大的 注意：对象兼容的前提是必须得存在共同的属性，此处两个对象共同的属性是 name 和 age 兼容的情况下，作为参数也不报错 123456789type Person = &#123; name: string; age: number &#125;let user = &#123; name: &#x27;ClariS&#x27;, age: 18, id: 1, email: &#x27;xxx@yyy.com&#x27; &#125;let p: Person = user // 不报错const f1 = (p: Person) =&gt; &#123; console.log(p)&#125;f1(user) // 不报错 接口的兼容子接口兼容父接口 函数的兼容函数的兼容比较复杂，需要考虑参数和返回值 参数个数不同存在相同类型的参数的函数，参数少的兼容参数多的 如何理解上图中的兼容关系？（图中绿色箭头代表可以兼容，红色箭头表示不能兼容） 如何理解上图中的代码？（图中绿色箭头代表可以兼容，红色箭头表示不能兼容）主要看划线的右边参数的部分：从上往下看，箭头全绿（a 和 b 都是 number）从下往上看，存在红色的箭头（参数 s 没有可以兼容的参数）因此 接受一个参数的函数 兼容 接受两个参数的函数，反过来则不行 为什么容忍参数变少呢？从下例中可以窥探一二 在 JS 中，少写参数是很常见的事情 参数类型不同对参数要求少的兼容对参数要求多的 和参数的兼容关系正好相反 从前面的例子我们知道，MyMouseEvent 是兼容 MyEvent 的，这里函数的兼容关系就正好反过来了。 返回值不同不考虑参数类型的情况下，函数的兼容关系和返回值的兼容关系保持一致 思考：如果函数的参数和返回值同时存在且兼容关系相反呢？ 实际工作中的函数12345678910111213141516171819202122232425interface Event &#123; timestamp: number;&#125;interface MyMouseEvent extends Event &#123; x: number; y: number;&#125;function listenEvent(eventType: string, handler: (n: Event) =&gt; void) &#123; /* ... */&#125;// 我们希望这样用，但会报错listenEvent(&quot;click&quot;, (e: MyMouseEvent) =&gt; console.log(e.x + &quot;,&quot; + e.y));// 因此只能这样用listenEvent(&quot;click&quot;, (e: Event) =&gt; console.log((e as MyMouseEvent).x + &quot;,&quot; + (e as MyMouseEvent).y));// 还可以这么用listenEvent(&quot;click&quot;, ((e: MyMouseEvent) =&gt; console.log(e.x + &quot;,&quot; + e.y)) as ( e: Event) =&gt; void);// 这个就太离谱了，也会报错listenEvent(&quot;click&quot;, (e: number) =&gt; console.log(e)); 在不关闭 TS 严格检查的情况下，可以通过设置 &quot;strictFunctionTypes&quot;: false 来避免函数报错 12345678// tsconfig.json&#123; &quot;compilerOptions&quot;: &#123; &quot;strict&quot;: true, &quot;strictFunctionTypes&quot;: false, ... &#125;&#125; 设置 strictFunctionTypes: false 后 特殊类型的兼容顶类型(Top Type) 与 底类型(Bottom Type)","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TS 中的类型运算：交叉类型","path":"/2023/01/17/typescript/ts-5/","content":"交叉类型（交集）英文全称：intersection types 12type A = string &amp; number;// ^-- never 交叉类型一般多用于对象，而不用于简单类型 123456type 有左手的人 = &#123; left: string &#125;const b = &#123; left: &#x27;yse&#x27;, right: &#x27;yes&#x27; &#125;const a1: 有左手的人 = b // 不报错const a2: 有左手的人 = &#123; left: &#x27;yse&#x27;, right: &#x27;yes&#x27; &#125; // 报错 可用于接口求交集 1234567interface Colorful &#123; color: string;&#125;interface Circle &#123; radius: number;&#125;type ColorfulCircle = Colorful &amp; Circle; 可用于模拟继承 1234567891011121314type Person = &#123; name: string; age: number;&#125;;type User = Person &amp; &#123; id: number; email: string;&#125;;const u: User = &#123; id: 1, name: &#x27;ClariS&#x27;, age: 18, email: &#x27;xxx@yyy.com&#x27;&#125;; 交叉类型的特殊情况123456789101112131415type Person = &#123; name: string; age: number; id: string;&#125;;type User = Person &amp; &#123; id: number; email: string;&#125;;const u: User = &#123; id: 1 as never, // 此处 id 的类型为 never name: &#x27;ClariS&#x27;, age: 18, email: &#x27;xxx@yyy.com&#x27;,&#125;; 当把上面 id 的类型从一个比较大的类型，变为比较小的类型时，整个 User 的类型都为 never 12345678910111213141516171819type Person = &#123; name: string; age: number; id: &#x27;A&#x27;;&#125;;type User = Person &amp; &#123; id: &#x27;B&#x27;; email: string;&#125;;const u: User = &#123; // User = never id: 1, name: &#x27;ClariS&#x27;, age: 18, email: &#x27;xxx@yyy.com&#x27;,&#125;;type A = &#123; kind: &#x27;A&#x27;; name: string &#125;;type B = &#123; kind: &#x27;B&#x27;; age: number &#125; &amp; A;// ^-- never 上面的例子中，当对象属性发生冲突时，type 只会把类型变为 never，但类型并不报错，只在使用时报错；而 interface 会直接报错 12345678910interface Person &#123; name: string; age: number; id: string;&#125;interface User extends Person &#123; // ^-- Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27; id: number; email: string;&#125; 函数的交集会得到一个参数的并集 123456789101112type A = &#123; method: (a: number) =&gt; void;&#125;;type B = &#123; method: (a: string) =&gt; void;&#125; &amp; A;const b: B = &#123; method(a) &#123; a; // number | string &#125;&#125;; 总结：交叉类型常用于有交集的类型 A、B，如果 A、B 无交集，可能得到 never，也可能只是属性为 never","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TS 中的类型运算：联合类型","path":"/2023/01/12/typescript/ts-4/","content":"TS &#x3D; JS + 类型系统 JS 可以对值进行加减运算，如果把 TS 的类型系统当作一门语言，TS 也同样可以对类型进行各种运算 联合类型（并集）英文全称：union types type A = &#123; name: string &#125; 表示 name 为 string 的所有对象但不要错误地认为这些对象只有 name 这一个 key比如对象 &#123; name: &#39;ClariS&#39;; age: 18 &#125; 也是属于 A 类型的即 A 类型的对象可以有 age，也可以没有 age同理，type = &#123; age: number &#125; 表示 age 为 number 的对象，这些对象的 name 可以为空，也可以不为空 如何使用联合类型？12345const f1 = (a: number | string) =&gt; &#123; &#x27;既不能把 a 当作 number&#x27; &#x27;也不能把 a 当做 string&#x27; &#x27;那么，怎么使用 a 变量呢？&#x27;&#125; 如果不拆开类型，就只能使用 number 和 string 共同拥有的方法或属性，比如 toString() 因此要使用联合类型，就得先区分类型，也就是进行类型收窄(Narrowing) 如何进行类型收窄？使用 typeof123456789const f1 = (a: number | string) =&gt; &#123; if (typeof a === &#x27;number&#x27;) &#123; a.toFixed(2); &#125; else if (typeof a === &#x27;string&#x27;) &#123; parseFloat(a).toFixed(2); &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; typeof 的局限性：无法区分数组、日期、普通对象以及 null（返回值都是 &quot;object&quot;） 使用 instanceof123456789const f1 = (a: Array&lt;Date&gt; | Date) =&gt; &#123; if (a instanceof Date) &#123; a.toISOString(); &#125; else if (a instanceof Array) &#123; a[0].toISOString(); &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; instanceof 的局限性： 不支持基础类型，string、number、bigint、boolean、symbol、undefined 不支持 TS 独有的类型123456789type Person = &#123; name: string &#125;;const f1 = (a: Person | Person[]) =&gt; &#123; if (a instanceof Person) &#123; // ^--- 报错：type 不能用作 value &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; 使用 in 操作符123456789type Person = &#123; name: string &#125;;const f1 = (a: Person | Person[]) =&gt; &#123; if (&#x27;name&#x27; in a) &#123; a; // Person &#125; else &#123; a; // Person[] &#125;&#125;; in 操作符的局限性：只适用于部分对象 比如当判断的两个对象存在相同的 key （存在相同 key，其中一个对象的 key 可能不存在），或不为键值对形式的对象（比如日期、正则、函数等）时，则无法使用 in 操作符来收窄类型 使用 JS 中判断类型的函数123456789const f1 = (a: string | string[]) =&gt; &#123; if (Array.isArray(a)) &#123; a.join(&#x27; &#x27;).toString(); &#125; else if (typeof a === &#x27;string&#x27;) &#123; parseFloat(a).toFixed(2); &#125; else &#123; throw new Error(&#x27;Never do this&#x27;); &#125;&#125;; 使用逻辑12345678910111213141516171819202122const f1 = (a?: string[]) =&gt; &#123; if (a) &#123; a; // string[] &#125; else &#123; a; // undefined &#125;&#125;;const f2 = (a: string | number) =&gt; &#123; a = 1; a; // number&#125;;const f3 = (x: string | number, y: string | boolean) =&gt; &#123; if (x === y) &#123; x; // string y; // string &#125; else &#123; x; // string | number y; // string | number &#125;&#125;; 使用类型谓词 is上述所有的类型收窄方法都是通过 JavaScript 来实现的，有没有区分类型的万全之法？ 12345678910111213141516type Rect = &#123; height: number; width: number &#125;;type Circle = &#123; center: [number, number]; radius: number &#125;;// 推荐使用普通函数实现 isRect，而不使用箭头函数function isRect(x: Rect | Circle): x is Rect &#123; return &#x27;height&#x27; in x &amp;&amp; &#x27;width&#x27; in x;&#125;const f1 = (a: Rect | Circle) =&gt; &#123; if (isRect(a)) &#123; // `isRect(a)` 判断 a 是不是 Rect a; // Rect &#125; else &#123; a; // Circle &#125;&#125;; 优点：支持所有 TS 类型缺点：需要自己实现，挺麻烦的 有没有更简单的办法？ 可辨别联合12345678910111213interface Circle &#123; kind: &quot;circle&quot;; radius: number; &#125;interface Square &#123; kind: &quot;square&quot;; sideLength: number; &#125;type Shape = Circle | Squareconst f1 = (shape: Shape) =&gt; &#123; if (shape.kind === &#x27;circle&#x27;) &#123; shape // Circle &#125; else if (shape.kind === &#x27;square&#x27;) &#123; shape // Square &#125; else &#123; shape // never &#125;&#125; 让复杂类型的收窄变成简单类型的对比 对于类型 T = A | B | C | D | ...，有以下要求： A、B、C、D... 有相同属性 kind 或其他 kind 的类型是简单类型 各类型中的 kind 可区分 则称 T 为可辨别联合 一句话总结：具有同名、可辨别的简单类型的 key 的联合类型，称为可辨别联合 使用断言可以使用 as 进行强制的类型收缩 1234567interface Circle &#123; kind: &quot;circle&quot;; radius: number; &#125;interface Square &#123; kind: &quot;square&quot;; sideLength: number; &#125;type Shape = Circle | Squareconst f1 = (shape: Shape) =&gt; &#123; (shape as Circle).radius = 4&#125; any 等于所有类型的联合吗？这里直接给出结论：any 不等于所有类型的联合 注意：这里的所有类型不包括 never unknown any void 用反证法可以证明： 只要类型发生了联合，就只能使用它们共同拥有的属性或方法（想要使用各自的方法就必须做类型收窄） 但是使用 any 之后，不做类型收窄可以使用所有类型的方法 说明 any 不是所有类型的联合 1234567891011const f1 = (a: string | number) =&gt; &#123; a.toString(); a.toFixed(); // 报错 a.split(); // 报错&#125;;const f2 = (a: any) =&gt; &#123; a.toString(); a.toFixed(); a.split();&#125;; 且 ts 的绝大部分规则对 any 不生效，但有一种特殊情况，any 无法赋值给 never 那什么等于所有类型的联合呢？ 1234567891011121314151617const f1 = (a: unknown) =&gt; &#123; if (a instanceof Date) &#123; a; // Date &#125;&#125;;type Rect = &#123; height: number; width: number &#125;;type Circle = &#123; center: [number, number]; radius: number &#125;;function isRect(x: Rect | Circle): x is Rect &#123; return &#x27;height&#x27; in x &amp;&amp; &#x27;width&#x27; in x;&#125;const f2 = (a: unknown) =&gt; &#123; if (isRect(a)) &#123; a; // Rect &#125;&#125;; 可以看出，unknown 是可以收窄到任何类型的，因此，unknown 就是所有类型的联合","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TypeScript 中的类型（下）","path":"/2022/12/29/typescript/ts-3/","content":"何时使用 enum 实例一：用 A.todo 将数字映射成一个有意义的语法 实例二：可以用于表示权限 以上代码中，Manage = Read | Write | Delete 是 JS 中的二进制操作（二进制或运算符），0b 在 JS 中表示二进制 何时用 enum 会显得很呆？ 如上所示，将 &#39;apple&#39; 映射为 Fruit.apple 完全是多此一举，还是别再用 enum 来映射字符串了吧ヾ(-_-;) 只推荐用 enum 对数字做映射，除此之外都不推荐使用 enum 何时使用 typeTS 中的 Type 叫作类型别名，Type Aliases，其实就是给其他类型取个名字，示例如下： 1234567891011type Name = string;type FalseLike = &#x27;&#x27; | 0 | false | null | undefined;type Point = &#123; x: number; y: number &#125;;type Points = Point[];type Line = [Point, Point];type Circle = &#123; center: Point; radius: number &#125;;type Fn = (a: number, b: number) =&gt; number;type FnWithProps = &#123; (a: number, b: number): number; prop1: number;&#125;; 如何体现出 type 只是一个别名？ 12type X = &#123; x: number &#125;type A = X 以上 TS 代码中 A 的类型是？由于 type 只是一个别名，并不是声明了一个真正的类型，此处 A 的类型为 { x: number } 如何理解 type FalseLike = &#39;&#39; | 0 | false | null | undefined？ 上面的五个值其实都是类型，类型可以理解为集合，因此可以看作五个集合并在一起，每个集合中只包含一个值；另外，不支持 NaN 作为类型，因为 NaN 表示的是一个值而不是类型 带有属性的函数的声明方式 12345678type FnWithProps = &#123; (a: number, b: number): number; props: string;&#125;;const fn: FnWithProps = (x, y) =&gt; x * y;fn.props = &#x27;hello&#x27;; 多用于 React 中 何时使用 interface声明接口，用于描述对象的属性 declare the shapes of objects 12345interface Data &#123; [k: string]: string; &#125;interface Point &#123; x: number; y: number; &#125;interface Points extends Array&lt;Point&gt; &#123;&#125;interface Fn &#123; (x: number, y: number): number; &#125;interface Date2 extends Date &#123;&#125; type 如何实现继承？ 123456interface X &#123; age: number; &#125;type Al = Array&lt;string&gt; &amp; &#123; name: string; &#125; &amp; X;// A1几乎等价于A2interface A2 extends Array&lt;string&gt;, X &#123; name: string; &#125; type 和 interface 的区别区别一interface 只能描述对象，而 type 能描述所有数据类型 区别二type 并不会创建一个新的类型，只是创建了一个类型别名；而 interface 则是类型声明，会创建一个新的类型 12345type A = string;type B = A; // B 的类型是 stringinterface D extends Date &#123;&#125;type E = D; // E 的类型是 D 区别三type 不可重新赋值，因此不能存在同名的 type；而 interface 可以声明同名的类型，同名的 interface 会自动合并 123456type A = string; // 报错 Duplicate identifier &#x27;A&#x27;type A = number; // 报错 Duplicate identifier &#x27;A&#x27;interface X &#123; name: string; &#125;interface X &#123; age: number; &#125;const x: X = &#123; name: &#x27;ClariS&#x27;, age: 18 &#125;; // X 为 &#123; name: string; age: number; &#125; 使用 type 无法进行类型扩展，因此 对外 API 尽量用 interface，方便用户进行类型扩展；对内 API 尽量用 type，防止代码分散 扩展 interface 的实例： 扩展 axios 1234567import &#123; AxiosRequestConfig &#125; from &#x27;axios&#x27;;declare module &#x27;axios&#x27; &#123; export interface AxiosRequestConfig &#123; _autoLoading?: boolean; _mock?: string; &#125;&#125; 扩展 string 12345declare global &#123; interface String &#123; padZero(length: number): string; &#125;&#125; void12345678910111213141516171819type Fn = () =&gt; void;const fn: Fn = () =&gt; &#123; return &#x27;xxx&#x27;; // 不报错&#125;;const x = fn();console.log(x.toString()); // 报错：Property &#x27;toString&#x27; does not exist on type &#x27;void&#x27;.console.log((x as any).toString()); // 不报错function fn1(a: number): void &#123; return &#x27;xxx&#x27;; // 报错：Type &#x27;string&#x27; is not assignable to type &#x27;void&#x27;.&#125;const fn2 = (a: number): void =&gt; &#123; return &#x27;xxx&#x27;; // 报错：Type &#x27;string&#x27; is not assignable to type &#x27;void&#x27;.&#125;;","tags":["TypeScript","enum"],"categories":["学习笔记","TypeScript"]},{"title":"TypeScript 中的类型（上）","path":"/2022/12/28/typescript/ts-2/","content":"JS&#x2F;TS 中有哪些数据类型 用集合来理解 TS 数据类型 number 可看做 1、1.1、2、2.3 等所有数字值组成的集合string 可看做 a、b、ab、c、abc 等所有字符串值组成的集合boolean 可看做 true 和 false 这两个值组成的集合 JS 中的 Number、String、Boolean 只用于包装对象，一般不会用到它们；同样地在 TS 中也不会用到它们。 TS 中一般不会用 Object 来描述对象的类型，因为 Object 所表示的类型范围太大了 如何用 TS 来描述对象 用 class&#x2F;constructor 描述 用 type&#x2F;interface 描述 描述普通对象由于 object&#x2F;Object 太不精确，所以一般使用索引签名或Record 泛型来描述普通对象 使用索引签名 思考题：key 的类型可以不是 string 吗？经测试，k 的类型只能为 number、string、symbol 这三种 使用 Record 使用具体的字段1234type A = &#123; name: string; age: number;&#125;; 描述数组对象由于 Array 太不精确，所以一般用 Array&lt;?&gt; 或 string[] 或 [string, number] 来描述数组 思考题 12type A = [1, 2, 3]const a: A = ?????? 以上 TS 代码中 a 的值是？当于只有一个元素的集合，因此 a 的值只能是 [1, 2, 3] 描述函数对象由于 Function 太不精确，所以一般用 () =&gt; ? 来描述函数 1234567891011121314type FnA = (a: number, b: number) =&gt; number;type FnReturnVoid = (s: string) =&gt; void;type FnReturnUndefined = (s: string) =&gt; undefined;const v: FnReturnVoid = (s: string) =&gt; &#123; console.log(s);&#125;;const u: FnReturnUndefined = (s: string) =&gt; &#123; console.log(s); return undefined;&#125;; 带有 this 的函数声明 123456789101112type Person = &#123;name: string, age: number, sayHi: FnWithThis&#125;type FnWithThis = (this: Person, name: string) =&gt; voidconst sayHi: FnWithThis = function(name) &#123; // 此处不能使用箭头函数，因为箭头函数内不存在 this console.log(&quot;hi&quot;, this.name)&#125;const x: Person = &#123;name: &quot;vivy&quot;, age: 18, sayHi&#125;// 如果函数声明中有 this，那么调用函数时必须显示地传递这个 thisx.sayHi(&quot;Citrus&quot;)sayHi.call(x, &quot;Citrus&quot;) 描述其他对象直接用 class（构造函数） 描述即可 12345678910111213const d: Date = new Date();const r: RegExp = /ab+c/;const m: Map&lt;string, number&gt; = new Map();m.set(&#x27;xxx&#x27;, 1);const wm: WeakMap&lt;&#123; name: string &#125;, number&gt; = new WeakMap();const s: Set&lt;&#123; name: string &#125;&gt; = new Set();s.add(&#123; name: &#x27;ClariS&#x27; &#125;);const ws: WeakSet&lt;string[]&gt; = new WeakSet(); any、unknown、never 是什么从集合的角度理解：any 是全集，never 是空集，unknown 是未知集 TS 的绝大部分规则对 any 类型不生效（TS 不报错） 可对 unknown 进行断言，适用于值是从外部获取的，没办法提前知道类型的情况；比如当使用 ajax 获取数据时，后台返回的数据格式不确定，此时可将接口响应的数据类型可定义为 unknown，然后再对其进行断言 12const a: unknown = await ajax.get(&#x27;/api/users&#x27;)const b = a as number never 一般不会用来声明类型，而是用来进行类型推断的 12345678910111213type A = string | number | boolean;const a: A = &#x27;hello&#x27; as any;if (typeof a === &#x27;string&#x27;) &#123; a.split(&#x27;&#x27;);&#125; else if (typeof a === &#x27;number&#x27;) &#123; a.toFixed(2);&#125; else if (typeof a === &#x27;boolean&#x27;) &#123; a.valueOf();&#125; else &#123; a.toString(); // 报错：Property &#x27;toString&#x27; does not exist on type &#x27;never&#x27;&#125; JS 类型与 TS 类型的区别我是这么理解的： JS 这门语言其实并没有提供类型相关的关键字（如小写的 number、string、boolean），只是提供了typeof让我们获取变量的类型，所以我认为 JS 对类型非常不重视。 而 TS 则将 JS 中的类型提升到很高的位置，高到如果你把类型写错了代码就不能通过编译。因此这两门语言中的类型其实没有可比性，只是看起来有重叠部分而已。如果一定要比较，我会这么说： 粒度不同：在 JS 中的类型 number 不可再细分，而 TS 中的 number 可以看做 1、1.1、2、2.3 等无数个小类型的联合 可变性不同：JS 中的变量类型是可变的，一个 number 随时可以变成一个 string；TS 中除了 any，其他类型要么是不可变的，要么就算可变也是有限制的","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"TypeScript 的运行与调试","path":"/2022/09/07/typescript/ts-1/","content":"如何擦除类型 如何运行 TypeScript在线编辑 TypeScript Playground（缺点是 URL 太长） playcode stackblitz codesandbox 本地编辑 + 浏览器使用 vite 和 chrome 本地编辑 + Node ts-node swc-node @esbuild-kit&#x2F;esm-loader esno 如何调试 TypeScript鼠标悬浮上去看报错提示即可 学习资料推荐 编程与类型系统 TypeScript 编程 类型和程序设计语言","tags":["TypeScript"],"categories":["学习笔记","TypeScript"]},{"title":"DNS 与 TCP","path":"/2021/08/20/dns-and-tcp/","content":"一图概览image.png DNS &amp; hostsDNS，全称：Domain Name System，中文：域名系统 域名系统本身的原理是比较复杂的，但域名系统的功能很简单，就是输入一个域名，输出一个 IP，这里我们只对 DNS 做简单讨论 举例说明： 在浏览器输入 baidu.com 这个地址 浏览器需要知道你访问的这个地址对应的 IP 是多少，于是浏览器就会去问操作系统 如果操作系统也不知道，就会去问电信、移动、联通这样的网络运行商（以下简称 ISP） 当你付费之后，网络运营商就会告诉你 baidu.com 这个地址对应的 IP 是多少（假设这里 baidu.com 对应的 IP 是 1.2.3.4），然后将 IP 返回给你 浏览器获取到 baidu.com 对应的 IP 之后，就会与 1.2.3.4 这个 IP 建立 TCP 连接 细化过程： 在浏览器输入 baidu.com 这个地址的时候，浏览器首先会去检查自身是否有缓存，如果发现之前访问过 baidu.com ，那么浏览器就会直接将上一次的 IP 进行返回 如果浏览器没有缓存，就回去询问操作系统，然后操作系统首先也是会检查自身是否有缓存，如果没有就会去询问 ISP（网络运行商） 平时我们修改 hosts 这个文件，其实就是在手动给操作系统设置缓存，比如我们在 hosts 中写入baidu.com 2.3.4.5，以后每次访问 baidu.com 这个地址的时候就不会再去询问 ISP 了，直接会通过 hosts 中的设置去访问 2.3.4.5 这个 IP TCP 三次握手TCP 全称：Transmission Control Protocol，即传输控制协议 image.png 假设 A 是浏览器，B 是服务器 A 首先会向 B 发送一个叫做SYN(x)（假设这里 x &#x3D; 100）的信息 SYN 是 synchronize(同步) 的缩写，同步不是指「同步异步」中的同步，而是「同步信息」中的同步；这里的 x 一般是一个数字编号，且 x 和 y 一般都是从 0 开始的，这里我们对 x 和 y 的意义不做讨论，有兴趣的请自行研究 B 收到 A 发来的同步信息后，就会返回ACK(x+1)（101） SYN(y)（这里假设 y &#x3D; 200） ACK 是 acknowledge(知道) 的缩写 然后 A 会回复消息 ACK(y+1)（201）给 B 从以上过程中能够确保以下几件事： A 可以向 B 发送信息 B 能收到 A 发送的信息 B 也可以向 A 发送信息 A 也能收到 B 发送的信息 三次握手成功后就开始建立 TCP 连接了，建立连接后就可以开始传输内容了（一般是 HTTP 内容，也可以是其他内容，且传输的过程也可以是双向的，并非一定是单向的），HTTP 内容传输结束后，就会「关闭」 TCP 四次挥手image.png 上述内容传输完成后，A 会发送一个FIN(x) 注意：不一定是 A 先发送 FIN，也可以是 B 先发送 B 先回复ACK(x+1) 注意：关闭时的 x 和 y 一般都不是 0 然后再回复FIN(y) 步骤 2 和步骤 3 中间可能会夹杂着其他内容 A 回复ACK(y+1) 最后，A 和 B 各自关闭自己的 TCP 连接 一些 Q &amp; A为什么需要关闭 TCP 连接？因为一直保持连接会浪费内存和 CPU TCP 和 UDP 的区别是什么？ 八股文，面试必背 TCP 面向连接有状态，UDP 无状态 TCP 可靠（不丢失不重复），UDP 不可靠 TCP 传输效率较低，UDP 较高 为什么 TCP 的三次握手不能精简为两次？为了确保客户端（A端）能接收到服务端（B端）的数据（只有两次的话，无法判断 A 是否能接收到 B 的数据） 为什么 TCP 的四次挥手不能将中间两步合并成一步？因为两步中间（指发送ACK(x+1)和FIN(y)之间）往往会有其他数据需要发送，需要等其他数据发送完成之后，再发送FIN(y)","tags":["DNS","TCP"],"categories":["学习笔记"]},{"title":"浅析 Promise、Async/Await","path":"/2021/08/17/promise-async-await/","content":"Promise基本用法Promise 的简单封装与使用 1234567891011// 封装function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(Math.floor(Math.random() * 6) + 1) &#125;, 3000) &#125;)&#125;// 使用摇色子().then(success1, failed1).then(success2, failed2) Ma Mi 任务模型 Ma 指 MacroTask(宏任务)，Mi 指 MicroTask(微任务) 先 Ma 再 Mi，即先执行宏任务再执行微任务 JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务 其实最初 JS 只存在一个任务队列，为了让 Promise 回调更早执行，强行又插入了一个异步的任务队列，用来存放 Mi 任务 宏任务：setTimeout()、setInterval()、 setImmediate()、 I&#x2F;O、UI渲染（常见的定时器，用户交互事件等等） 微任务：Promise、process.nextTick、Object.observe、MutationObserver Promise 的其他 APIPromise.resolve(result): 制造一个成功（或失败）制造成功 123456789101112function 摇色子() &#123; return Promise.resolve(4)&#125;// 等价于function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(4) &#125;)&#125;摇色子().then(n =&gt; console.log(n)) // 4 制造失败 123456function 摇色子() &#123; // 此处 Promise.resolve 接收的是一个失败的 Promise 实例（状态为 reject） return Promise.resolve(new Promise((resolve, reject) =&gt; reject()))&#125;摇色子().then(n =&gt; console.log(n)) // 1 Uncaught (in promise) undefined 关于 Promise.resolve 接收参数的问题，ECMAScript 6 入门里其实说得很清楚 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例；如果参数是一个原始值，或者没有参数，Promise.resolve都会直接返回一个resolved状态的 Promise 对象。 Promise.reject(reason): 制造一个失败12345Promise.reject(&#x27;我错了&#x27;)// 等价于new Promise((resolve, reject) =&gt; reject(&#x27;我错了&#x27;))Promise.reject(&#x27;我错了&#x27;).then(null, reason =&gt; console.log(reason)) // 我错了 Promise.all(数组): 等待全部成功，或者有一个失败全部成功，将所有成功 promise 结果组成的数组返回 12Promise.all([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]) .then(values =&gt; console.log(values)) // [1, 2, 3] 只要有一个失败，就结束，返回最先被 reject 失败状态的值 12Promise.all([Promise.reject(1), Promise.resolve(2), Promise.resolve(3)]) .then(values =&gt; console.log(values)) // Uncaught (in promise) 1 Promse.all 在需要对多个异步进行处理时往往非常有用； 不过在某些特殊情况下，直接使用Promse.all就显得不那么方便了 举个例子，比如现在有 3 个请求，request1, request2 和 request3，我们需要对这 3 个请求进行统一处理，并且不管请求成功还是失败，都需要拿到所有的响应结果，如果这时候使用Promise.all([request1, request2, request3])的话，request1 请求失败了，后面的两个请求 request2, request3 就都不会执行了（这里实际上是 request1 在 rejected 之后，被 Promise.all([]).catch 给捕获了 ）。 如何解决 Promise.all() 在第一个 Promise 失败就会中断的问题？ 利用 .then() 后会返回一个状态为 resolved 的 Promise（即会自动包装成一个已resolved的promise），从而避免被 Promise.all([]).catch 捕获 123456789101112131415161718192021222324// 3 个请求const request1 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;第 1 个请求失败&#x27;) &#125;, 1000)&#125;)const request2 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;第 2 个请求失败&#x27;) &#125;, 2000)&#125;)const request3 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;第 3 个请求成功&#x27;) &#125;, 3000)&#125;)Promise.all([ request1().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;)), request2().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;)), request3().then(value =&gt; (&#123; status: &#x27;ok&#x27;, value &#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason &#125;))]).then(result =&gt; console.log(result)) 可以把对每个请求的.then操作封装一下 123456789101112const x = promiseList =&gt; promiseList.map(promise =&gt; promise.then(value =&gt; (&#123; status: &#x27;ok&#x27;, value&#125;), reason =&gt; (&#123; status: &#x27;not ok&#x27;, reason&#125;)))const xxx = promiseList =&gt; Promise.all(x(promiseList))xxx([request1(), request2(), request3()]) .then(result =&gt; console.log(result)) 打印结果如下： Promise.allSettled(数组): 等待全部状态改变12Promise.allSettled([Promise.reject(1), Promise.resolve(2), Promise.resolve(3)]) .then(result =&gt; console.log(result)) 打印结果如下： 可以看出 Promise.allSettled 的作用其实和上面我们实现的 xxx 函数的作用是一致的，因此针对上文提到场景，可以直接使用 Promise.allSettled，更加简洁。 Promise.race(数组): 等待第一个状态改变12345Promise.race([request1(), request2(), request3()]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 第 1 个请求失败&#125;) Promise.race([request1, request2, request3])里面哪个请求最先响应，就返回其对应的结果，不管结果本身是成功状态还是失败状态（这里最先响应的请求是 request1）。 一般情况下用不到 Promise.race 这个 api，不过在某些场景下还是有用的。例如在多台服务器部署了同样的服务端代码，要从一个商品列表的接口拿数据，这时候就可以在 race 中写上所有服务器中的查询商品列表的接口地址，哪个服务器响应快，就优先从哪个服务器拿数据。 Promise 的应用场景多次处理一个结果1摇色子().then(v =&gt; v1).then(v1 =&gt; v2) 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 串行 这里有一个悖论：一旦 promise 出现，那么任务就已经执行了 所以不是 promise 串行，而是任务串行 解法：把任务放进队列，完成一个再做下一个（用 Reduce 实现 Promise 串行执行） 并行Promise.all、Promise.allSettled、Promise.race都可以看作是并行地在处理任务 这里可能你会产生疑问，JS 不是单线程吗，怎么做到并行执行任务？ 这里指的是并行地做网络请求的任务，而网络请求实际上是由浏览器来做的，并非是 JS 做的，就像 setTimeout 是浏览器的功能而不是 JS 的，setTimeout 只是浏览器提供给 JS 的一个接口。 Promise 的错误处理自身的错误处理promise 自身的错误处理其实挺好用的，直接在.then的第二个回调参数中进行错误处理即可 1promise.then(s1, f1) 或者使用.catch语法糖 12// 上面写法的语法糖promise.then(s1).catch(f1) 建议总是使用catch()方法，而不使用then()方法的第二个参数，原因是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch） 全局错误处理以axios为例，Axios 作弊表 错误处理之后 如果你没有继续抛错，那么错误就不再出现 如果你继续抛错，那么后续回调就要继续处理错误 前端似乎对 Promise 不满Async&#x2F;Await替代Promise的6个理由，主要是以下 6 个方面： 简洁 错误处理 条件语句 中间值 错误栈 调试（在.then代码块中设置断点，使用 Step Over 快捷键，调试器不会跳到下一个.then，因为它只会跳过异步代码） async &#x2F; awaitasync &#x2F; await 基本用法最常见的用法 1234const fn = async() =&gt; &#123; const temp = await makePromise() return temp + 1&#125; 优点：完全没有缩进，就像是在写同步代码 封装一个 async 函数async的封装和使用 1234567891011121314function 摇色子() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(Math.floor(Math.random() * 6) + 1) &#125;, 3000) &#125;)&#125;async function fn() &#123; const result = await 摇色子() console.log(result)&#125;fn() 用try...catch进行错误处理 1234567891011121314async function 摇色子() &#123; throw new Error(&#x27;色子坏了&#x27;)&#125;async function fn() &#123; try &#123; const result = await 摇色子() console.log(result) &#125; catch (error) &#123; console.log(error) &#125;&#125;fn() 为什么需要 async在函数前面加一个async，这看起来非常多余，await所在的函数就是async，不是吗？ 理由之一： 在 ES 标准的 async&#x2F;await 出来之前，有些人自己用函数实现了 await，为了兼容旧代码里普通函数的 await(xxx)（为了将旧代码里面的 await 和新的 ES 标准里的 async&#x2F;await 区分开来），其实 async 本身并没有什么意义。 你可能会说，async函数会隐式地返回一个 Promise 对象呀，但这并不能成为必须要在函数前加async的理由，有兴趣的可以去看看知乎上关于async的讨论。 为什么js里使用了await的方法必须定义成async的？ C#中，async关键字到底起什么作用？ await 错误处理用 try&#x2F;catch 来同时处理同步和异步错误是很常见的做法 12345678910let responsetry &#123; response = await axios.get(&#x27;/xxx&#x27;)&#125; catch (e) &#123; if (e.response) &#123; console.log(e.response.status) throw e &#125;&#125;console.log(response) 但其实还有更好的写法，就像下面这样 123456789101112const errorHandler = error =&gt; &#123; console.log(error) // 注意这里要抛出一个错误 throw error // 或者 return Promise.reject(error)，注意：一定要 return&#125;// 只用一句代码就可以处理成功和失败const response = await axios.get(&#x27;/xxx&#x27;).then(null, errorHandler)// 或者使用 catch 语法糖const response = await axios.get(&#x27;/xxx&#x27;).catch(errorHandler) 需要注意的是，errorHandler函数中不要直接return一个值，一定要抛出一个错误（打断程序的运行）。因为在请求调用失败的情况下，会把errorHandler里return的值直接赋值给 response（通俗的说法就是“Promise 会吃掉错误”），在errorHandler中抛出一个错误能够保证在请求成功的情况下才会有 response，请求失败的情况下一定是会进入errorHandler函数中的 下面是一个实际的例子 123456789101112131415161718const ajax = function() &#123; return new Promise((resolve, reject) =&gt; &#123; reject(&#x27;这是失败后的提示&#x27;) // resolve(&#x27;这是成功后的结果&#x27;) &#125;)&#125;const error = (error) =&gt; &#123; console.log(&#x27;error:&#x27;, error) return Promise.reject(error)&#125;async function fn() &#123; const response = await ajax().then(null, error) console.log(&#x27;response:&#x27;, response)&#125;fn() 可以看到，我们仅仅只用了一句代码就可以同时处理 Promise 成功和失败的情况了，绝大多数的 ajax 调用都是可以用这样的方式来处理的。 所以，对于async/await，并不是一定需要使用try/catch来做错误处理的。 之前我常常陷入一个误区：就是认为await和.then是对立的，始终觉得用了await后就不应该再出现.then。 但其实并非如此，说到底async/await也只不过是.then的语法糖而已。就像上面的例子一样，.then和await完全是可以结合在一起使用的，在.then中进行错误处理，而await左边只接受成功结果。 另外，我们还可以把 4xx&#x2F;5xx 等常见错误用拦截器全局处理，errorHandler也可以放在拦截器里。 await 的传染性代码： 123console.log(1)await console.log(2)console.log(3) // await 会使这句代码变成异步的，如果想要让他立即执行，放到 await 前面即可 分析： await会使得所有它左边的和下面的代码变成异步代码 console.log(3)变成异步任务了 Promise 同样有传染性（同步变异步），放到.then回调函数中的代码会变成异步的，不过相比于await，.then下面的代码并不会变成异步的 回调没有传染性 await 的应用场景多次处理一个结果123const r1 = await makePromise()const r2 = handleR1(r1)const r3 = handleR2(r2) 串行天生串行（多个await并排时，从上到下依次执行，后面的会等前面执行完了再执行） 1234await promise1await promise2await promise3... 并行同 Promise，await Promise.all([p1, p2, p3])、await Promise.allSettled([p1, p2, p3])、await Promise.race([p1, p2, p3]) 都是并行的 循环的时候存在 bug正常情况下，即便在循环中，await也应当是串行执行的。 例如 for 循环中的 await 是串行的（后面等前面） 1234567891011121314151617181920async function runPromiseByQueue(myPromises) &#123; for (let i = 0; i &lt; myPromises.length; i++) &#123; await myPromises[i](); &#125;&#125;const createPromise = (time, id) =&gt; () =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(&quot;promise&quot;, id); resolve(); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 4 2 1 但是在某些循环中，如 forEach 和 map 中，await 会并行执行（后面不等前面） 1234567891011121314151617181920async function runPromiseByQueue(myPromises) &#123; myPromises.forEach(async (task) =&gt; &#123; await task(); &#125;);&#125;const createPromise = (time, id) =&gt; () =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; console.log(&quot;promise&quot;, id); resolve(); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 1 2 4 后面 JS 又出了一个新的东西 for await…of 来弥补这个 bug 123456789101112131415161718192021async function runPromiseByQueue(myPromises) &#123; // 异步迭代 for await (let item of myPromises) &#123; console.log(&#x27;promise&#x27;, item); &#125;&#125;const createPromise = (time, id) =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; &#123; resolve(id); &#125;, time) );runPromiseByQueue([ createPromise(3000, 4), createPromise(2000, 2), createPromise(1000, 1)]);// 4 2 1","tags":["Promise","async/await"],"categories":["学习笔记"]},{"title":"JavaScript Snippets","path":"/2021/07/23/javascript-snippets/","content":":::info收集的一些常用的 JavaScript 代码片段::: 将给定字符串中每个单词的首字母转为大写1234const capitalizeWord = (string) =&gt; string.replace(/\\b[a-z]/g, (char) =&gt; char.toUpperCase());console.log(capitalizeWord(&quot;hello world in javascript&quot;)); // Hello World In Javascript 计算给定字符串的字节长度1234const byteSize = (string) =&gt; new Blob([string]).size;console.log(byteSize(&quot;vivy&quot;)); // 4console.log(byteSize(&quot;潮鸣&quot;)); // 6 将数组元素转换为指定的 HTML 元素，主要用于将数据转换为界面 HTML 格式12345const arrayToHtmlList = (array, tag = &quot;li&quot;) =&gt; array.map((item) =&gt; `&lt;$&#123;tag&#125;&gt;$&#123;item&#125;&lt;/$&#123;tag&#125;&gt;`).join(&quot;&quot;);console.log(arrayToHtmlList([&quot;第一条&quot;, &quot;第二条&quot;])); // &lt;li&gt;第一条&lt;/li&gt;&lt;li&gt;第二条&lt;/li&gt;console.log(arrayToHtmlList([&quot;第一条&quot;, &quot;第二条&quot;], &quot;p&quot;)); // &lt;p&gt;第一条&lt;/p&gt;&lt;p&gt;第二条&lt;/p&gt; 多个数值求平均值1234567const average = (...nums) =&gt; nums.reduce((acc, val) =&gt; acc + val, 0) / nums.length;const ages = [23, 56, 15, 28];// 此代码也展示了函数如何传递不定参数（使用 ES6 扩展运算符）console.log(average(...ages)); // 30.5console.log(average(23, 56, 15, 28)); // 30.5 计算 map 数组按照指定 key 的平均值，也可以给定一个迭代函数123456789101112const averageBy = (array, fn) =&gt; array.map(typeof fn === &quot;function&quot; ? fn : (val) =&gt; val[fn]).reduce((acc, val) =&gt; acc + val, 0) / array.length;const users = [ &#123; name: &quot;saber&quot;, size: 23 &#125;, &#123; name: &quot;vivy&quot;, size: 56 &#125;, &#123; name: &quot;tico&quot;, size: 15 &#125;, &#123; name: &quot;k423&quot;, size: 28 &#125;,];const average1 = averageBy(users, (item) =&gt; item.size);const average2 = averageBy(users, &quot;size&quot;);console.log(average1); // 30.5console.log(average2); // 30.5 封装 localStorage12345678910111213141516171819202122232425const useStorage = (storageKey = &quot;authorization&quot;) =&gt; &#123; const localKey = `devpoint.local.$&#123;storageKey&#125;`; const save = (data) =&gt; &#123; window.localStorage.setItem(localKey, JSON.stringify(data)); &#125;; const get = () =&gt; &#123; const localData = window.localStorage.getItem(localKey); if (localData &amp;&amp; localData !== &quot;&quot;) &#123; return JSON.parse(localData); &#125; else &#123; return false; &#125; &#125;; const clear = () =&gt; &#123; window.localStorage.setItem(localKey, &quot;&quot;); &#125;; return &#123; save, get, clear &#125;;&#125;;const storageAuth = useStorage();const loginInfo = &#123; username: &quot;vivy&quot;, age: 18,&#125;;storageAuth.save(loginInfo);console.log(storageAuth.get()); 计算数组中某个值的重复次数123456789const countOccurrences = (array, value) =&gt; array.reduce( (accumulator, current) =&gt; current === value ? accumulator + 1 : accumulator, 0 );console.log(countOccurrences([...&quot;vivy&quot;], &quot;v&quot;)); // 2console.log(countOccurrences([1, 3, 3, 4, 3, 3, 2, 3], 3)); // 5 检查值是否属于某个数据类型123456789const isCheck = (type, val) =&gt; ![undefined, null].includes(val) &amp;&amp; val.constructor === type;console.log(isCheck(Array, [&quot;a&quot;])); // trueconsole.log(isCheck(Object, &#123;&#125;)); // trueconsole.log(isCheck(ArrayBuffer, new ArrayBuffer())); // trueconsole.log(isCheck(Boolean, new Boolean(true))); // trueconsole.log(isCheck(RegExp, /./g)); // trueconsole.log(isCheck(Number, 0)); // true 遍历对象的每个属性，并分别为每个属性迭代一个回调123456789101112const forObject = (obj, callback) =&gt; Object.keys(obj).forEach((key) =&gt; callback(obj[key], key, obj));const testObj = &#123; word: &quot;信じる心があなたの魔法〜&quot;, author: &quot;篝敦子&quot;,&#125;;forObject(testObj, (val, key) =&gt; &#123; console.log(`$&#123;key&#125;:$&#123;val&#125;`);&#125;);// word:信じる心があなたの魔法〜// author:篝敦子 通过键值查找对象，返回满足给定函数的第一个 key12345678910const findKey = (obj, fn) =&gt; Object.keys(obj).find((key) =&gt; fn(obj[key], key, obj));const testObj = &#123; vivy: &#123; age: 17 &#125;, k423: &#123; age: 18 &#125;, saber: &#123; age: 19 &#125;,&#125;;console.log(findKey(testObj, (item) =&gt; item.age &gt; 18)); // saber 将一组数据按照指定的 key 的进行分组，并按照分组进行归类1234567891011121314151617181920212223242526272829303132333435363738const groupBy = (obj, key) =&gt; &#123; const values = obj instanceof Map || obj instanceof Set ? Array.from(obj.values()) : Object.values(obj); return values.reduce((acc, value) =&gt; &#123; const groupKey = value[key]; if (!Array.isArray(acc[groupKey])) &#123; acc[groupKey] = [value]; &#125; else &#123; acc[groupKey].push(value); &#125; return acc; &#125;, &#123;&#125;);&#125;;const arrayRoles = [ &#123; title: &quot;Mieruko-chan&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Vladilena Mirizé&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Nakano Azusa&quot;, category: &quot;xxx&quot; &#125;, &#123; title: &quot;Shirahane Suou&quot;, category: &quot;yyy&quot; &#125;, &#123; title: &quot;Mio Akiyama&quot;, category: &quot;yyy&quot; &#125;,];console.log(groupBy(arrayRoles, &quot;category&quot;));/*&#123; &#x27;xxx&#x27;: [ &#123; title: &#x27;Mieruko-chan&#x27;, category: &#x27;xxx&#x27; &#125;, &#123; title: &#x27;Vladilena Mirizé&#x27;, category: &#x27;xxx&#x27; &#125;, &#123; title: &#x27;Nakano Azusa&#x27;, category: &#x27;xxx&#x27; &#125; ], &#x27;yyy&#x27;: [ &#123; title: &#x27;Shirahane Suou&#x27;, category: &#x27;yyy&#x27; &#125;, &#123; title: &#x27;Mio Akiyama&#x27;, category: &#x27;yyy&#x27; &#125; ]&#125;*/","tags":["JavaScript Snippets","Tool function"],"categories":["学习笔记"]},{"title":"第三方应用授权：OAuth 2.0","path":"/2021/06/21/oauth2.0/","content":"介绍OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。 简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（access_token），用来代替密码，供第三方应用使用。 OAuth 2.0 的优点：保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全 令牌与密码的区别令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。 令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。 令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。 令牌有权限范围（scope）。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。 :::warning只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。::: 四种授权类型（authorization grant）即四种颁发令牌的方式： 授权码（authorization-code） 隐藏式（implicit） 密码式（password）： 客户端凭证（client credentials） :::primary不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。::: 第一种授权方式：授权码授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。:::info这种方式是&#x3D;&#x3D;最常用的流程&#x3D;&#x3D;，安全性也最高，它适用于那些++有后端的 Web 应用++{.wavy .success}。授权码通过前端传送，++令牌则是储存在后端++{.dot}，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。::: 举例说明： A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用 12345https://b.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。 用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码 1https://a.com/callback?code=AUTHORIZATION_CODE A 网站拿到授权码以后，就可以&#x3D;&#x3D;在后端&#x3D;&#x3D;，向 B 网站请求令牌 123456https://b.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL client_id参数和client_secret参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri参数是令牌颁发后的回调网址。 B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据 123456789&#123; &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;token_type&quot;:&quot;bearer&quot;, &quot;expires_in&quot;:2592000, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, &quot;scope&quot;:&quot;read&quot;, &quot;uid&quot;:100101, &quot;info&quot;:&#123;...&#125;&#125; access_token字段就是令牌，A 网站在后端拿到了。 第二种方式：隐藏式有些 Web 应用是&#x3D;&#x3D;纯前端应用&#x3D;&#x3D;，没有后端。这时就不能用上面的方式了，必须++将令牌储存在前端++{.dot}。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式++没有授权码这个中间步骤++{.dot}，所以称为（授权码）”隐藏式”（implicit）。 A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用 12345https://b.com/oauth/authorize? response_type=token&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read response_type参数为token，表示要求直接返回令牌。 用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。 1https://a.com/callback#token=ACCESS_TOKEN token参数就是令牌，A 网站因此直接在前端拿到令牌。 :::info注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。另外，这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。::: 第三种方式：密码式如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。 A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。 12345https://oauth.b.com/token? grant_type=password&amp; username=USERNAME&amp; password=PASSWORD&amp; client_id=CLIENT_ID grant_type参数是授权方式，这里的password表示”密码式”，username和password是 B 的用户名和密码。 B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 响应，A 因此拿到令牌。 :::danger这种方式需要用户给出自己的用户名&#x2F;密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。::: 第四种方式：凭证式最后一种方式是凭证式（client credentials），适用于++没有前端的命令行应用++{.dot}，即在命令行下请求令牌。 A 应用在命令行向 B 发出请求。 1234https://oauth.b.com/token? grant_type=client_credentials&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET grant_type参数等于client_credentials表示采用凭证式，client_id和client_secret用来让 B 确认 A 的身份。 B 网站验证通过以后，直接返回令牌 :::info这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。::: 令牌的使用A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。 此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。 12curl -H &quot;Authorization: Bearer ACCESS_TOKEN&quot; \\&quot;https://api.b.com&quot; 更新令牌令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。 具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。 12345https://b.com/oauth/token? grant_type=refresh_token&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; refresh_token=REFRESH_TOKEN grant_type参数为refresh_token表示要求更新令牌，client_id参数和client_secret参数用于确认身份，refresh_token参数就是用于更新令牌的令牌。 B 网站验证通过以后，就会颁发新的令牌。","tags":["OAuth 2.0","第三方应用授权"],"categories":["学习笔记"]},{"title":"npm & package.json","path":"/2021/06/17/npm&package.json/","content":"npm 是什么npm 是 Node.js 的包管理工具，Node.js package manger，通过 npm Node.js 可以方便地使用第三方开发的开源模块，同时也可以把自己的模块发布到 npm 供其它开发者使用。 npm 主要由三部分组成： npm website：https://npmjs.com，开发者查找发现 package 的站点 CLI（命令行）：开发者可以使用命令行工具和 npm 进行交互，对 package 进行安装、更新、删除等操作 registry（注册表）：package 及其元信息存储的数据库 :::info注册表是一个巨大的数据库，保存了每个包（package）的信息。例如我们要查询 vue 包的信息，可以访问https://registry.npmjs.org/vue，就会看到 vue 模块所有版本的信息。模块名后面，还可以跟上版本号或者标签，用来查询某个具体版本的信息，例如：https://registry.npmjs.org/vue/3.0.0 查看 vue 3.0.0 版本的信息具体用法就是，https://registry.npmjs.org/模块名/版本号::: yarnyarn 是 Facebook 2017 年推出的和 npm 功能类似的包管理工具，主要解决当时 npm 的几个核心问题 安装包不够快速与稳定 存在安全隐患 同时 yarn 的 cli 工具提供了更简单的命令，当然面对 yarn 带来的压力，npm 在 5.0 后提供了类似的改进，两者现在差距不再巨大，开发者可以根据个人习惯和项目规范自由选择（我个人更喜欢使用 yarn） npxnpm 从5.2版本开始，增加了 npx 命令，npx 想要解决的主要问题，就是调用项目内部安装的模块。原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在；如果存在，则执行；不存在，则进行临时安装，然后执行，执行完毕后将包删除。 对 npx 的详细介绍见npx使用教程 package.jsonnpm 通过 Node.js 模块根目录的 package.json 文件获取模块元数据和依赖关系等，例如react 的 package.json 包含如下信息:::info可以通过npm init -y或者yarn init -y生成一份默认的 package.json 配置::: react 的 package.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; &quot;name&quot;: &quot;react&quot;, &quot;description&quot;: &quot;React is a JavaScript library for building user interfaces.&quot;, &quot;keywords&quot;: [ &quot;react&quot; ], &quot;version&quot;: &quot;17.0.3&quot;, &quot;homepage&quot;: &quot;https://reactjs.org/&quot;, &quot;bugs&quot;: &quot;https://github.com/facebook/react/issues&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;files&quot;: [ &quot;LICENSE&quot;, &quot;README.md&quot;, &quot;build-info.json&quot;, &quot;index.js&quot;, &quot;cjs/&quot;, &quot;umd/&quot;, &quot;jsx-runtime.js&quot;, &quot;jsx-dev-runtime.js&quot;, &quot;unstable-shared-subset.js&quot; ], &quot;main&quot;: &quot;index.js&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &#123; &quot;react-server&quot;: &quot;./unstable-shared-subset.js&quot;, &quot;default&quot;: &quot;./index.js&quot; &#125;, &quot;./index&quot;: &#123; &quot;react-server&quot;: &quot;./unstable-shared-subset.js&quot;, &quot;default&quot;: &quot;./index.js&quot; &#125;, &quot;./build-info.json&quot;: &quot;./build-info.json&quot;, &quot;./jsx-runtime&quot;: &quot;./jsx-runtime.js&quot;, &quot;./jsx-dev-runtime&quot;: &quot;./jsx-dev-runtime.js&quot;, &quot;./&quot;: &quot;./&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/facebook/react.git&quot;, &quot;directory&quot;: &quot;packages/react&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=0.10.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;loose-envify&quot;: &quot;^1.1.0&quot;, &quot;object-assign&quot;: &quot;^4.1.1&quot; &#125;, &quot;browserify&quot;: &#123; &quot;transform&quot;: [ &quot;loose-envify&quot; ] &#125;&#125; namename 是模块的唯一标识，安装、使用模块都需要使用模块的 name，可以使用字母（只能使用小写字母）、数字、_、-和.，例如安装和使用 vue 需要用到如下命令 1yarn add vue 1import &#123;inject, Ref&#125; from &#x27;vue&#x27; 可以通过 scope 组织具有相关性的模块，模块名义@开头的包就是一个 scoped package，scope 就是@和/之间的内容 1@scope/project-name 例如@antv&#x2F;g2plot version版本号遵从语义化版本规范，使用x.y.z形式，对应主版本.次版本.修订版本 ，版本号递增规则如下： 主版本（major）：当你做了不兼容的 API 修改，一般改动很大，不兼容低版本 次版本（minor）：当你做了向下兼容的功能性新增，兼容同一个大版本的 API 和用法 修订版本（patch）：当你做了向下兼容的问题修正，一般用来修复 bug 先行版本x.y.z格式是模块正式版本，重要模块为了保证稳定，会在放出正式版本之前提供先行版本 alpha: 内部版本 beta: 公测版本 rc: Release candidate，正式版本的候选版本 stable: 稳定版 csp 例：npm 上 vue 部分版本记录 这种特殊版本除非开发者&#x3D;&#x3D;精确声明使用&#x3D;&#x3D;，例如npm install vue@3.0.0-rc.13，否则npm install不会自动安装对应版本内容 快捷命令npm 提供了快捷升级命令 升级主版本号：npm version major 升级次版本号：npm version minor 升级修订版本号：npm version patch 设置版本号为指定的版本号：npm version 版本号 升级先行版本号：npm version prerelease 升级先行版本号并指定先行版本的名字：npm version prerelease --preid=&lt;prerelease-id&gt; 示例： 1234567# 假定现在的版本号是1.1.1npm version major # 2.0.0npm version minor # 1.2.0npm version patch # 1.1.2npm version prerelease # 1.1.2-0npm version prerelease --preid=alpha # 1.1.2-alpha.0npm version 4.1.2 # 4.1.2 :::info执行npm version修改完版本号之后，还会默认执行 git add -&gt; git commit -&gt; git tag 操作，commit 的信息和为 tag 均为版本号，且该步骤应在npm publish之前进行。::: tagnpm 中的 tag 类似于 git 中的 branch ，发布者可以在指定的 tag 上进行发版，使用者可以选择指定 tag 来安装，默认的 tag 是latest。这对于我们日常开发非常有用，很多时候我们想要发布版本来进行验证功能，但是又不想影响正在使用的人，我们就可以利用 tag 和先行版本来进行发包。 12npm publish --tag alpha # 发版到名为 alpha 的 tag 上npm i &lt;package&gt;@&lt;tag&gt; # 从指定 tag 上安装包 dependencies &amp; devDependenciesdependencies 和 devDependencies 字段用来表示模块的依赖和开发环境依赖，模块依赖的版本号有些几种不同写法，来保证安装的时候使用对应的版本 x.y.z 使用精确版本号 * 任意版本，第一次安装会使用模块最新版本 ^x.y.z x 位锁死，y、z 位使用最新版本 3.x和^3.0.0含义相同，x 位使用指定版本，y、z 位使用最新 ~x.y.z x、y 锁定，z 位使用最新版本 npm 提供了快捷命令，可以在安装的时候就自动把对应内容写到 package.json 中 12npm install &lt;package_name&gt; --save # 安装模块并写入 dependenciesnpm install &lt;package_name&gt; --save-dev # 安装模块并写入 devDependencies peerDependencies有时候模块需要与宿主模块共享依赖，也就是有可能会用到某个模块，但自己不安装，希望宿主环境安装的时候使用 peerDependencies 声明，比如 react-dom 的 package.json 的使用 12345678&quot;dependencies&quot;: &#123; &quot;loose-envify&quot;: &quot;^1.1.0&quot;, &quot;object-assign&quot;: &quot;^4.1.1&quot;, &quot;scheduler&quot;: &quot;^0.20.1&quot;&#125;,&quot;peerDependencies&quot;: &#123; &quot;react&quot;: &quot;17.0.3&quot;&#125; repositoryrepository 用来指定模块源代码信息 12345&quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/facebook/react.git&quot;, &quot;directory&quot;: &quot;packages/react&quot;&#125; main 字段main 字段用来标识模块的默认入口文件，比如 react main: &quot;index.js&quot; ，下面两句写法含义相同 12const react = require(&#x27;react&#x27;);const react = require(&#x27;react/index.js&#x27;); 发布 package 在 npmjs.com 上注册账号 在++命令行++{.dot}使用npm login登录 使用npm publish进行发布 :::warning在进行npm publish操作前，请确认使用的是 npm 官方源，如果当前使用的是非官方源，可以使用npm config set registry https://registry.npmjs.org或者nrm切换至 npm 官方源:::","tags":["npm","package.json"],"categories":["学习笔记"]},{"title":"Google 搜索技巧","path":"/2021/03/01/google-search-skills/","content":"使用引号强制进行精确匹配搜索:::default no-icon“what is javascript”::: AND运算符将只返回与这两个术语相关的结果:::default no-iconhtml AND css::: 使用OR运算符获取与其中一个搜索词相关的结果:::default no-icon(javascript OR python) free course或者(javascript | python) free course::: search_skill_03 -运算符将排除包含以下术语或短语的结果:::default no-iconjavascript -css::: search_skill_04 使用*通配符作为占位符，它将被任何单词或短语替换:::default no-icon“how to start * in 6 months”::: search_skill_05 在单个网站内搜索:::default no-iconsite:freecodecamp.org::: search_skill_06 也可以用site:来限制搜索结果的顶级域，例如.com、.edu、.org search_skill_06 查找特定的文件类型:::default no-iconfiletype:pdf learn css或者ext:pdf learn css::: search_skill_07 搜索一个数字范围:::default no-iconecmascript 2016..2018::: search_skill_08","tags":["Google 搜索技巧"],"categories":["其他"]},{"title":"浅析前端路由","path":"/2021/02/22/frontend-routing/","content":"什么是前端路由用最简单的话来说就是，页面间的跳转仅由前端来控制，而不需要向后端发起请求。前端路由反映的是URL和组件之间的映射关系。 前端路由反映的是 URL 和组件之间的映射关系 route_01 如何实现前端路由vue-router 中有 3 种路由模式：hash、history、abstract（不常用），这里仅介绍下 hash 模式和 history 模式的简单实现 hash 模式早期的前端路由的实现就是基于 location.hash 来实现的。实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#first’。 1http://www.example.com#first hash 路由模式的实现主要基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，&#x3D;&#x3D;hash 部分并不会被发送&#x3D;&#x3D;； hash 值的任意改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过&#x3D;&#x3D;浏览器的回退、前进按钮&#x3D;&#x3D;来控制 hash 的切换； 通过&#x3D;&#x3D;设置 a 标签的 href 属性&#x3D;&#x3D;，当用户点击这个标签后，URL 的 hash 值会发生改变；或者直接&#x3D;&#x3D;对 loaction.hash 进行赋值&#x3D;&#x3D;，改变 URL 的 hash 值； 通过浏览器原生的hashchange事件来++监听 hash 值的变化++{.dot .warning}，从而对页面进行跳转（渲染）。 1234567891011121314151617181920212223242526272829303132333435&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--渲染对应组件的地方--&gt;&lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 第一次加载的时候，不会执行 hashchange 监听事件，默认执行一次 // DOMContentLoaded 为浏览器 DOM 加载完成时触发 window.addEventListener(&#x27;DOMContentLoaded&#x27;, Load) window.addEventListener(&#x27;hashchange&#x27;, HashChange) // 展示页面组件的节点 var routeView = null function Load() &#123; routeView = document.getElementById(&#x27;route-view&#x27;) HashChange() &#125; function HashChange() &#123; // 每次触发 hashchange 事件，通过 location.hash 拿到当前浏览器地址的 hash 值 // 根据不同的路径展示不同的内容 switch(location.hash) &#123; case &#x27;#/page1&#x27;: routeView.innerHTML = &#x27;page1&#x27; return case &#x27;#/page2&#x27;: routeView.innerHTML = &#x27;page2&#x27; return default: routeView.innerHTML = &#x27;page1&#x27; return &#125; &#125;&lt;/script&gt; :::info这仅是最简易的实现，真实的 hash 模式，还要考虑到很多复杂的情况，具体情况可以去看 Vue Router 的源码。::: history 模式history 模式的实现基于 HTML5 提供的 History API，其中最主要的 API 为：history.pushState()和history.repalceState()。这两个 API 均可在不刷新页面的情况下，对浏览器的历史纪录进行操作。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。 history 路由模式的实现主要基于下面几个特性： 通过 pushState 和 repalceState 这两个 API 来操作实现 URL 的变化（实际上是改变了浏览器的location.pathname属性值） ； 通过浏览器原生的popstate事件来&#x3D;&#x3D;监听浏览器动作的变化&#x3D;&#x3D;，从而对页面进行跳转（渲染）； 但history.pushState()或history.replaceState()只能改变 URL，并不会触发 popstate 事件，需要&#x3D;&#x3D;手动触发页面跳转（渲染）&#x3D;&#x3D;。 :::info需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在 Javascript 代码中调用history.back()或者history.forward()方法）（摘自 MDN 对 popstate 的解释）::: 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&#x27;DOMContentLoaded&#x27;, Load) window.addEventListener(&#x27;popstate&#x27;, PopChange) var routeView = null function Load() &#123; routeView = document.getElementById(&#x27;route-view&#x27;) // 默认执行一次 popstate 的回调函数，匹配一次页面组件 PopChange() // 获取所有带 href 属性的 a 标签节点 var aList = document.querySelectorAll(&#x27;a[href]&#x27;) // 遍历 a 标签节点数组，阻止默认事件，添加点击事件回调函数 aList.forEach(aNode =&gt; aNode.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault() //阻止a标签的默认事件 var href = aNode.getAttribute(&#x27;href&#x27;) // 手动修改浏览器的地址栏 history.pushState(null, &#x27;&#x27;, href) // 通过 history.pushState 手动修改地址栏， // popstate 是监听不到地址栏的变化，所以此处需要手动执行回调函数 PopChange PopChange() &#125;)) &#125; function PopChange() &#123; console.log(&#x27;location&#x27;, location) switch(location.pathname) &#123; case &#x27;/page1&#x27;: routeView.innerHTML = &#x27;page1&#x27; return case &#x27;/page2&#x27;: routeView.innerHTML = &#x27;page2&#x27; return default: routeView.innerHTML = &#x27;page1&#x27; return &#125; &#125;&lt;/script&gt; 以上代码的思路：通过遍历页面上的所有 a 标签，阻止 a 标签的默认事件的同时，加上点击事件的回调函数，在回调函数内获取 a 标签的 href 属性值，再通过 pushState 去改变浏览器的 location.pathname 属性值。然后手动执行 popstate 事件的回调函数，去匹配相应的路由。 :::warning这里注意，以上代码不能在浏览器直接打开静态文件（会报错），需要通过 web 服务，启动端口去浏览网址。::: 单页面应用 v.s. 多页面应用对前端来说，路由概念的出现是伴随着SPA出现的；在SPA出现之前，页面的跳转(导航)都是通过服务端来控制的，并且页面跳转存在一个明显白屏跳转过程；SPA出现后，用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染，就不再让服务端控制页面跳转了，于是前端路由出现了，前端可以自由控制组件的渲染，来模拟页面跳转。 单页面应用和多页面应用的对比如下： 单页面应用（SinglePage Web Application，SPA） 多页面应用（MultiPage Application，MPA） 组成 一个外壳页面和多个页面片段组成 多个完整页面构成 资源共用（css，js） 共用，只需在外壳部分加载 不共用，每个页面都需要加载 刷新方式 页面局部刷新或更改 整页刷新 URL 模式 xxx.com/#/firstxxx.com/#/second xxx.com/#/first.htmlxxx.com/#/second.html 用户体验 页面片段间切换快，用户体验好 页面切换加载缓慢，流畅度不够，用户体验较差 转场动画 容易实现 无法实现 数据传递 容易 依赖 URL 传参，或者 cookie、localStorage 等 搜索引擎优化（SEO） 需要单独方案、实现较为困难、不利于SEO检索、可利用服务端渲染（SSR）优化 容易实现 使用范围 高要求的体验度、追求界面流畅的应用（一般是后台管理系统） 适用于追求高度支持搜索引擎的应用 维护成本 相对容易 相对复杂","tags":["前端路由"],"categories":["学习笔记"]},{"title":"Vue 两个版本的区别（完整版 v.s. 运行时版）","path":"/2020/06/30/vue-difference-version/","content":"使用 Vue 实例的三种方式 方法一：从 HTML 得到视图 使用「完整版 Vue」 通过 cdn 或 import 来引入 vue.js 或者 vue.min.js 将视图写在 HTML 中或者写在 template 选项中 方法二：用 JS 来构建视图 使用「非完整版 Vue」 通过 cdn 或 import 来引入 vue.runtime.js 或者 vue.runtime.min.js 使用 render 函数 方法三：使用 vue-loader（webpack 的一个 loader） 使用「非完整版 Vue」 vue-loader 可以把 *.vue 文件翻译成 h 构建方法 这种做法的缺点是，HTML 内就只有一个 div#app，对 SEO 不友好 完整版（运行时 + 编译器） v.s. 非完整版（只包含运行时）对比如下： Vue 完整版 （运行时 + 编译器） Vue 非完整版（只包含运行时） 评价 特点 有 compiler 没有 compiler compiler 占 30% 体积 视图 写在 HTML 中或者写在 template 选项中 写在 render 函数里用 h 来创建标签 h 是尤雨溪写好传给 render 的 cdn 引入 vue.js vue.runtime.js 文件名不同，生产环境后缀为 .min.js webpack 引入 需要配置 alias 默认使用此版 尤雨溪配置的 @vue&#x2F;cli 引入 需要额外配置 默认使用此版 尤雨溪、蒋豪群配置的 1234567891011// 需要编译器new Vue(&#123; template: &#x27;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#x27;&#125;)// 不需要编译器new Vue(&#123; render (h) &#123; return h(&#x27;div&#x27;, this.hi) &#125;&#125;) 当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。 最佳实践：总是使用非完整版，然后配合vue-loader 和 vue 单文件组件。 Vue 作者的思路： 为了保证用户体验，让用户下载的 JS 文件体积更小，但只支持 h 函数 为了保证开发体验，让开发者可以直接在 vue 文件里写 HTML 标签，而不写 h 函数 由此发明了 vue-loader，脏活儿让 loader 来做，vue-loader 把 vue 文件里的 HTML 转为 h 函数 SEO 基本原理 全称：Search Engine Optimization，中文：搜索引擎优化 你可以认为搜索引擎就是在不停的发起 curl 搜索引擎根据 curl 的结果来猜测页面的内容 如果页面的内容是通过 JS 渲染上去的，则不利于 SEO JS 创建 div 比如 Vue 的 HTML 内初始就只有一个 div#app，这个 div 的内容是通过 JS 后面填充进去的，因此 Vue 不利于 SEO（可以用 SSR 来解决 Vue 的 SEO 问题） 解决「SEO 不友好」方法： 原则上只要让 curl 能得到页面的信息，SEO 就能正常工作 把 title、description、keyword、meta、h1、a 写好即可 百度的 SEO 就是个笑话，充钱你就能变强 Google 其实可以获取 JS 创建的内容，但毕竟在墙外，国内还是别想了","tags":["Vue","SEO","Vue compiler"],"categories":["学习笔记"]},{"title":"朋友们","path":"/friends/index.html","content":"Notev優萌初華云之巅涼風桜雨星日语Hairy'Blog"}]